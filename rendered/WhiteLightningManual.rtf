{\rtf1\ansi\deff0\n{\fonttbl{\f0 Consolas;}}{\info{\author Richard Milne (RichMilne AT users DOT noreply DOT github DOT com)}{\version134}{\creatim\yr2023\mo2\dy1\hr22\min19}{\subject Revision: 134, 2023-02-01 22:19:28}{\keywords http://www.worldofspectrum.org/infoseekid.cgi?id=0008967}{\title White Lightning Documentation - Manual}}
\fs18
                           {\b WHITE LIGHTNING}\par
\par
                          {\b by OASIS SOFTWARE}\par
\par
\par
\par
{\b Copyright Notice}\par
\par
Copyright \'a9 1984 by Oasis Software.  No part of this manual may be\par
reproduced on any media without prior written permission from Oasis\par
Software.\par
\par
\par
\par
{\b This Manual}\par
\par
Piracy has reached epidemic proportions and it is with regret that we are\par
forced to reproduce this manual in a form which cannot be photocopied.  Our\par
apologies for the inconvenience this may cause to our genuine customers.  A\par
reward will be paid for information leading to the successful prosecution\par
of parties infringing this Copyright Notice.\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
                       {\b Copyright \'a9 by Oasis Software}\page
                       {\b CONTENTS}\par
\par
\par
\par
                                                       {\b Page}\par
\par
{\b INTRODUCTION}                                             {\b 1}\par
\par
{\b OPERATING INSTRUCTIONS}                                   {\b 3}\par
\par
{\b SPRITE GENERATOR PROGRAM}                                 {\b 4}\par
    Introduction                                         {\b 4}\par
    Operating Instructions                               {\b 6}\par
    Getting Familiar with the Function Keys              {\b 6}\par
\par
{\b SPECTRA FORTH}                                           {\b 18}\par
    Introduction                                        {\b 19}\par
    Input/Output Operators                              {\b 19}\par
    Mathematical Operators                              {\b 21}\par
    Stack Operations                                    {\b 24}\par
    Other Operations                                    {\b 25}\par
    Colon Definitions                                   {\b 26}\par
    Control Structures                                  {\b 27}\par
    Conditional Branching                               {\b 28}\par
    Constants and Variables                             {\b 32}\par
    Other Commonly Used Forth Words                     {\b 32}\par
    Using the Editor                                    {\b 33}\par
    Forth Error Messages                                {\b 35}\par
\par
{\b IDEAL}                                                   {\b 38}\par
    Introduction                                        {\b 38}\par
    IDEAL Variables                                     {\b 40}\par
    Errors                                              {\b 42}\par
    Sprite Buffer Organisation                          {\b 42}\par
    Loading Sprites from Tape                           {\b 43}\par
    The Buffer                                          {\b 43}\par
    Background Scrolling                                {\b 43}\par
    IDEAL Mnemonics                                     {\b 44}\par
    General Points                                      {\b 45}\par
    Sprite Utilities                                    {\b 48}\par
    Scrolling                                           {\b 52}\par
    GETs and PUTs                                       {\b 55}\par
    Sprite Transformations                              {\b 59}\par
    Interrupt Related Words                             {\b 61}\par
    BASIC Interface Words                               {\b 62}\par
    Miscellaneous Words                                 {\b 62}\par
    Forth/BASIC Words                                   {\b 66}\par
    Foreground/Background                               {\b 67}\par
    Logical Operations                                  {\b 71}\par
    Collision Detection and Sprite Recognition          {\b 73}\par
    The BASIC Interface                                 {\b 76}\par
    Program Development                                 {\b 79}\par
    Table of Screen Addresses                           {\b 82}\par
    Function Key Summary                                {\b 83}\par
    Arcade Graphics Library                             {\b 89}\par
    Demo Sprite Library                                 {\b 89}\page
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
                                                       {\b Page}\par
\par
{\b FIG-FORTH GLOSSARY}                                      {\b 91}\par
\par
{\b IDEAL GLOSSARY}                                         {\b 119}\par
\par
{\b FORTH/BASIC GLOSSARY}                                   {\b 124}\par
\par
{\b USR CALLS}                                              {\b 125}\par
\par
{\b EXTENDED SPECTRA FORTH GLOSSARY}                        {\b 125}\par
\par
{\b THE DEMO - A BRIEF DESCRIPTION}                         {\b 126}\par
\par
{\b SOME SIMPLE PROGRAMMING EXAMPLES}                       {\b 129}\page
                                {\b WHITE LIGHTNING}\par
                               {\b by Oasis Software}\par
\par
\par
{\b INTRODUCTION}\par
\par
White Lightning is a high level graphics development system for the Spectrum 48k.\par
It is aimed primarily at the user who has commercial games writing in mind and has\par
the patience to learn a sizeable new language.  It is not a games designer and\par
stunning results probably won't be produced overnight, but it does have the power\par
and flexibility to produce software of a commercial standard (with a little\par
perseverance!).  Software produced using White Lightning can be marketed without\par
restriction, although, we would be very grateful if you felt you could pop a small\par
credit on the sleeve.  If you're looking for a publisher - don't forget us!\par
\par
Assembly language has three advantages over high level languages:  speed,\par
flexibility and compactness.  During the running of an arcade game, the processor\par
spends most of its time manipulating screen data, and if the appropriate commands\par
are implemented in the language, the execution "overhead" is very small.  Add to\par
this the fact that considerable time has been spent on the routines themselves to\par
optimise execution speed, and we feel most machine code programmers would be hard\par
pressed to better White Lightning for speed.  As far as flexibility is concerned,\par
White Lightning has almost 300 commands as well as access to BASIC and machine\par
language if required.  A lot of the tricky routines like rotations and\par
enlargements are already implemented for you.  As far as compactness goes, Forth\par
itself produces very compact code, but there is, of course, the overhead of the\par
language itself.  Assembly language has four major drawbacks.  Firstly, you've got\par
to learn it.  Having mastered machine code, program development is very slow\par
compared with a typical high level language, there is no "crash protection"\par
whatsoever, and to produce effective results, you need a fairly intimate knowledge\par
of the machine you're working with.\par
\par
BASIC has several points in its favour, these are: excellent crash protection,\par
extremely readable source code and a relatively short learning curve.  These\par
features make BASIC a very good introduction to programming for the hobbyist, but\par
for the serious games writer, the language is insufficient in terms of both its\par
speed and flexibility.\par
\par
Because White Lightning is Forth based it has virtually the speed of machine code,\par
no knowledge of the machine is required, the source code is relatively readable,\par
and it is fairly well protected from crashing.\par
\par
If you do have any queries concerning White Lightning, then we can be contacted by\par
phone on (0934) 419921.  If possible, please restrict calls to the periods 9 am to\par
11 am or 6 pm to 6.30 pm.  If this is not convenient we are here all day.  If your\par
query is a detailed one then it's probably better to write in.  We are also\par
interested to hear of any extensions or routines you may develop, and if\par
sufficient interest is shown we will start a News Letter, and possibly, even a\par
User Group.\par
\par
\par
{\b SPRITE DEVELOPMENT}\par
\par
Included with White Lightning is a sprite generator. This comes complete with a\par
pre-defined character set which, when suitably combined, makes up to 167 full\par
characters. The predefined characters cover Asteroids, Pac-Man, Scramble,\par
Defender, Space Invaders, City Bomber, Lunar Lander, Frogger, Centipede, Donkey\par
Kong and many more. You can use them as they are, customise them, or design up to\par
255 of your own sprites. The development software allows you to reflect, spin or\par
invert. When you have finished work, or between sessions the whole lot can be\par
simply saved to tape.\par
\par
\par
\par
1\page
{\b IDEAL}\par
\par
The main part of the package is the White Lightning language itself. The language\par
can be thought of as being divided into two parts: firstly, there is a super fast\par
integer Forth, which conforms to a standard Fig-Forth, but secondly, and of most\par
importance to games designers, there is the IDEAL sub-language. IDEAL stands for\par
"Interrupt Driven Extendable Animation Language".  IDEAL has a dictionary of over\par
100 words, which can be freely mixed with Forth, or, as we shall see, can be\par
accessed from BASIC.\par
\par
\par
{\b Interrupt Driven}\par
\par
Forth/IDEAL words can be executed under interrupt; this means that programs can be\par
run in foreground and background at the same time. Suppose, for instance, the\par
program you are writing involves a scrolling backdrop, which has been defined in a\par
sprite 6 screens wide. A program can be run in background to handle the scrolling\par
backdrop, and a separate program written in foreground to control all of the\par
characters which move within the backdrop. This will free the user from complex\par
timing calculations to get a smooth scroll and is one of the most powerful\par
features of the entire package.  Background words can be executed up to 50 times a\par
second.\par
\par
\par
{\b Extendable}\par
\par
Forth is extendable and was chosen as the most suitable host language for IDEAL\par
because of this extremely useful feature. New words can be defined in terms of any\par
of the Forth/IDEAL words, or your own previously defined words. This means you can\par
create diagonal scrolls for instance, by combining individual scrolls.\par
\par
\par
{\b Animation Language}\par
\par
Very careful planning went into the designing of the IDEAL animation language, to\par
make it as portable as possible between micros. If you've written a very\par
successful program for one micro, you can move the same code across without too\par
much difficulty. The only major changes necessary, are changes to accommodate the\par
different screen formats, ie the number of columns and rows.  You don't need to\par
worry about the complexities of various memory mappings, IDEAL does that for you.\par
Some implementations will not allow attributes to be moved separately from pixel\par
data, so to be certain of higher portability, move attributes and data together.\par
\par
\par
{\b ACCESS FROM BASIC}\par
\par
If you are not familiar with Forth and want to get reasonable software quickly,\par
you can access the IDEAL language from BASIC. Programs will no longer be portable\par
and you won't get quite the same speed and polish, but perfectly good programs\par
can, and have, been written this way. More memory will be used for BASIC source,\par
so bear all this in mind before deciding to put off learning Forth!  Most of the\par
useful BASIC commands that handle sound and graphics, such as DRAW, CIRCLE, BEEP\par
and so on, have been implemented in Spectra Forth. Whenever possible, call them\par
from Forth and not BASIC. The interpretation and initial floating point\par
manipulation of BASIC commands are avoided, and commands will therefore execute\par
more rapidly from Forth.\par
\par
\par
\par
\par
\par
\par
\par
\par
                                                                                 2\page
{\b OPERATING INSTRUCTIONS}\par
\par
1)  Rewind the tape marked "White Lightning".  Disconnect Interface\par
    1 if fitted.\par
\par
2)  Load using LOAD"" then stop the tape.  White Lightning will auto-run.\par
\par
3)  Once loaded, you will get the prompt LOAD SPRITES Y/N.\par
\par
4)  If it's the first time you've used the package, type Y to load the\par
    demonstration sprites, which will follow directly after White Lightning on\par
    the same tape.  There is a section of data before the sprites which doesn't\par
    load, but don't worry about this, this is information used by the sprite\par
    development package.  Once loaded, the LOAD SOURCE Y/N prompt will appear.\par
    Press N to enter White Lightning or, if you wish to load some source code\par
    place the appropriate cassette in the recorder, press PLAY and then type Y.\par
\par
5)  To RUN the demonstrations, just LOAD using LOAD"" and the program will\par
    auto-run.\par
\par
6)  To RUN the Sprite Development Software just type LOAD"" and again the\par
    program will auto-run.\par
\par
\par
{\b TO THE NEWCOMER}\par
\par
When you have run the demonstration tape and have seen what can be done, this may\par
give you the incentive to learn all you can to produce full specification games\par
for yourself.  The author of this manual knew nothing of White Lightning before\par
starting this project, but can promise you that after only a few hours of\par
experimentation, became fairly adept and had the confidence to want to go further.\par
It may all look a little complicated at first, but please be assured, that after a\par
short time, and only a little effort, the fog really does clear!\par
\par
Mike Butler.\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
3\page
                                 {\b SECTION 1}\par
\par
                       {\b THE SPRITE GENERATOR PROGRAM}\par
                              {\b by Paul Newnham}\par
\par
\par
{\b INTRODUCTION}\par
\par
The Sprite Generator Program was developed to complement the White Lightning\par
language.  The language is comprised of commands for manipulating sprites and\par
screen data but does not have the facility to directly design graphics characters.\par
This means there are two phases to games creation.  The first involves designing\par
and editing your graphics characters with the sprite generator program, and the\par
second involves the writing of the game itself using the White Lightning language.\par
In practice the two areas of work will probably be carried out simultaneously.\par
For those of you who are not artistically inclined, there are two sets of\par
previously defined graphics characters ready to use.\par
\par
{\b The Arcade Character Set}\par
\par
The arcade character set is an integral part of the sprite generator program - 167\par
characters are provided in all.  To see these, LOAD and run DEMO B using LOAD "".\par
The demo will auto-run.  This will tell you which characters can be called up by\par
which number, using Function Key Z.  These characters are summarised as the\par
penultimate part of this section.\par
\par
{\b The Demonstration Sprites}\par
\par
Directly after White Lightning on side A you will find the demonstration sprites.\par
By running the tape past White Lightning and using the LOAD SPRITES FROM TAPE\par
facility, these can be loaded and edited for your own use.  The various sprites\par
are tabulated at the end of this section.\par
\par
\par
{\b USING SPRITES WITH WHITE LIGHTNING}\par
\par
Once you have completed an editing session, the sprites generated should be saved\par
to tape for further editing sessions, or for use with the White Lightning language\par
itself.  To load your sprites into White Lightning:\par
\par
1.   Load White Lightning using LOAD ""\par
\par
2.   Insert the tape containing your sprites into the tape recorder and press Y in\par
response to the "LOAD SPRITES Y/N" prompt. The sprites will be loaded at the\par
address from which they were saved using the sprite generator program.\par
\par
\par
{\b COLD START}\par
\par
If you enter the sprite generator program via a COLD start, then all sprites\par
previously stored will be cleared and all system variables reset.  If, for\par
instance, you wish to use the demonstration sprites, you would enter via a COLD\par
start.  The program must always be initially entered via a COLD start.\par
\par
\par
{\b WARM START}\par
\par
If you enter the program via a WARM start then all sprites will be conserved and\par
all system variables left unchanged.  It is provided principally for re-entering\par
the program after an accidental BREAK or ERROR.  If you do accidentally BREAK;\par
type: GOTO 3 and then enter via the WARM start.\par
\par
\par
\par
                                                                                 4\page
{\b BUFFER SIZE}\par
\par
When White Lightning runs programs in Background mode (see Section 3) the top end\par
of memory is used as a scratch pad.  The size of this area depends on the\par
operation of the program and calculating the amount you need to reserve is covered\par
in Section 3.  When the sprite generator program is entered the buffer has a\par
default size of 256 bytes.  This is probably much larger than required, but until\par
you are familiar with the package or need to save a few extra bytes, just leave\par
the buffer at 256 bytes.\par
\par
\par
{\b THE CHR$ SQR}\par
\par
CHR$ SQR is the abbreviation used throughout this text for character square, and\par
refers to the 8 by 8 grid to the left of the sprite screen.  This is the area used\par
to create and edit sprites one character at a time.\par
\par
\par
{\b THE SPRITE SCREEN}\par
\par
This is the area of screen 15 characters by 15 characters on which sprites are\par
created, developed, transformed and generally worked on.\par
\par
\par
{\b THE CHR$ SQR CURSOR}\par
\par
This is the non-destructive flashing cursor which is used to design and edit the\par
character currently held in the CHR$ SQR.\par
\par
\par
{\b THE SPRITE SCREEN CURSORS}\par
\par
These are the two flashing cursors displayed in the row beneath the sprite screen\par
and the column to the right of the sprite screen.  They are used to indicate the\par
position of the top left hand corner of the screen window currently being operated\par
upon.  The actual cursor positions are measured from the top left hand corner of\par
the sprite screen and are displayed in real time on the screen as X POS (column)\par
and Y POS (row).  Top left is X POS 1 Y POS 1. Bottom right is X POS F Y POS F.\par
\par
\par
{\b SCREEN WINDOWS}\par
\par
The area of the screen currently being worked on is referred to as the screen\par
window.  Its position is defined by X POS and Y POS, which correspond to the\par
positions of the sprite screen cursors, and its dimensions are defined by SPRITE\par
HEIGHT and SPRITE LENGTH.  To see the screen window you are currently working on\par
just press F.  The window will flash.\par
\par
\par
{\b SPRITE LIBRARY}\par
\par
This refers to the set of sprites you are currently working with and can contain\par
up to 255 sprites or use 12500 bytes.  If your sprite library needs more than\par
12500 bytes you can use the merging procedure detailed in section 3 to load and\par
merge more than one sprite library into White Lightning.\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
5\page
{\b OPERATING INSTRUCTIONS}\par
\par
Insert the Sprite Generator Program Tape, type LOAD"" and load into the computer\par
as normal.\par
\par
Once loaded, the program will auto-run and the screen message "COLD OR WARM\par
START" will appear.  If this is the first execution of the program or if you wish\par
to clear the sprite memory, press C for a COLD START.\par
\par
A further screen message will now appear asking if you wish to change the buffer\par
size - this has a default value of 256 bytes.  For now, press N.  This function\par
will become more apparent later.\par
\par
{\b NOTES:}\par
\par
1. A WARM START will not destroy any sprites already in memory and if ever the\par
program is accidentally caused to BREAK, type GOTO 3 and in response to the screen\par
prompt, execute a WARM START.\par
\par
2. A COLD START will destroy any and all sprites defined in memory.\par
\par
3. WARM STARTs can only be executed after an initial COLD START.\par
\par
\par
{\b GETTING FAMILIAR WITH THE FUNCTION KEYS}\par
\par
Now let's get familiar with some of the Function Keys - a full list will be found\par
at the end of this section.\par
\par
\par
{\b THE CHR$ SQR}\par
\par
This is the grid square on which you create and edit characters for your own\par
sprite library.  To move the cursor:\par
\par
1.  Press the 5 key for each movement to the left.\par
\par
2.  Press the 6 key for each movement downward.\par
\par
3.  Press the 7 key for each movement upward.\par
\par
4.  Press the 8 key for each movement to the right.\par
\par
Now that you know how to move the cursor, let's fill in a few squares:\par
\par
1.  Move the cursor to any square that you like and release the keys.\par
\par
2.  Press the 9 key to set the square.\par
\par
3.  Now move the direction keys and fill in a few more squares.\par
\par
Now that we have set some squares, what about deleting a few of then?  This is\par
simple:\par
\par
1.  Move the cursor to a square that you have set and release the keys.\par
\par
2.  Press the 0 key to clear the square.\par
\par
Now have a go at setting and clearing some squares, just to get used to it.\par
\par
\par
\par
\par
\par
                                                                                 6\page
{\b The Sprite Screen Cursors}\par
\par
Now that you're used to moving the CHR$ SQR cursor around, moving the sprite\par
screen cursors is a piece of cake:\par
\par
1.  Move the X cursor by pressing SYMBOL SHIFT and the 5 or 8 key to move left or\par
right respectively.\par
\par
NOTE:  If you've never been able to remember which is the X or which is\par
       the Y movement, remember this little saying:\par
       X is a cross - if you say it quickly it sounds like, X is across -\par
       which it is!\par
\par
2.  Move the Y cursor by pressing SYMBOL SHIFT and the 7 or 6 key to move up or\par
down respectively.\par
\par
\par
{\b Character Building}\par
\par
No, not yours - building up characters to make up sprites!  You've probably got\par
quite a mess in the CHR$ SQR, so let's clear it:\par
\par
1.  Press the Q key and respond to the prompt in the text line by pressing Y and\par
the CHR$ SQR will clear.\par
\par
Just to get you used to a similar function, let's clear the Sprite Screen as well,\par
even though it's clear:\par
\par
1.  As you can see, to clear the CHR$ SQR press Q, to clear the sprite screen\par
press SYMBOL SHIFT Q - cunning, eh?\par
\par
Now that we have clear screens we can start to go places.  Have a go at this:\par
\par
1.  Move the X and Y cursors to 1 and 1 respectively.\par
\par
2.  Press the Z key (to call up a character from the Arcade Library) and enter the\par
number 63 followed by ENTER.  A space invader type character will appear on the\par
sprite screen.\par
\par
3.  Press the K key and answer Y to the prompt and hey presto - the character has\par
been placed in the CHR$ SQR.\par
\par
This will illustrate quite nicely how a character is built up.\par
\par
Have a go at changing this character using the 5, 6, 7 or 8 keys to move the CHR$\par
SQR cursor and the 9 and 0 keys to set or clear a square.  You won't be able to\par
see the CHR$ SQR cursor at the moment - just press one of the cursor keys and it\par
will flash for you.\par
\par
\par
Let's GET your 'new character' into memory:\par
\par
1.  Move the sprite screen cursors to X POS 4 and Y POS 4 (SYMBOL SHIFT 5, 6, 7,\par
and 8)\par
\par
2.  Press the J key and answer Y to the question.\par
\par
3.  Your new character was placed on the sprite screen from the CHR$ SQR by using\par
the J key. Your original character is still there at X POS 1 Y POS 1.\par
\par
\par
\par
\par
\par
7\page
4.  Now press the S key to give your character a sprite number.  For now, just\par
enter the number 1 and press ENTER.\par
\par
5.  Press the G key to GET the character into memory as a sprite and answer Y to\par
the prompt - your character will flash to confirm.\par
\par
Now, let's prove that your character is in memory:\par
\par
1.  Press the SYMBOL SHIFT Q to clear the sprite screen.\par
\par
2.  Press S to tell the computer which sprite you are calling up (there is only\par
one at the moment of course).  Enter 1 followed by ENTER.\par
\par
3.  Now press P to PUT the sprite to the sprite screen and answer Y to the\par
question.\par
\par
4.  Now you will be given four more options.  Don't worry about 2, 3 and 4 for now\par
- we just want to place our sprite on the sprite screen.  Press 1, and there it\par
is!\par
\par
You will notice that although you correctly got your own sprite PUT back to the\par
sprite screen, the original character from the Arcade Library wasn't.  This\par
example was to show you that any actions that you call for, will only happen to\par
the character that the sprite screen cursors are pointing to, as we pointed out in\par
the Introduction.\par
\par
You will also notice that the CHR$ SQR still contains your new character - have a\par
look to compare.\par
\par
\par
We have seen how to call up a character from the Arcade Library and how, in\par
essence, to build up a character in the CHR$ SQR.  There is another way to build\par
up a character:\par
\par
1.  Press SYMBOL SHIFT Q to clear the sprite screen.\par
\par
2.  Press the D key, answer Y to the question, and enter the following, very\par
carefully, pressing ENTER after each entry:\par
\par
    a) H24 126 H9D 255 HFF 153 129 102\par
\par
3.  Guess who's back! (You should have a space invader type character).\par
\par
This is the DIRECT DATA INPUT.  Direct Data characters are built up from 8 bytes\par
of data, one byte at a time.\par
\par
NOTE:  Data can only be entered using values in the range 0 to 255 Decimal or\par
       H00 to HFF HEX.  The character H must precede a HEX entry.\par
\par
\par
Let's do a quick review of the functions that we have used:\par
\par
1.  CHR$ SQR - cursors, 5, 6, 7 and 8 keys to move and the 9 and 0 keys to set and\par
clear squares.  The Q key clears the CHR$ SQR.\par
\par
2.  SPRITE SCREEN - 5 and 8 to move the X cursor (X is across remember) and 6 and\par
7 to move the Y cursor.  The SYMBOL SHIFT and Q keys clear the sprite screen.\par
\par
3.  The Z key calls up the ARCADE CHARACTER LIBRARY - 1 to 167.\par
\par
\par
\par
\par
\par
                                                                                 8\page
4.  The K key transfers a character from the SPRITE SCREEN to the CHR$ SQR.\par
\par
5.  The J key transfers a character from the CHR$ SQR to the SPRITE SCREEN.\par
\par
6.  The S key defines and subsequently calls up a particular SPRITE.\par
\par
7.  The G key GETs your sprite into memory.\par
\par
8.  The P key PUTs your sprite from memory onto the SPRITE SCREEN.\par
\par
9.  The D key enables you to enter a character by DIRECT DATA to the SPRITE\par
SCREEN.\par
\par
You've used quite a few functions!  Have a go at calling up some more Arcade\par
Characters, change them if you wish, then GET them into memory and PUT them onto\par
the SPRITE SCREEN.\par
\par
\par
{\b The Information Rectangle}\par
\par
             {\b MEMORY LEFT 12486  X POS 4  Y POS 4}\par
             {\b SPRITE 65266   SPRITE HEIGHT-1}\par
             {\b SPST.. 65266   SPRITE LENGTH-1}\par
             {\b SPND.. 65280   SPRITE NUMBER-1}\par
                  {\b The text line}\par
\par
This is a most useful facility which can be of great service to you.  Most of the\par
information is fairly obvious, but we'll run through it all:\par
\par
1.  MEMORY LEFT, as it says, is the amount of memory available for sprites; these\par
are the sprites that you define and do not include the Arcade Characters - to use\par
these, of course, you must define them as sprites by GETting them into memory.\par
\par
2.  X POS Y POS, these are the current positions of your SPRITE SCREEN X and Y\par
cursors with reference to the figures on top and to the left of the SPRITE SCREEN.\par
\par
3.  SPRITE, this indicates the position, in memory, where your defined sprite is.\par
\par
4.  SPST, indicates the SPrite space STart point, in memory.  (Before any sprites\par
are defined this has an initial value of 65280).\par
\par
5.  SPND, indicates the SPrite space eND point, in memory.\par
\par
6.  SPRITE HEIGHT, indicates the height of your defined sprite, in character\par
squares, as indicated by the figures at the top and to the left of the SPRITE\par
SCREEN.  (This has an initial value of 1).\par
\par
7.  SPRITE LENGTH, indicates the length of your defined sprite, in character\par
squares, as indicated by the figures at the top and to the left of the SPRITE\par
SCREEN.  (This has an initial value of 1).\par
\par
8.  SPRITE NUMBER, indicates the sprite currently defined.  (This has an initial\par
value of 1).\par
\par
9.  The Text Line, to show the Function called up, and the available options.\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
9\page
{\b More Function Keys}\par
\par
Let's move on.  BREAK the program - CAPS SHIFT/BREAK keys, type GOTO 3 and press\par
ENTER.  Execute a COLD (C) START and answer N to BUFFER SIZE CHANGE.  Nothing of\par
what you have previously done is in memory.  (We could have cleared all your\par
sprites by defining them (S key) and pressing W (WIPE SPRITE), but depending on\par
how many you defined whilst experimenting, it could have been a lengthy process!)\par
\par
Now have a go at this:\par
\par
1.  Clear the sprite screen (SYMBOL SHIFT Q)\par
\par
2.  Press X to activate the INK variable and then set it to 2.\par
\par
3.  Press C to activate the PAPER variable and then set it to 7.\par
\par
4.  Press B to activate the BRIGHT switch and then press 1 to switch it ON.\par
\par
5.  Press V to activate the FLASH variable and then press 0 to switch it OFF.\par
\par
6.  Press A to activate the ATTRIBUTE switch and then press 1 to switch it ON.\par
\par
You will have noticed, that both PAPER and FLASH were already set to 7 and 0\par
respectively from the COLD start; we only run through them all for completeness\par
and to get used to using them.\par
\par
\par
What you have done, is to set the attributes for the character we are about to\par
define, so lets do that:\par
\par
1.  Press Z to call up the arcade characters, answer Y to the prompt, and enter\par
150 followed by ENTER - there you have it - a red Dalek.\par
\par
Now in order to define this character as a sprite, we reed to GET it into memory.\par
\par
1.  Press S to set up a sprite and type 10, followed by ENTER.\par
\par
Now we'll need to set up the screen window:\par
\par
1.  Press L to activate the sprite length variable and then press 2 followed by\par
ENTER.  You will see the window flash red across the top half of the character.\par
\par
2.  Press H to activate the SPRITE HEIGHT variable and then press 2 followed by\par
ENTER.  Now you will see the new window flash.\par
\par
\par
Now convert this character into a sprite by GETting it into memory:\par
\par
1.  Press G to activate the GET function and answer Y to the prompt.  Again the\par
screen window will flash, confirming that the character has been GOT into memory.\par
\par
Move the sprite screen X cursor +2 (SYMBOL SHIFT 8 twice).  Activate the PUT\par
function (P), respond with a Y to the prompt and press 1 to PUT your new sprite to\par
the screen.\par
\par
\par
Now we're going to mirror this second character and GET it into memory as another\par
sprite but with different attributes:\par
\par
\par
\par
\par
\par
\par
                                                                                10\page
1.  Press E (Screen Functions), answer Y and press 2 (Mirror) - the character is\par
reflected!\par
\par
2.  Now press S (Sprite Number) and enter 11.\par
\par
3.  Press G (GET) and then Y - again it flashes to confirm.\par
\par
\par
We now have two sprites, one facing left and one facing right.  Let's set some new\par
attributes.\par
\par
1.  Press X (INK) and enter 4 (green).\par
\par
2.  Press I to activate the Attribute Dump facility.\par
\par
3.  Move the sprite screen X cursor 1 place to the right and press I again - the\par
top half is done!\par
\par
4.  Move the sprite screen Y cursor 1 place down and press I.\par
\par
5.  Finally, move the sprite screen cursor one place to the left and press I again\par
- there you have it, a red character to the left and a green one to the right.\par
\par
\par
If you want to swap the colours the other way around - yes you're right this can\par
be done:\par
\par
1.  Position the sprite screen cursors to X POS 1 Y POS 1.\par
\par
2.  We will have to set up the screen window for the exchange:\par
\par
Press L (Length Variable) and enter 4 - the window will flash.\par
\par
3.  Press E (Screen Functions), answer Y to the prompt and press 3 to MIRROR\par
ATIRIBUTES - watch the screen as you press 3, it happens very quickly!  The red\par
Dalek becomes green and the green Dalek becomes red.\par
\par
\par
Right then - we'll move on a little.  We'll consider some sprite operations.\par
These are operations which take place in memory on the stored sprites.  We'll\par
begin by setting up a new sprite comprising two arcade characters and then go on\par
to change their positions in the sprite in memory. Have a go at this:\par
\par
1.  Clear the sprite screen (SYMBOL SHIFT Q).  Don't worry about your previous\par
characters - you'll probably remember that they are still in memory as sprites 10\par
and ll.\par
\par
2.  Make sure that the sprite screen cursors are set to X POS 1 Y POS 1.\par
\par
3.  Set INK (X) to 6 (yellow).\par
\par
4.  Set PAPER (C) to 0.\par
\par
5.  Set FLASH (V) to 0.\par
\par
6.  Set BRIGHT (B) to 1.\par
\par
7.  Set ATTR (A) to 1.\par
\par
8.  Press Z (Arcade Character) and enter 149 (a Robot).\par
\par
\par
\par
\par
11\page
9.  Move the sprite screen X cursor by +2.\par
\par
10. Change the INK (X) to 4 (green).\par
\par
ll. Press Z (Arcade Character) and enter 151 (another Robot).\par
\par
\par
OK, you should have two robots on the sprite screen - let's define them as a\par
combined sprite:\par
\par
1.  Move the cursors to X POS 1 Y POS 1.\par
\par
2.  Press L (Length Variable) and set to 4.\par
\par
3.  Press H (Height Variable) and set to 2.\par
\par
4.  Press S (Sprite Number) and enter 12.\par
\par
5.  Press G (GET Function) and respond to the prompt with Y.\par
\par
\par
We have now set up a 4 by 2 sprite containing both characters. Now let's change\par
them over in memory:\par
\par
1.  Press M (Sprite Memory Functions), respond to the prompt with Y, and press 2\par
(MIRROR) - nothing happens on the sprite screen - this is a memory function.\par
\par
Let's prove that the sprite has been altered:\par
\par
1.  Move the sprite screen Y cursor by +3.\par
\par
2.  Press P (PUT) respond to the prompt with Y and press 1 - the sprite has been\par
reflected.\par
\par
\par
We can return the attributes to their former Robots quite easily:\par
\par
1.  Press M (Sprite Memory Functions), respond to the prompt with Y, and press 3\par
(Mirror Attributes).\par
\par
2.  Move the Y cursor by +3 and press P (PUT), respond to the prompt with Y and\par
press 1 - now the attributes have mirrored.\par
\par
\par
Let's move on a little further now.  We now look at a second sprite transformation\par
- rotation.  Try the following:\par
\par
1.  Clear the sprite screen and set the X and Y cursors to X POS 1 Y POS 1.\par
\par
2.  Set INK (X) to 1 (blue).\par
\par
3.  Set PAPER (C) to 7 (white).\par
\par
4.  Set FLASH (V) to 0.\par
\par
5.  Set BRIGHT (B) to 1.\par
\par
6.  Set ATTR (A) to 1.\par
\par
\par
\par
\par
\par
\par
                                                                                12\page
7.  Press Z (Arcade Character) and enter 151 (a Robot).\par
\par
8.  Set HEIGHT (H) to 2 and LENGTH (L) to 2.\par
\par
9.  Set the Sprite Number (S) to 13, then press G to GET the character as a\par
sprite.\par
\par
10. Move the X cursor by +2.\par
\par
11. Press R (ROTATE), and enter the new sprite number, 14.\par
\par
12. Press P (PUT) and press 1 - a Robot rotated by 90 degrees!\par
\par
Now that we have sprite 14 as a 90 degree rotation of sprite 13, why not go a\par
little further ? Try this:\par
\par
\par
1.  Move the X cursor by +2.\par
\par
2.  Press R (ROTATE) and enter the new sprite number, 15.\par
\par
3.  Press P (PUT) and press 1 - this new robot has been rotated by 180 degrees\par
from its original orientation.\par
\par
To produce the final (270 degree) orientation:\par
\par
1.  Move the X cursor by +2.\par
\par
2.  Press R (ROTATE) and enter the new sprite number, 16.\par
\par
3.  Press P (PUT) and press 1 - this has produced the final orientation.\par
\par
\par
Now let's look at attribute handling in more detail - clear the sprite screen and\par
position the X and Y cursors to X POS 1 Y POS 1.  The following two examples will\par
show how to download and pick-up attributes between the attribute variables and\par
the sprite screen:\par
\par
1.  Press X (INK) and set to 3 (magenta).\par
\par
2.  Press C (PAPER) and set to 2 (red).\par
\par
3.  Press V (FLASH) and set to 1 (ON).\par
\par
4.  Press B (BRIGHT) and set to 0 (OFF).\par
\par
5.  Press A (ATTR) and set to 0.\par
\par
6.  Press I (ATTRIBUTE DUMP) - the attributes will appear on the sprite screen.\par
\par
7.  Now set all the attributes, X, C, V, B, and A to 0.\par
\par
8.  Press U (PICK UP ATTRIBUTES) and the attributes on the screen will be loaded\par
into the attribute variables.\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
13\page
This next example illustrates one of the more complicated functions of the\par
generator - GETting a sprite into a larger sprite:\par
\par
1.  Clear the sprite screen and position the cursors to X POS 1 Y POS 1.\par
\par
2.  Press L (Length) and enter 4, then press H (Height) and enter 4.\par
\par
3.  Press E (Screen Functions) and press 1 (INVERT).\par
\par
4.  Press S (Sprite Number) and enter 17, then press G (GET).\par
\par
5.  Move the X cursor by +4.\par
\par
6.  Press X (INK) and set to 0.\par
\par
7.  Press C (PAPER) and set to 6 (yellow).\par
\par
8.  Press V (FLASH) and set to 0 (OFF).\par
\par
9.  Press B (BRIGHT) and set to 1 (ON).\par
\par
10. Press A (ATTR) and set to 1.\par
\par
11. Press Z (Arcade Character) and then enter 149.\par
\par
12. Press L (Length) and enter 2, then press H (Height) and enter 2.\par
\par
13. Press S (Sprite Number) and enter 18.\par
\par
14. Press G (GET).\par
\par
15. Press SPACE key (Place small sprite into large sprite) - enter small sprite as\par
18, larger sprite as 17, Row as 1, Column as 1 and BLS (1), as you get each\par
prompt.\par
\par
16. Move the X cursor by +2.\par
\par
17. Press P (PUT), answer the prompt with Y and then press 1 - there you have it,\par
your Robot inside the square.\par
\par
\par
Let's move on to look at some of the utility functions - Test and Wipe.\par
\par
1.  Clear the sprite screen and position the cursors to X POS 1 Y POS 1.\par
\par
2.  Press Z (Arcade Character) and enter 135.\par
\par
3.  Press L (Length) and enter 2, then press H (Height) and enter 2.\par
\par
4.  Press S (Sprite Number) and enter 19.\par
\par
5.  Press G (GET).\par
\par
6.  Press L (Length) and enter 10, then press H (Height) and enter 10.\par
\par
7.  Clear the sprite screen.\par
\par
8.  Press T (Test Sprite) and note that the information rectangle contains the\par
following:\par
\par
\par
\par
\par
\par
                                                                                14\page
    A)  SPRITE HEIGHT = 2\par
    B)  SPRITE LENGTH = 2\par
    C)  SPRITE NUMBER = 19\par
    D)  MEMORY LEFT   = The remaining memory for sprites.\par
    E)  SPRITE        = Start address of sprite being tested.\par
\par
\par
A function is provided to Wipe a sprite from memory and adjust pointers.  Leave\par
everything as it is and try:\par
\par
1.  Press W (Wipe sprite) - remember sprite 19 has already been defined.  Respond\par
to the prompt with Y.\par
\par
2.  Press T (Test sprite) and an error message will appear on the text line -\par
SPRITE NO LONGER EXISTS\par
\par
\par
While we are considering error messages, have a go at this:\par
\par
1.  Press Z (Arcade Character) and then press 63.\par
\par
2.  Press S (Sprite Number) and press 12 - an error message will appear, SPRITE\par
ALREADY DEFINED.  Sprite number 12 is not corrupted in any way, nor is the one you\par
have put to the screen.  All that you need to do is choose a different sprite\par
number which has not already been allocated.\par
\par
\par
There's one area we've been avoiding all the way through - the Logic Functions.\par
We don't want to wade into the depths of Boolean algebra here, but instead,\par
provide a few examples which hopefully show the application of the XOR, OR and\par
AND operations to this part of the package.  They are provided for advanced\par
applications only and their results are summarised on the sprite generator panel.\par
Let's see what they do:\par
\par
1.  Clear the sprite screen and position the cursors to X POS 1 Y POS 1.\par
\par
2.  Press X (INK) and set to 3 (magenta).\par
\par
3.  Press C (PAPPR) and set to 0 (black).\par
\par
4.  Press V (FLASH) and set to 0.\par
\par
5.  Press B (BRIGHT) and set to 1.\par
\par
6.  Press A (ATTR) and set to 1.\par
\par
7.  Press Z (Arcade Character) and enter 149 (Robot).\par
\par
8.  Press L (Length) and enter 2, then press H (Height) and enter 2.\par
\par
9.  Press S (Sprite Number) and enter 21, then G (GET) to Get the sprite.\par
\par
10. Move the X cursor by +2.\par
\par
ll. Press P (PUT) and respond to the prompt with 1.\par
\par
12. Press Z (Arcade Character) and enter 151 (Robot).\par
\par
13. Press O (Logical Sprite Functions) and press 1.\par
\par
\par
\par
\par
\par
15\page
14. Move the X cursor by +2.\par
\par
15. Press P (PUT) and respond with 1 - the characters have been "ORed" (merged).\par
\par
\par
Let's take this a little further and OR with the screen:\par
\par
1.  Clear the sprite screen and position the cursors to X POS 1 Y POS 1.\par
\par
2.  Press X (INK) and set to 1 (blue).\par
\par
3.  Press C (PAPER) and set to 7 (white).\par
\par
4.  Press V (FLASH) and set to 0.\par
\par
5.  Press B (BRIGHT) and set to 1.\par
\par
6.  Press A (ATTR) and set to 1.\par
\par
7.  Press Z (Arcade Character) and enter 141 (Explosion) - you probably think\par
we're going to blow up the Robot!\par
\par
8.  Press L (Length) and enter 2, then press H (Height) and enter 2.\par
\par
9.  Press S (Sprite Number) and enter 22, then G (GET) sprite 22.\par
\par
10. Move the X cursor by +2.\par
\par
11. Press Z (Arcade Character) and enter 149 (Robot).\par
\par
12. Press P (PUT) and enter 2 - sprite number 22 has been "ORed" with whatever was\par
on the screen.\par
\par
13. Move the X cursor by +2.\par
\par
14. Press P (PUT) and enter 1 - the explosion was unaffected!\par
\par
\par
Now let's take a look at a second logical operation - the AND function:\par
\par
1.  Clear the sprite screen and position the cursors to X POS 1 Y POS 1.\par
\par
2.  Press P (PUT) and enter 4, sprite 22 has been "ANDed" with the screen - as the\par
screen was empty, nothing happened.\par
\par
3.  Press P (PUT) and enter 1 - the sprite is still there!\par
\par
\par
Now, lastly, let's look at the XOR function:\par
\par
1.  Clear the sprite screen and move the cursors to X POS 1 Y POS 1.\par
\par
2.  Press Z (Arcade Character) and enter 151 (Robot).\par
\par
3.  Press P (PUT) and enter 3 - the Robot has blown up! ("At last!", I hear you\par
say!)\par
\par
\par
\par
\par
\par
\par
\par
\par
                                                                                16\page
Now one of the interesting properties of the logical XOR, is that if the operation\par
is repeated, the original character is restored - to mend the Robot:\par
\par
1.  Press P (PUT) and enter 3 - a fully restored Robot!\par
\par
\par
Well, there you have it.  In fact, the only functions remaining that have not been\par
covered by an example are:\par
\par
1.  Relocate Sprites  ( < (SYMBOL SHIFT R) ).\par
\par
2.  Save sprites to Tape ( NOT (SYMBOL SHIFT S) ).\par
\par
3.  Load Sprites from Tape ( - (SYMBOL SHIFT J) ).\par
\par
The "Relocate Sprites" does simply that, it relocates sprites in memory.  Just\par
enter a relocation length - positive to move sprites to higher memory and negative\par
to move sprites to lower memory.  This function is not often used in fact and\par
should be used with great care!\par
\par
The "Save Sprites" function is very straight forward - just follow the screen\par
instructions.  After the sprites have been saved you will be asked to rewind the\par
tape to verify the saved data.\par
\par
The "Load Sprites" function is similar to the above - just follow the screen\par
instructions.\par
\par
It should be noted that whenever sprites are saved or loaded, there are 3 distinct\par
sets of data which the generator stores and retrieves.\par
\par
\par
{\b CONCLUSIONS}\par
\par
Well, there's nothing to stop you now!  Going through the examples will help you\par
to familiarise yourself with all of the Function Keys.  It won't be long before\par
you'll be happy to press on by yourself - happy sprite generating!\par
\par
The thing to do now, is to press on with Spectra Forth and IDEAL, these really are\par
not as frightening as they may first appear - after seeing the demo program, what\par
more incentive do you need!\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
17\page
                                    {\b SECTION 2}\par
\par
                                  {\b SPECTRA FORTH}\par
                                 {\b by Stuart Smith}\par
\par
\par
Forth is an extraordinary computer language developed originally for the control\par
of radio telescopes, by an American named Charles Moore.\par
\par
Forth is neither an interpreter nor a compiler, but combines the best features of\par
both to produce a super-fast, high level language, incorporating the facilities\par
offered by an interactive interpreter and the speed of execution close to that of\par
machine-code.  In order to achieve these fantastic speeds, Forth employs the use\par
of a data, or computation stack, on which to hold the data or the operations to be\par
performed, coupled with the use of Reverse Polish Notation (RPN).  This may be\par
quite a mouthful, but RPN is very easy to use and understand with only a little\par
practice - in fact, Hewlett Packard use RPN on many of their calculators.\par
\par
All standard Forths use integer arithmetic for their operations and can handle up\par
to 32 bit precision if required - floating point mathematics routines could be\par
incorporated, but with a reduction in the execution speeds of a program.\par
\par
White Lightning consists of a standard Fig-Forth model, but with over 100\par
extensions to the standard vocabulary of Forth words.  There are two important\par
extensions to White Lightning: the first is the ability to access almost ALL of\par
the Spectrum's own BASIC commands, just as you would when writing a BASIC program,\par
and with the addition of many of the high resolution graphics commands (CIRCLE,\par
DRAW, etc.).  Coupled with the incredible execution speeds of White Lightning, the\par
possibilities are limitless!  The second, and possibly most important, addition is\par
the IDEAL sub-language.\par
\par
In addition to the basic vocabulary of White Lightning words, the user can very\par
easily ADD his own NEW WORDS using previously defined words, thus extending the\par
vocabulary and building up as complex a word as is necessary to do the task in\par
hand.\par
\par
Fully structured programming methods are also employed as a fundamental feature of\par
Forth through the use of the structured control sequences included, such as:\par
\par
IF.....ELSE.....ENDIF\par
DO.....UNTIL\par
\par
The standard Spectrum editor can be used to create lines of White Lightning source\par
code for later compilation.  Do not allow lines to exceed 64 characters - any\par
characters after this are ignored.  The standard Forth line editor is included for\par
compatibility with existing text. The source code is stored in memory from $CC00\par
onwards, and can be LOADed or SAVEd to tape as and when required.  Once the source\par
code is complete, it may then be compiled into the White Lightning dictionary for\par
later execution.\par
\par
Included in this documentation is a glossary of Fig-Forth terms (courtesy of the\par
FORTH INTEREST GROUP, P.O. BOX 1105, SAN CARLOS, CA 94070).\par
\par
Spectra Forth was written by Stuart Smith, the author of the extremely successful\par
DRAGONFORTH, and is an enhancement of a program written by the Forth Interest\par
Group - to whom we offer our thanks.\par
\par
At the time of writing, floppy discs are not readily available for the Spectrum\par
and instructions referring to discs should be interpreted as accessing RAM.\par
\par
\par
\par
\par
\par
                                                                                18\page
{\b AN INTRODUCTION TO SPECTRA FORTH}\par
\par
This introduction does not set out to teach Forth programming, but rather to serve\par
as a supplement to available texts on the subject; references include:\par
\par
'Starting Forth' by Brodie, published by Prentice Hall.\par
'Introduction to Forth' by Knecht, published by Prentice Hall\par
'Discover Forth' by Hogan, published by McGraw Hill.\par
\par
\par
White Lightning syntax consists of Forth words or literals, separated by spaces\par
and terminated by a carriage return.  A valid name must not contain any embedded\par
spaces since this will be interpreted as two distinct words, and most be less than\par
31 characters in length.  If a word is entered which does not exist or has been\par
spelt wrongly, or the number entered is not valid in the current base, then an\par
error message will be displayed.  To compile and execute programs created using\par
the Editor type LOAD <CR>.  Throughout these examples <CR> means 'PRESS ENTER'.\par
\par
e.g.  -FINE     will generate an error message 0 since the word does\par
      not exist.\par
\par
      HEX 17FZ  will generate an error message 0 since Z is not valid\par
      in hexadecimal base.\par
\par
Other error messages include:\par
\par
      STACK EMPTY\par
      STACK FULL\par
      DICTIONARY FULL\par
\par
In order to program in white Lightning, it is necessary to define new words based\par
on the words already in the vocabulary.  Values to be passed to these words are\par
pushed onto the stack and if required, the word will pull these values from the\par
stack, operate on them, and push the result onto the stack for use by another\par
Lightning word.  As mentioned previously, Spectra Forth (as with all Forths) uses\par
Reverse Polish Notation and integer numbers, therefore no precedence of operators\par
is available, thus all operations are performed in the sequence in which they are\par
found on the stack.\par
\par
e.g.    1 2 + 3 * is equivalent to 3*(1+2)\par
\par
As can be seen, in RPN, the operators are input after the numbers on which they\par
have to operate have been input.\par
\par
We will now discuss some of the words in greater depth.\par
\par
\par
{\b 1. INPUT/OUTPUT Operators.}\par
\par
\par
{\b EMIT}    :  This will take the number held on the top of the stack and display it\par
           on the terminal, as its original ASCII character.\par
\par
e.g.    HEX  41  EMIT  CR  <CR>\par
\par
will instruct the Forth to move into hexadecimal mode, push 41H onto the stack,\par
and then take that number and display it on the terminal - in this example the\par
character displayed will be an "A".  The actual character displayed my be any of\par
the recognisable ASCII characters, a graphic character, or a control code depending\par
on the value of the number on the stack.\par
\par
\par
\par
\par
19\page
{\b EMITC}   :  As EMIT but Control characters are also dealt with.\par
\par
\par
{\b KEY}     :  This will poll the keyboard, wait for a key to be pressed and push\par
           the ASCII code for that key onto the stack, without displaying it on\par
           the terminal.\par
\par
e.g. KEY      Press "A" on the keyboard\par
\par
will instruct the computer to wait for a key to be pressed (press the "A") and\par
then push the ASCII value of this key, in this case 41H (where the 'H' implies\par
Hexadecimal 41 ie 65 decimal) onto the top of the stack.  In order to display this\par
character, try the following example:\par
\par
Type:\par
\par
KEY EMIT <CR>\par
\par
but be sure to hit the <CR> very quickly.\par
\par
Now hit any key and its ASCII value will be printed followed by OK.  So if you\par
type "A" it would print "AOK".  If you were too slow you've now got two cursors!\par
Ignore the top one and try again.  This problem only occurs because when you press\par
<CR> to enter the example, it immediately executes and you've possibly still got\par
<CR> held down.  In a normal Forth definition you won't have this problem.\par
\par
\par
{\b CR}      :  This will transmit a carriage return and line feed to the display.\par
\par
\par
{\b .}       :  Convert the number held on the stack using the current BASE and\par
           print it on the screen with a trailing space.\par
\par
e.g   Suppose the stack contains 16H and BASE is decimal (10), then . will print\par
22 (this is 16 + 6); if BASE were hexadecimal (16), then . would print 16.\par
\par
In order to see this Working we will alter the BASE and push numbers onto the\par
stack - remember, that just by typing in a valid number will result in it being\par
pushed onto the stack.  There are two words to alter the BASE:\par
\par
{\b HEX}     :  Use hexadecimal base\par
{\b DECIMAL} :  Use decimal base\par
\par
Try:\par
\par
(i)   HEX 1F7 . <CR> (Where <CR> means press ENTER).\par
      This will print 1F7\par
\par
(ii)  DECIMAL 2048 . <CR>\par
      This will print 2048\par
\par
(iii) DECIMAL 2048 HEX . <CR>\par
      This will print 800, since this is the HEX equivalent, of 2048.\par
      Remember that . will remove the number from the stack that it is printing.\par
\par
\par
{\b U.}      :  Prints the number held on the top of the stack as an unsigned number.\par
\par
e.g.  HEX C000 U. <CR>\par
\par
will push C000 onto the stack and then print it.\par
\par
\par
\par
                                                                                20\page
If we use just . we will get a negative result.\par
\par
      HEX C000 . <CR>\par
\par
will print -4000\par
\par
\par
{\b ?}       :  Print the value contained at the address on top of the stack using the\par
           current base.\par
\par
Suppose the top of the stack contains FF40H, location FF40/41H contains 0014H, and\par
current BASE is 10 (DECIMAL), then ? will print 20 which is the decimal equivalent\par
of 14 Hex.\par
\par
\par
{\b TYPE}    :  This uses the top TWO numbers held on the stack and will print a\par
           selected number of characters starting at a specific\par
           address onto the screen.  The top number on the stack is the\par
           character count and the second number is the address to\par
           start at.\par
\par
e.g.    HEX 6100 20 TYPE <CR>\par
(Note that 6100H is pushed onto the stack and 20H is pushed on top of it 20H =\par
TOP; 6100H = second).  This will print 20H (32) ASCII characters corresponding to\par
the data starting at address 6100H . (Note that much of the output will be\par
unrecognisable unless the data contains correct ASCII codes, such as for numbers\par
and letters).\par
\par
\par
{\b DUMP}    :  This takes the top number on the stack and prints out 80H bytes\par
           starting at this address.\par
\par
\par
{\b "}       :  This is used in the form ." character string " and will display\par
           the string contained within " " on the screen.\par
\par
e.g.   ." THIS IS A CHARACTER STRING " <CR>\par
will put THIS IS A CHARACTER STRING on the screen.  Note the spaces between the\par
string and the quotes.\par
\par
\par
{\b SPACE}   :  This will display a single blank/space on the screen.\par
\par
\par
{\b SPACES}  :  This will display n spaces on the screen, where n is the number on the\par
           top of the stack.\par
\par
e.g.    DECIMAL 10 SPACES <CR>\par
will print 10 spaces on the screen.\par
\par
\par
{\b 2. MATHEMATICAL OPERATORS}\par
\par
{\b +}       :  This will add the top two numbers on the stack and leave the result\par
           as a single number.\par
\par
e.g.    1 2 + . <CR>\par
will print the value of 1 + 2 = 3 on the screen.  Note that the two top numbers\par
are removed from the stack, being replaced by a single number - this is true of\par
most Forth commands, in that they remove the values which they require to use from\par
the stack and push the result onto the stack.\par
\par
\par
\par
21\page
For the purposes of the following examples, let us refer to the numbers on the\par
stack as follows:\par
\par
 N1  =  top    number on stack (i.e. first to be removed)\par
 N2  =  second number on stack (i.e. second to be removed)\par
 N3  =  third  number on stack (i.e. third to be removed)\par
\par
To demonstrate this, let us push three numbers onto the stack by typing:\par
\par
        HEX 01FA 0019 1F47 <CR>\par
\par
The stack will look like this:\par
\par
        1F47    Top of stack\par
        0019\par
        01FA\par
\par
Note that this illustrates the property of the stack, that it is, Last In First\par
Out or LIFO; therefore we have:\par
\par
        N1  =  1F47\par
        N2  =  0019\par
        N3  =  01FA\par
\par
So if we type:\par
\par
        CR . CR . CR . CR <CR>\par
\par
We get  1F47\par
          19\par
         1FA\par
\par
We will now resume our explanation of the mathematical operators.\par
\par
\par
{\b -}       :  This will subtract the top number on the stack from the second number\par
           on the stack and leave the result as the top number.\par
i.e.    N1 = N2 - N1\par
\par
e.g.    Decimal 7 11 - . <CR>\par
will print -4, since the stack would contain\par
\par
        N1     ll    TOS (Top of stack)\par
        N2      7\par
\par
before the subtraction, and\par
\par
        N1     -4    TOS\par
\par
after the subtraction.\par
\par
\par
{\b * }       : This will multiply the top two numbers on the stack and leave the\par
          result on the top of the stack.\par
i.e.    N1 = N1 x N2\par
\par
e.g.    DECIMAL 140 20 * . <CR>\par
would print 2800\par
\par
\par
\par
\par
\par
\par
                                                                                22\page
{\b /}       :  This will divide the second number on the stack by the first number,\par
           and leave the result on the top of the stack.\par
i.e.    N1 = N2 / N1\par
\par
e.g.    DECIMAL 1000 500 / . <CR>\par
will print 2\par
\par
\par
{\b MAX}     :  This will leave the greater of the top two numbers on the stack.\par
\par
e.g.    371 309 MAX . <CR>\par
will print 371\par
\par
\par
{\b MIN}     :  This will leave the smaller of the two numbers on the stack.\par
\par
e.g.    371 309 MIN . <CR>\par
will print 309\par
\par
\par
{\b ABS}     :  This will leave the absolute value of the top number on the stack as\par
           an unsigned number.\par
i.e.    N1 = ABS(N1)\par
\par
e.g.    47 ABS . <CR>\par
will print 47\par
\par
        -47 ABS . <CR>\par
will print 47\par
\par
\par
{\b MINUS}   :  This will negate the top number on the stack.\par
i.e.    N1 = -N1\par
\par
e.g.    418 MINUS . <CR>\par
will print -418\par
\par
        -418 MINUS . <CR>\par
will print 418\par
\par
\par
{\b 1+}      :  add 1 to the top number on the stack\par
        N1 = N1 + 1\par
\par
\par
{\b 2+}      :  add 2 to the top number an the stack\par
        N1 = N1 + 2\par
\par
\par
{\b 1-}      :  subtract 1 from the top number on the stack\par
        N1 = N1 - 1\par
\par
\par
{\b 2-}      :  subtract 2 from the top number on the stack\par
        N1 = N1 - 2\par
\par
e.g.    196 2- . <CR>\par
will print 194\par
\par
\par
\par
\par
\par
\par
23\page
{\b MOD}     :  This will leave the remainder of N2/N1 on the top of the stack with\par
           the same sign as N2\par
\par
e.g.    17 3 MOD . <CR>\par
will print 2  (17/3 = 5 remainder 2)\par
\par
\par
{\b /MOD}    :  This will leave the remainder and the quotient on the stack of N2/N1\par
           such that the quotient becomes the top number on the stack and the\par
           remainder becomes the second.\par
\par
e.g.    17 3 /MOD . CR . <CR>\par
will print 5 (quotient)\par
           2 (remainder)\par
\par
\par
{\b 3. STACK OPERATORS}\par
\par
\par
{\b DUP}     :  This will duplicate the top number on the stack.\par
\par
e.g.    719 DUP . . <CR>\par
will print  719 719\par
\par
\par
{\b DROP}    :  This will drop the number from the top of the stack.\par
\par
e.g.    111 222 DROP . <CR>\par
will print  111\par
\par
\par
{\b SWAP}    :  This will swap the top two numbers on the stack.\par
\par
e.g.    111 222 SWAP . . <CR>\par
will print  111 222\par
\par
\par
{\b OVER}    :  This will copy the second number on the stack, making it a new number\par
           at the top of the stack without destroying the other numbers.\par
\par
e.g.    111 222 OVER . CR . CR . <CR>\par
will print  111\par
            222\par
            111\par
\par
since the stack before OVER was:\par
\par
            222      TOS\par
            111\par
\par
and after OVER is:\par
\par
            111      TOS\par
     copy   222\par
            111\par
\par
\par
{\b ROT}     :  This will rotate the top three numbers on the stack, bringing the\par
           third number to the top of the stack.\par
\par
\par
\par
\par
\par
                                                                                24\page
e.g.    1 2 3 ROT . CR . CR . <CR>\par
will print  1\par
            3\par
            2\par
\par
since the stack before ROT was:\par
            3        TOS\par
            2\par
            1\par
\par
and after ROT is:\par
            1        TOS\par
            3\par
            2\par
\par
\par
{\b 4. OTHER OPERATIONS}\par
\par
\par
{\b !}       :  This will store the second number on the stack at the address held on\par
           the top of the stack. (pronounced "store").\par
\par
e.g.    Suppose the stack is as follows:\par
\par
        HEX C000     TOS\par
            FFEE\par
\par
This will store FFEE at address C000/C001\par
i.e.    EE at C000\par
        FF at C001\par
\par
If we key in HEX FF00 C000 ! <CR>\par
this will store FF00 at C000/C001\par
i.e     C000 contains low byte 00\par
        C001 contains high byte FF\par
\par
Remember that each 16 bit number takes up 2 bytes.\par
\par
\par
{\b @}       :  This will replace the address held on the top of the stack, with the\par
           16 bit contents of that address. (Pronounced "at")\par
\par
Suppose the memory contents are as follows:\par
\par
Address:  6100 6101 6102 6103 6104 6105\par
Contents: 00   C3   8F   70   00   C3\par
\par
then 6100 @ . <CR>\par
will print C300\par
\par
If you wish to deal with single bytes, then a variation of the above will be\par
used.\par
\par
\par
{\b C!}      :  Will store a single byte held in the second number on the stack at the\par
           address held on the top of the stack.\par
\par
e.g.    FF C000 C! <CR>\par
will store a single byte FF at address C000.\par
\par
\par
\par
\par
\par
25\page
{\b C@}      :  This will fetch the single byte held at the address at the top of the\par
           stack - this single byte will be pushed on the stack as a 16\par
           bit number, but with the high byte set to zero.\par
\par
with reference to the memory contents shown previously,\par
if we key in C000 C@ . <CR>\par
\par
this will print FF (and not FF00 as with @)\par
\par
\par
{\b +!}      :  This will add the number held in the second number of the stack, to\par
           the value held at the address on the top of the stack (Pronounced\par
           "Plus-store").\par
\par
e.g.    4 HEX C000 +! <CR>\par
will add 4 to the value at C000/C001\par
As will be shown later, this is of use when using variables in White Lightning.\par
\par
\par
{\b 5. COLON DEFINITIONS}\par
\par
These are the most powerful and most used forms of data structures in White\par
Lightning, and are so called because they begin with a colon ":"\par
\par
Colon definitions allow the creation of new Forth words based on previously\par
defined words.  They can be of any length, although carriage return must be\par
pressed before a particular section exceeds 80 characters.\par
\par
The general format is:\par
\par
:  new-word  word1  word2.....  wordn  ;\par
\par
All colon definitions end with a semi-colon  ";"\par
\par
If a word used in a colon definition has not been previously defined, then an\par
error will result.\par
\par
The new-word is executed simply by typing its name and pressing ENTER.\par
\par
e.g.    Suppose we wish to define a new word to calculate the square of a given\par
number.\par
\par
We could do this by:\par
\par
: SQUARE DECIMAL CR ." THE SQUARE OF " DUP . ." IS " DUP * . ; <CR>\par
\par
Here we have defined a new word called SQUARE which will be called by\par
\par
number SQUARE <CR>\par
\par
e.g.    9 SQUARE <CR>\par
\par
will result in:\par
\par
THE SQUARE OF 9 IS 81\par
\par
If we follow the operation of the word, we will see the changes in the stack:\par
\par
\par
\par
\par
\par
\par
\par
                                                                                26\page
     TOS               OPERATION              RESULT\par
  empty\par
      9                 9 SQUARE\par
      9                 CR                  carriage return\par
      9                 ."                  THE SQUARE OF\par
  9   9                 DUP\par
      9                 .                   9\par
      9                 ."                  IS\par
  9   9                 DUP\par
     81                 *\par
  empty 81              .                   81\par
\par
and execution of SQUARE ends at the semi-colon.\par
\par
If we now wished, we could define a new word using our word SQUARE.\par
\par
We are now going to discuss control structures.  It must be remembered, that the\par
control structures can only be incorporated in colon definitions, or an error will\par
result.\par
\par
\par
{\b 6. CONTROL STRUCTURES}\par
\par
LOOPS\par
\par
There are essentially two forms of loop operation:\par
\par
 (i)  {\b DO...  LOOP}\par
\par
(ii)  {\b DO... +LOOP}\par
\par
The first loop structure is used as follows:\par
\par
limit start DO ... 'Forth words' ... LOOP\par
\par
The Forth words within the loop are executed until start = limit, incrementing the\par
start (or index) by one each time. Type:\par
\par
: TEST1 5 0 DO ." Forth " CR LOOP ; <CR>\par
Typing in TEST1 <CR>\par
will print Forth\par
           Forth\par
           Forth\par
           Forth\par
           Forth\par
\par
The second loop structure is used as follows:\par
\par
limit start DO ...'Forth words' increment +LOOP\par
\par
The Forth words within the loop are executed from start to limit, with the index\par
being incremented or decremented by the value increment. Try:\par
\par
: TEST2 5 0 CO ." HELLO " 2 +LOOP ; <CR>\par
Executing TEST2 will print HELLO HELLO HELLO\par
\par
Since the limit and the index are held on the return stack, it would be useful if\par
we could examine the index.  Well, there are words to do this:\par
\par
\par
\par
\par
\par
\par
27\page
{\b I}       : This will copy the loop index from the return stack onto the data\par
          stack.\par
\par
{\b J}       : This will push the value of the nested LOOP index to the stack.\par
\par
{\b K}       : This will push the value of the double nested LOOP index to the stack.\par
\par
\par
\par
Type:\par
\par
: TEST3 4 0 DO 4 0 DO 4 0 DO K J I . . . CR LOOP LOOP LOOP ; <CR>\par
\par
Executing TEST3      1  1  1\par
will print:          1  1  2\par
                     1  1  3\par
                     .  .  .\par
                     .  .  .\par
                     .  .  .\par
\par
and so on.\par
\par
\par
{\b 7. CONDITIONAL BRANCHING}\par
\par
Conditional branching must again be used only within a colon definition and uses\par
the form:\par
\par
{\b IF} (true part) ... (Forth WORDS) ... {\b ENDIF}\par
\par
{\b IF} (true part) ... (Forth WORDS) ... {\b ELSE} (false part) ... (Forth WORDS) ...\par
{\b ENDIF}\par
\par
These conditional statements rely on testing the top number on the stack to decide\par
whether to execute the TRUE part, or the FALSE part of the condition.\par
\par
If the top item on the stack is true (non-zero) then the true part will be\par
executed.  If the top item is false (zero) then the true part will be skipped and\par
execution of the false part will take place.  If the ELSE part is missing, then\par
execution skips to just after the ENDIF statement.\par
\par
There are several mathematical operators which will leave either a true (non-zero)\par
flag, or a false (zero) flag on the stack to be tested for by IF.\par
\par
These are:\par
\par
{\b 0<}      :  This will leave a true flag on the stack if the number on the top\par
           of the stack is less than zero, otherwise it leaves a false flag.\par
\par
e.g.    -4 0< <CR>\par
will leave a true flag (non-zero).\par
\par
To see this, type:\par
        . <CR>\par
to print the top number on the stack, which is the flag.  This will print\par
        1\par
to show a true flag.\par
\par
        914 0< . <CR>\par
will print a 0 (false flag).\par
\par
\par
\par
\par
                                                                                28\page
{\b 0=}      :  This will leave a true flag on the top of the stack if the number on\par
           the top of the stack is equal to zero, otherwise it will leave a\par
           false flag.\par
\par
\par
{\b <}       :  This will leave a true flag if the second number on the stack is less\par
           than the top number, otherwise it will leave a false flag.\par
\par
e.g.    40 25 < . <CR>\par
will print 0 (false flag).\par
\par
If we look at the stack during this operation we will see:\par
\par
          Operation              TOS\par
             40                   40\par
             25                40 25\par
              <                    0\par
              .                empty\par
\par
\par
{\b >}       :  This will leave a true flag if the second number on the stack is\par
           greater than the top number, else a false flag will be left.\par
\par
e.g.    40 25 > . <CR>\par
will print 1 (true flag).\par
\par
\par
{\b =}       :  This will leave a true flag if the two top numbers are equal,\par
           otherwise it will leave a false flag.\par
\par
Now for some examples using the conditional branching structures, type:\par
\par
: TEST= = IF ." BOTH ARE EQUAL " ENDIF ." FINISHED " ; <CR>\par
\par
Now key in two numbers followed by TEST= and a carriage return.\par
\par
e.g.    11 119 TEST= <CR>\par
This will print FINISHED\par
\par
        119 119 TEST= <CR>\par
will print BOTH ARE EQUAL FINISHED\par
\par
Now key in:\par
: TEST1= = IF ." EQUAL " ELSE ." UNEQUAL " ENDIF CR ." FINISHED " ; <CR>\par
\par
Now key in:\par
        249 249 TEST1= <CR>\par
this will print EQUAL\par
                FINISHED\par
\par
Try:    249 248 TEST1= <CR>\par
this will print UNEQUAL\par
                FINISHED\par
\par
Notice how the part after ENDIF was executed in both cases.\par
\par
Two more loop structures will now be discussed:\par
\par
\par
\par
\par
\par
\par
\par
29\page
{\b BEGIN}  ....  (Forth WORDS)  ....  {\b UNTIL}\par
\par
{\b BEGIN}  ....  (Forth WORDS)  ....  {\b WHILE}  ....  (Forth WORDS)  ....  {\b REPEAT}\par
\par
Using the BEGIN .... UNTIL the value at the top of the stack is tested upon\par
reaching UNTIL.  If the flag is false (0) then the loop starting from BEGIN is\par
repeated.  If the value is true (non-zero) then an exit from the loop occurs.\par
\par
Try typing the following example:\par
\par
: COUNT-DOWN DECIMAL 100 BEGIN 1- DUP DUP . CR 0= UNTIL ." DONE " ; <CR>\par
\par
Now key in: COUNTDOWN <CR>\par
This will print:\par
  99\par
  98\par
   .\par
   .\par
   .\par
   3\par
   2\par
   1\par
   0\par
DONE\par
\par
The BEGIN ... WHILE ... REPEAT structure uses the WHILE condition to abort a loop\par
in the middle of that loop.  WHILE will test the flag left on top of the stack and\par
if that flag is true, will continue with the execution of words up to REPEAT,\par
which then branches always (unconditionally) back to BEGIN.  If the flag is false,\par
then WHILE will cause execution to skip the words up to REPEAT and thus exit from\par
the loop.\par
\par
We will now construct a program to print out the cubes of numbers from 1 upwards,\par
until the cube is greater than 3000.\par
\par
The colon definition could be as follows:\par
\par
: CUBE DECIMAL 0 BEGIN 1+ <CR>\par
DUP DUP DUP DUP * * DUP <CR>\par
3000 < WHILE ." THE CUBE OF " <CR>\par
SWAP . ." IS " . CR REPEAT <CR>\par
DROP DROP DROP ." ALL DONE " CR ; <CR>\par
\par
You may get an error message "MSG#4" appearing on the screen; this means that the\par
word you have just created already exists.  This is not a problem since the new\par
word will be created, and all actions referencing the word CUBE will be directed\par
to the latest definition using that name.\par
\par
Now run this by keying in:\par
\par
CUBE <CR>\par
\par
and watch the results.\par
\par
Try to follow what is happening by writing down the values on the stack at each\par
operation.  If you are having any difficulty in doing this, the stack values are\par
shown below.\par
\par
\par
\par
\par
\par
\par
\par
                                                                                30\page
       {\b STACK}            {\b OPERATION}           {\b OUTPUT (if any)}\par
\par
        empty            DECIMAL\par
        0                0\par
        0                BEGIN\par
        1                1+\par
\par
(let us now refer to the number on the stack as N)\par
\par
      N N                DUP\par
    N N N                DUP\par
  N N N N                DUP\par
N N N N N                DUP\par
  N N N N\'b2               *\par
    N N N\'b3               *\par
  N N N\'b3N\'b3               DUP\par
N N N\'b3N\'b33000             3000\par
  N N N\'b3flag (1 or 0)    <\par
\par
If TRUE:\par
\par
    N N N\'b3               WHILE\par
                         ." THE CUBE OF "   THE CUBE OF\par
    N N\'b3N                SWAP\par
      N N\'b3               .                   N\par
                         ." IS "             IS\par
        N                .                   N\'b3\par
        N                CR                  carriage return\par
        N                REPEAT              (branch back to BEGIN)\par
\par
If FALSE:\par
\par
      N N                DROP\par
        N                DROP\par
    empty                DROP\par
                         ." ALL DONE "       ALL DONE\par
                         CR\par
                         ;\par
\par
In fact, it is a good idea to check the stack contents during the execution of any\par
new Forth word to make sure that it is working correctly.  (Note that DROP merely\par
clears the top number from the stack).\par
\par
Finally, one extra construct has been added to circumvent the problem of deeply\par
nested IF...THEN...ELSE structures.  This is the CASE OF structure. It takes the\par
general form :\par
\par
CASE n1 OF (Forth Word) ENDOF n2 OF (Forth Word) ENDOF ... END CASE\par
\par
For example type:\par
\par
: TEST4 CASE 1 OF ." FIRST CASE " ENDOF 2 OF ." SECOND CASE " ENDOF 3 OF ." THIRD\par
CASE " ENDOF END CASE ; <CR>\par
\par
Now type :\par
\par
1 TEST4 CR 2 TEST4 CR 3 TEST4 CR <CR>\par
\par
\par
\par
\par
\par
\par
\par
31\page
{\b 8. CONSTANTS AND VARIABLES}\par
\par
White Lightning also allows you to define your own constants and variables using\par
the Fourth words:\par
\par
CONSTANT\par
VARIABLE\par
\par
When a constant is called up, this causes its VALUE to be pushed onto the stack,\par
however, when a variable is called up, this causes its address to be pushed onto\par
the stack.  The Forth words ! and @ are used to modify the contents of the\par
variable.\par
\par
A constant is defined by using the form:\par
\par
value CONSTANT name\par
\par
and any references to the name will cause the value n to be put on the stack.\par
\par
A variable is defined using the form:\par
\par
value VARIABLE name\par
\par
and any reference to the name will result in the address of that variable to be\par
put on the stack for further manipulation using ! and @.  It is essential that you\par
realise the difference between the contents and the address of a variable.\par
\par
Now for some examples:\par
\par
  64 CONSTANT R 1000 CONSTANT Q\par
 256 VARIABLE X\par
   0 VARIABLE Y\par
\par
R Q + .  will print the value of R + Q i.e. 1064\par
    X .  will print the address of X, not its value\par
  X @ .  will print the value of X, i.e. 256\par
  R Y !  will store the value of R in the variable Y\par
  Y X !  will store the address of Y in the variable X\par
  4 X !  will store the value 4 in variable X\par
\par
{\b BASIC statement}       {\b Forth Equivalent}\par
\par
LET X = Y             Y @ X !\par
LET X = R             R X !\par
LET X = 4             4 X !\par
LET X = X + 5         5 X +!\par
\par
\par
{\b OTHER COMMONLY USED FORTH WORDS}\par
\par
\par
{\b LIST}    : This will list the contents of the screen number held on the top of\par
          the stack.\par
\par
e.g.  6 LIST will list screen 6 to the screen.  Note that if source has not been\par
typed into any of the screens, they will probably contain garbage.\par
\par
\par
{\b FORGET}  : This is used to delete part of the Lightning dictionary.  Please note\par
          that not only will the word following FORGET be erased, but so will\par
          every word defined after it!\par
\par
\par
\par
                                                                                32\page
e.g.  FORGET EXAMPLE will delete the word EXAMPLE (if it exists) along with any\par
other words defined after it.\par
\par
\par
{\b VLIST}   : This is just typed in as a single word with no parameters.  It will\par
          cause a list of all the words defined so far; pressing BREAK\par
          (CAPS SHIFT & SPACE as in BASIC) will stop the listing.\par
\par
\par
{\b LOAD}    : This will compile the source code that you have created using the\par
          editor into the White Lightning dictionary, to become new Lightning\par
          words.  Loading will terminate at the end of a screen or at the\par
          Forth word ;S  unless the "continue loading" word --> is used at the\par
          end of a screen.  The idea of the screen will became obvious in the\par
          next section on editing.\par
\par
\par
{\b USING THE EDITOR}\par
\par
Generally speaking, most users will want to use the Spectrum editor to type and\par
edit the source, but a full Forth line editor is included for compatibility with\par
existing texts.  The maximum length of any line is 64 characters.  Any characters\par
after this will be ignored.\par
\par
{\b Line Editor}\par
\par
Included in this version of White Lightning is a line editor to enable you to\par
create source or text files.  To facilitate text editing, the text is organised\par
into blocks of 512 bytes, divided into 8 lines of 64 characters.  Once the text\par
has been edited, it may then be compiled into the White Lightning dictionary and\par
the text, if required, can be saved to tape.  The text is stored in memory in the\par
pages at C000 to F000, therefore, you can edit into screens 1 to 23.  If the\par
background facility is utilised, text is stored from CC00 onwards in screens 6 to\par
23, and screens 0 to 5 cannot be used.\par
\par
Here is a list of the editor commands and their descriptions:\par
\par
\par
{\b H}      :  This will Hold the text pointed to by the top number on the stack of\par
          the current screen in a temporary area known as PAD.\par
\par
e.g.  4 H will hold line 4 of the current screen in PAD.\par
\par
\par
{\b S}      :  Fill (Spread) the line number at the top of the stack with blanks, and\par
          shift down all subsequent lines by 1, with the last line being lost.\par
\par
e.g.  6 S will fill line 6 with blanks and move all other lines down by one,\par
pushing the last line off the screen.\par
\par
\par
{\b D}      :  Delete the line number held on the stack.  All other lines are moved\par
          up by 1.  The line is held in PAD in case it is still needed.\par
          Line 7 cannot be deleted.\par
\par
\par
{\b E}      :  Erase the line number at the top of the stack by filling it with\par
          spaces.\par
\par
\par
{\b RE}     :  REplace the line number at the top of the stack with the line\par
          currently held in PAD.\par
\par
\par
33\page
{\b P}      :  Put the following text on the line number held on the stack, by\par
          overwriting its present contents.\par
\par
\par
{\b INS}    :  INSert the text from PAD to the line number held on the stack.\par
          The original and subsequent lines are moved down by 1 with the last\par
          line being lost.\par
\par
\par
{\b EDIT}   :  Works just like the normal Sinclair line editor.  Also, it does an\par
          automatic list and an automatic flush.  This is far and away the best\par
          way to edit and the above are included only for compatibility\par
          with existing Forths.\par
\par
{\b CLEAR}  :  Clear the screen number held on the stack and make it the current\par
          screen.\par
\par
\par
{\b WHERE}  :  If an error occurs during the loading of White Lightning's text\par
          screens, then keying in WHERE will result in the screen number and\par
          the offending line being displayed.  You can now use the other editing\par
          commands to edit the screen, or you may move to another screen by\par
          either LISTing or CLEARing it.\par
\par
e.g.  15 LIST will now make screen 15 the current screen and will list the\par
contents.\par
\par
In order to compile this screen into the dictionary, it is necessary to use the\par
word LOAD.\par
\par
\par
LOAD\par
\par
This will start loading at the screen number held on the top of the stack and will\par
stop at the end of the screen.\par
\par
If you wish to continue and LOAD the next screen, the current screen must end with\par
-->\par
\par
This means "continue loading and interpreting".\par
\par
If you wish to stop the LOADing anywhere in a screen then use: ;S\par
\par
This means "stop loading and interpreting".\par
\par
At the end of every editing session, and before saving your text, it is necessary\par
to FLUSH the memory buffers into the text area.  To do this, just key in:\par
\par
FLUSH <CR>\par
\par
Note that the EDIT command does an automatic FLUSH.\par
\par
You can save your text to tape using the Spectrum 'SAVE' command.  You must first\par
enter BASIC by typing PROG  <CR> .\par
\par
Now for an example of how to edit a text file:\par
\par
The first step is to either LIST or CLEAR the screen about to be worked on:\par
\par
\par
\par
\par
\par
\par
                                                                                34\page
9 CLEAR <CR>\par
\par
This sets the current screen to 9.  To insert text use the EDIT command. Type 0\par
EDIT <CR> followed by the text below:\par
\par
THIS IS HOW TO PUT <CR>\par
\par
Then type 1 EDIT <CR>\par
\par
TEXT ON LINE 1 <CR>\par
\par
and so on, until you have entered:\par
\par
0 THIS IS HOW TO PUT <CR>\par
1 TEXT ON LINE 1 <CR>\par
2 LINE 2 <CR>\par
3 AND LINE 3 OF THIS SCREEN <CR>\par
\par
9 LIST will produce:\par
\par
SCR # 9\par
0  THIS IS HOW TO PUT\par
1  TEXT ON LINE 1\par
2  LINE 2\par
3  AND LINE 3 OF THIS SCREEN 4\par
5\par
6\par
7\par
\par
To change LINE 2, type 2 EDIT <CR> and then change it in the normal way to insert\par
'TEXT ON' before 'LINE 2'.  Now type 9 LIST <CR> to see the result.  The editor\par
ignores characters after the 64th character of the line being edited.\par
\par
If you have a Sinclair printer connected, then it is probably worth defining a\par
word to list screens to the printer:\par
\par
: SLIST PRT-ON 1+ SWAP DO I LIST CR LOOP PRT-OFF ;\par
\par
To use the above word, type the first screen number, last screen number, SLIST.\par
\par
e.g.  6 9 SLIST <CR> will list screens 6-9 to the printer.\par
\par
\par
{\b FORTH ERROR MESSAGES}\par
\par
The following error messages may occur, and will be printed out in the form FRED ?\par
MSG #0   standing for FRED ? ERROR MESSAGE NUMBER 0 .\par
\par
\par
 # 0  -  this means that a word could not be found, or that a numeric conversion\par
         could not take place.\par
\par
e.g.  109Z <CR>\par
\par
\par
 # 1  -  this indicates an empty stack and will be encountered when trying to\par
         take more values from the stack than exist. Try:\par
\par
        : TEST1  1000  0  DO  ?STACK  DROP LOOP  ; <CR>\par
          TEST1 <CR>\par
\par
\par
\par
\par
35\page
?STACK is a word which tests the stack for out of bounds.\par
\par
\par
 # 2  -  this indicates that either the dictionary has grown up to meet the\par
         stack (dictionary full) or that the stack has grown down to meet\par
         the dictionary.\par
\par
Try:    : TEST2  1000  0  DO  ?STACK  0 0 0 0 0 LOOP  ; <CR>\par
          TEST2 <CR>\par
\par
\par
 # 4  -  this means that you have redefined an existing word using a new colon\par
         definition\par
\par
Try:    : ROT ." NEW DEFINITION " ; <CR>\par
\par
This is not really an error since the new word is still valid, but the old\par
definition cannot be accessed unless you FORGET the new one.\par
\par
\par
 # 6  -  this error my occur when editing, loading or listing screens of data.\par
\par
Try:    25 LIST <CR>\par
This will produce MSG#6 and means you have tried to access a non-existent\par
screenful of memory.\par
\par
\par
 # 9  -  this indicates that an attempt was made to clear sprite space of\par
         less than 2 bytes.\par
\par
\par
 # 10 -  this indicates that one of the IDEAL words made reference to a sprite\par
         which did not exist, or that an attempt was mode to insert a sprite\par
         using ISPRITE with a number previously allocated to an existing sprite.\par
\par
\par
 # 17 -  this will occur if you try to use a word in the 'immediate' mode which\par
         should only be used during compilation, i.e. during colon definitions.\par
         For a list of such words, refer to the glossary (words with "C" in the\par
         top right hand corner of the description).\par
\par
Try:    DO <CR>\par
        IF <CR>\par
\par
\par
 # 18 -  this occurs if a word meant for execution only, is put within a colon\par
         definition (words with "E" in the top right hand corner of the\par
         description).\par
\par
\par
 # 19 -  this means that a colon definition contains conditionals that have\par
         not been paired.\par
\par
e.g.    a LOOP without a DO\par
        an ENDIF without an IF\par
\par
Try:    : TEST3  ELSE  ." WRONG " ; <CR>\par
\par
 # 20 -  this occurs if a colon definition has not been properly finished.\par
\par
Try:    : TEST4 IF ." OK " ; <CR>\par
\par
\par
\par
                                                                                36\page
 #  21 -  this means that you have tried to delete something in the protected\par
          part of the Forth dictionary, e.g.\par
\par
          FORGET DO\par
\par
\par
 #  22 -  this implies the illegal use of --> when not loading text screens.\par
\par
\par
 #  23 -  this happens when you try to edit a non-existent line of screen data.\par
\par
Try:    12 D\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
37\page
                                    {\b SECTION 3}\par
\par
                                      {\b IDEAL}\par
                                  {\b by John Gross}\par
\par
IDEAL has been designed to facilitate the manipulation of sprites and screen data,\par
and with its 100 or so instructions, provides a powerful and comprehensive\par
animation sub-language.  Time should be taken to gain familiarity with the\par
available commands before undertaking the first big project.  Remember, that by\par
using the colon definitions of Forth, new words can very easily be added to the\par
language, built from the existing Forth and graphics words.  Mastering this\par
technique effectively will save a great deal of space and, in many cases,\par
execution time.\par
\par
\par
{\b SPRITE}\par
\par
A sprite is a software controllable graphics character.  White Lightning supports\par
up to 255 sprites with user selectable dimensions.\par
\par
\par
{\b SCREEN WINDOWS}\par
\par
A screen window is a section of the screen defined by the four variables COL, ROW,\par
HGT and LEN.  Columns are in the range 0 to 31, Rows are in the range 0 to 23,\par
Heights are in the range 1 to 24, and Lengths are in the range 1 to 32. The unit\par
for each is the character.  COL and ROW specify the position of the top left hand\par
corner of the window, with ROW 0 at the top of the screen and COL 0 on the left\par
hand side of the screen.  HGT and LEN define the size of the window.  To see an\par
example type:\par
\par
5 ROW ! 6 COL ! 4 HGT ! 3 LEN ! INVV <CR>\par
\par
The window has been inverted to mark it out.\par
\par
\par
{\b SPRITE WINDOWS}\par
\par
A sprite window is a section of the sprite defined by the Forth variables SCOL,\par
SROW, HGT and LEN.  This time SCOL and SROW specify the position of the top left\par
hand corner of the sprite window.  HGT and LEN are again used to specify the\par
dimensions of the window.\par
\par
\par
{\b SPRITE SPACE}\par
\par
Sprite space is the area of memory containing the previously defined sprites.  The\par
variable SPST holds the address of the start of sprite space, so SPST should never\par
be loaded with a new value unless a COLD# command is being executed, or you're\par
quite sure you know what you're doing!!  SPND points to the first free byte after\par
sprite space.  SPND should never be higher than FFF0 Hex if routines are being\par
executed in Background.\par
\par
\par
{\b PIXEL DATA}\par
\par
For those not acquainted with the workings of the Spectrum screen display, each\par
character on the screen is produced as follows:  each character cell is an array\par
of 64 (8 by 8) pixels.  A pixel is a 'dot' which can be INK colour or PAPER\par
colour.  The bytes which define a particular character or block of characters are\par
referred to as pixel data.\par
\par
\par
\par
                                                                                38\page
{\b ATTRIBUTE DATA}\par
\par
The colour of the INK and PAPER in each particular cell, together with the\par
BRIGHTNESS and FLASHING attributes of the character, are controlled by a separate\par
byte.  The bytes which define the attributes of the block of characters are\par
referred to as Attribute data.  Pixel data and Attribute data are frequently\par
treated as separate entities.\par
\par
\par
{\b SCREEN OPERATIONS}\par
\par
Often, it is required to carry out an operation, such as a scroll or a reflection,\par
on one particular section of the screen.  Four variables are used to define a\par
screen window, these are COL, ROW, HGT and LEN.  The co-ordinates of the top left\par
hand corner are held in COL and ROW, where COL is measured from the left and ROW\par
from the top.  Both values are in characters.  HGT and LEN are the dimensions of\par
the window.  COL + LEN must be in the range 1 to 32, and ROW + HGT must be in the\par
range 1 to 24.  Commands in this group are postfixed with a "V", e.g. WRL1V, INVV,\par
MIRV.\par
\par
\par
{\b SCREEN/SPRITE OPERATIONS}\par
\par
These are operations between the screen and a sprite.  The dimensions of the\par
sprite are used as the dimensions of the screen window, and COL and ROW are used\par
to give the co-ordinates of the top left of the window.  If the window overlaps\par
the edge of the screen, the command will not execute. Typical commands in this\par
group are the PUTs and GETs, which move sprites between the screen and memory.\par
Commands in this group are postfixed with an "S", e.g. PUTBLS, GETXRS.\par
\par
\par
{\b SPRITE OPERATIONS}\par
\par
These cover more or less the same commands as the screen operations, but this time\par
a complete sprite is used instead of a screen window.  The only parameter required\par
is the sprite number stored in SPN.  Commands in this group are postfixed with an\par
"M", e.g. WRR4M, ATTUPM.\par
\par
\par
{\b SCREEN/SPRITE WINDOW OPERATIONS}\par
\par
These are operations between a screen window and a sprite window.  As before, ROW,\par
COL, HGT and LEN define the screen window, but this time, SCOL and SROW are used\par
to define the position of the window within the sprite.  SCOL and SROW are\par
measured in characters, SROW from the top and SCOL from the left.  If SROW + HGT\par
is greater than 24 or the sprite height, or if SCOL + LEN is greater than 32 or\par
the sprite width, the commands will not execute.  These commands are postfixed\par
with an "S", e.g. GWATTS, PWORS.\par
\par
\par
{\b SPRITE/SPRITE WINDOW OPERATIONS}\par
\par
These are operations between a whole sprite and a sprite window.  The two sprite\par
numbers are held in SP1 (the whole sprite) and SP2 (the sprite which contains the\par
window).  The dimensions of the window are the dimensions of the sprite whose\par
number is held in SP1.  The position of the window in the sprite whose number is\par
held in SP2 is specified by SCOL and SROW.  Commands in this group are postfixed\par
with an "M", e.g. GWATTM, PWNDM.\par
\par
\par
\par
\par
\par
\par
39\page
{\b SPRITE/SPRITE OPERATIONS}\par
\par
These are operations between sprites which usually have the same dimensions, or,\par
as in the case of the SPIN command, transposed dimensions.  SP1 and SP2 hold the\par
sprite numbers.  Commands in this group are postfixed with a "M", e.g. COPORM,\par
SPINM.\par
\par
\par
{\b DUMMY SPRITE}\par
\par
A dummy sprite is a sprite which does not contain data for display.  It may be\par
used, for instance, to store a machine code subroutine, an array, or maybe a\par
collision detection sprite.\par
\par
\par
{\b IDEAL VARIABLES}\par
\par
The IDEAL sublanguage uses 27 variables in all, these are:\par
\par
{\b VARIABLE}                              {\b USE}\par
\par
{\b ROW}          Used to hold the row (Y co-ord) in characters, measured\par
             from the top of the screen (0-23).\par
\par
{\b LEN}          Used to hold the width of the current screen window\par
             (1-32), or the width of the sprite being defined (1-255).\par
             Units are characters.\par
\par
{\b COL}          Used to hold the column (X co-ord) in characters, measured\par
             from the left of the screen (0-31).\par
\par
{\b HGT}          Used to hold the height of the current screen window\par
             (1-24), or the height of the sprite being defined (1-255).\par
             Units are characters.\par
\par
{\b SROW}         Used to hold the row (Y co-ord) within the sprite whose\par
             number is held in SP2, measured from the top (0-(HGT-1)).\par
             Units are characters.\par
\par
{\b SCOL}         Used to hold the column (X co-ord) within the sprite\par
             whose number is held in SP2, measured from the left\par
             (0-(LEN-1)).  Units are characters.\par
\par
{\b NPX}          Used to hold the size and direction of the vertical scrolls.\par
             Positive scrolls are upward and negative downward.\par
             Units are pixels and not characters.\par
\par
{\b SPN}          Used to hold the sprite number for those words which\par
             operate on only one sprite (1-255).\par
\par
{\b SP1}          Where operations involve a sprite and a sprite window,\par
             SP1 holds the number of the sprite which does not contain\par
             the window (1-255).  Where a sprite is to be spun into a\par
             second sprite, SP1 holds the number of the first sprite\par
             (1-255).\par
\par
{\b SP2}          Where operations involve a sprite and a sprite window,\par
             SP2 holds the number of the sprite which does contain\par
             the window (1-255).  Where a sprite is to be spun into a second\par
             sprite, SP2 holds the number of the second sprite\par
             (1-255).\par
\par
\par
\par
                                                                                40\page
{\b SPST}         Used to hold the start address of sprite space.\par
\par
{\b SPND}         Used to hold the end of sprite space, i.e. the first free byte\par
             after the last sprite.  This is the address of the\par
             foreground scrolling buffer.\par
\par
{\b SLEN}         Used to hold the length of sprite space to be cleared\par
             by the COLD# command.\par
\par
{\b MLEN}         Used to hold the size and direction of the relocation.\par
             A positive value relocates sprites to higher memory and\par
             a negative value to lower memory.\par
\par
{\b SPTR}         On return from the TEST command, SPTR points to the start\par
             of the sprite.\par
\par
{\b DPTR}         On return from the TEST command, DPTR points to the start\par
             of the pixel data.\par
\par
\par
{\b Alternate Variables}\par
\par
Eleven of the previously listed variables are replicated for use by the background\par
program (see Foreground/Background).  These are ROW', COL', LEN', HGT', NPX',\par
SPN', SP1', SP2', SROW', SCOL' and SPND'.\par
\par
When a word is executed in background, the eleven alternate variables are\par
automatically switched with the eleven background variables; when execution is\par
complete, the variables are switched again to restore them to their former state.\par
\par
Suppose, for example, that the background program is to scroll left 1 pixel with\par
wrap (WRL1V), with an area of screen 6 characters wide and 4 characters high, with\par
top left co-ordinates row = 5, column = 7.\par
\par
Now type the following:\par
\par
CLS 6 LEN' ! 4 HGT' ! 5 ROW' ! 7 COL' ! ' WRL1V INT-ON <CR>\par
\par
The window is now scrolling but you can't see it, because there is no data in the\par
window.\par
\par
Type VLIST <CR> and watch the data as it scrolls through the window.  The data in\par
the window will be slanting to the left, because the foreground program was\par
scrolling up at the same time as the background program scrolled left.\par
\par
Leaving the background program running, type:\par
\par
10 LEN' ! <CR>\par
\par
and the window will widen.\par
\par
Type:\par
\par
INT-OFF ' WRR8V INT-ON <CR>\par
\par
and the screen will scroll to the right, this time much more rapidly.  Now type:\par
\par
INT-OFF <CR>\par
\par
to halt the background program.\par
\par
\par
\par
\par
41\page
In the above example we set background variables from foreground.  If we were to\par
set the background variables actually in the background program, then foreground\par
and background variables would already have been switched before execution.  To\par
set up the same windows, we would now have to use ROW, COL, HGT and LEN, and not\par
ROW', COL', HGT' and LEN'.\par
\par
To define a word to do this, type:\par
\par
: FRED 6 LEN ! 4 HGT ! 1 ROW ! 2 COL ! WRL1V ; <CR>\par
\par
To run "FRED" in background, type:\par
\par
' FRED INT-ON <CR>\par
\par
Since the variables were this time being assigned values in the background program\par
itself, the alternate variables set was being accessed with the normal names.  Now\par
type:\par
\par
INT-OFF FORGET FRED <CR>\par
\par
to halt the background program and clear the definition.\par
\par
Operating in this way, a word will work in foreground or background without any\par
need to change variable names.  The alternate variables are only used directly by\par
a foreground program that is required to change background variables, or a\par
background program that is required to change foreground variables.  If the\par
previous example is a little confusing at first, carry out your own\par
experimentation until it becomes clear.\par
\par
\par
{\b ERRORS}\par
\par
The graphics commands do not in many cases provide the user with error messages,\par
but instead, if an attempt is made to execute a command which is not possible, for\par
instance scrolling a screen window which lies partly off the screen, the command\par
will simply not execute.  This does have the advantage that the user is freed\par
from testing edge conditions, but does mean that a little extra care needs to be\par
exercised. See the words ADJM and ADJV.  Errors are generated if an attempt is\par
made to access a non-existent sprite, or to insert an already existing sprite\par
using ISPRITE.\par
\par
\par
{\b SPRITE AND BUFFER ORGANISATION}\par
\par
Before discussing the sprite manipulation commands in detail, it is worth\par
describing the organisation of sprites in some detail.  The user does not need\par
this information, but it is made available for interest and an overall\par
appreciation of the language structure.\par
\par
Sprites are stored as one contiguous block of data whose start address is held in\par
the variable SPST.  The first free byte after the final sprite contains a zero and\par
this address is held in the variable SPND.  The format of each sprite is as\par
follows:\par
\par
First byte              Holds the sprite number which must be in the range\par
                        1 to 255.\par
\par
Second and              Hold the address of the start of the next\par
third bytes             sprite.\par
\par
\par
\par
\par
\par
                                                                                42\page
Fourth byte             Holds the width of the sprite in characters (1 to 255).\par
\par
Fifth byte              Holds the height of the sprite in characters (1 to 255).\par
\par
8*height*length bytes   Pixel data.\par
\par
Height*length bytes     Attribute data.\par
\par
This means that the total space allocated to each sprite is 9*height*length+5\par
bytes.\par
\par
Sprite numbers do not need to run sequentially, but the earlier a sprite is\par
defined, the more rapid its access.\par
\par
\par
{\b LOADING SPRITES FROM TAPE}\par
\par
Sprites saved to tape using the development software can be loaded into the main\par
program at the start of the session when the "LOAD SPRITES Y/N" prompt appears.\par
If sprites are loaded in this manner, the sprite data, together with the necessary\par
pointers, will be loaded.  SPST and SPND are automatically set and the sprites\par
will be ready for use.\par
\par
If sprites are saved and later loaded from White Lightning, SPST and SPND will\par
need to be set by hand.\par
\par
\par
{\b THE BUFFER}\par
\par
When vertical scrolling takes place, be it for pixel data or attributes, with or\par
without wrap, data has to be temporarily stored for later retrieval.  If a\par
vertical scroll is executed by the foreground program then the buffer is pointed\par
to by SPND, so the space immediately above sprites is used.  When the sprite\par
development software is used, a prompt is issued at the start of the session,\par
which asks the user whether or not buffer size should be changed.  If the buffer\par
size is not changed then it remains 256 bytes long.  The user can enter a larger\par
or smaller value if preferred, though the default value of 256 will cover most\par
eventualities.\par
\par
Scrolling attributes uses one byte for each column of the width, scrolling pixel\par
data uses one byte for each column of the width, multiplied by the number of\par
pixels being scrolled (the value held in NPX, see vertical scrolls).  The buffer\par
space need only be large enough to accommodate the largest scroll, as foreground\par
scrolls will not take place simultaneously.  Suppose a sprite or screen window 8\par
characters high by 4 characters wide is to be scrolled by 10 pixels.  (The\par
direction, i.e. the sign of NPX does not matter).  The space required is 4 * 10 =\par
40 bytes.  If you find at some later stage that you have not allowed enough buffer\par
space, you can always relocate sprite space downward and likewise, if you have\par
more than you need, you can relocate upwards.\par
\par
\par
{\b BACKGROUND SCROLLING}\par
\par
When programs are executed in background (see Foreground/Background) it is risky\par
to share a common scrolling buffer, since the background program could execute\par
while the foreground program is using the buffer.  For this reason, a second\par
buffer pointer is used for background scrolling.  The variable holding the address\par
of the background buffer is SPND'.  When White Lightning is first entered, SPND'\par
points to the 256 free bytes in the printer buffer at decimal 23296.  The user can\par
move this buffer by changing the value held in SPND'.  It is not a bad idea to\par
allocate enough buffer space, for both foreground and background scrolling above\par
\par
\par
\par
43\page
sprite space and assign SPND' to point to the space after the foreground buffer.\par
Suppose, for example, the foreground program requires 200 bytes and the background\par
300 bytes, with the buffer currently set to 256 bytes.  500 bytes are needed in\par
all, so sprites need to be relocated down by 500 - 256 = 244 bytes.  Type:\par
\par
-244 MLEN ! RELOCATE <CR>\par
\par
Note that MLEN is now negative since relocation is downward.  SPND' should be set\par
200 bytes into the buffer to leave space for the foreground data.  To do this\par
type:\par
\par
SPND @ 200 + SPND' ! <CR>\par
\par
If memory is really tight and the buffer has to be shared, then the background\par
program can be temporarily disabled using DI but as soon as the vertical scroll is\par
executed, an EI must be executed to re-enable the background program.  If, for\par
example, a screen window 12 characters wide and 4 characters high is to be\par
scrolled vertically by 8 pixels with wrap, and the background program is to be\par
inhibited, type:\par
\par
0 0 AT 8 NPX ! 12 LEN ! 4 HGT ! 4 COL ! 4 ROW ! DI WCRV EI <CR>\par
\par
It is best to re-enable the background program as soon as possible, preferably, as\par
above, the next word.\par
\par
Until you get used to the package leave the buffers as they are on entry to White\par
Lightning.  Use ISPRITE and DSPRITE, and not SPRITE and WIPE, to define new\par
sprites.  The only time you really need to worry about changing buffer sizes or\par
positions is when you have a dire need to save a few extra bytes.\par
\par
\par
{\b IDEAL MNEMONICS}\par
\par
To get the best out of the White Lightning package, please read these next\par
sections carefully and note the parameters.  The words have been selected so as to\par
be as mnemonic as possible.  To help yourself become acquainted with the language,\par
it is worth noting the following:\par
\par
 1.  Words which involve only the screen are postfixed "V" for "Video\par
     Operations".\par
\par
 2.  Words which involve only operations on or between sprites, are postfixed\par
     with "M" for "Memory Operations".\par
\par
 3.  Words which involve operations between the screen and sprites are postfixed\par
     with "S" for "Screen/Sprite" operations.\par
\par
 4.  BLS indicates that data is being "Block Shifted" to a destination and will\par
     replace whatever was there.\par
\par
 5.  ORS indicates that data is being "Shifted and OR'ed" so the destination data\par
     will be OR'ed with the source data.\par
\par
 6.  NDS indicates that data is to be "Shifted and AND'ed".\par
\par
 7.  XRS indicates that data is to be "Shifted and XOR'ed".\par
\par
 8.  ATT indicates that the operation is on attribute data.\par
\par
\par
\par
\par
\par
\par
                                                                                44\page
 9.  WR implies that the data will be scrolled with wrap.\par
\par
10.  SC implies that data will be scrolled without wrap.\par
\par
11.  GW "Get Window" implies that data is being moved from a window into a\par
     sprite.\par
\par
12.  PW "Put Window" implies that data is being put into a window from a sprite.\par
\par
13.  COP implies an operation between two sprites with the same dimensions.\par
\par
The best way to become familiar with the language is to use it!\par
\par
There are also some general points worth noting.\par
\par
\par
{\b GENERAL POINTS}\par
\par
 1.  Vertical scrolls will require some buffer space at the end of sprite space,\par
     so make sure that either you have set up sprite space with the development\par
     package (the default of 256 is usually adequate), or that at least one COLD#\par
     has been executed to make space.  The space required for a scroll is\par
     obtained by multiplying the width of the sprite, by the number of pixels\par
     to be scrolled.  Horizontal scrolls do not require buffer space.  When\par
     White Lightning is first Loaded without sprites, a COLD# is automatically\par
     executed and sets the buffer to 256 bytes.\par
\par
 2.  All attribute scrolls are "with wrap".\par
\par
 3.  Commands prefixed with GET or PUT are operations between a whole sprite\par
     and a screen window.  These are very fast and can be made even faster\par
     by suppressing the movement of attribute data, if its transference is\par
     not required.  To suppress attribute data use the word ATTOFF.  If you\par
     wish to switch data flow back on at a later stage, use ATTON.  The switch\par
     remains in its state until changed by the execution of one of these\par
     two words or the execution of a word beginning with GW or PW and ending\par
     with S (group 2 GETS and PUTS).  NEVER assume the state of the switch\par
     at the start of the program:  one of your first words at the beginning\par
     of your program should be ATTON or ATTOFF.\par
\par
 4.  If a sprite is dynamically allocated space at runtime it will probably\par
     contain garbage in its pixel and attribute data, so both will need to be\par
     set up.  It is all too easy to forget the attributes.\par
\par
 5.  Sometimes the dynamically created sprites will contain zeroes; if you set\par
     up the pixel data and forget the attribute data then execute a PUT to\par
     the screen with the attributes on - a black rectangle will appear. See\par
     SETAM.\par
\par
 6.  If you want to wipe a sprite off the screen but not affect any other\par
     pixel data within its screen window, use PUTXRS.  Remember, though, that\par
     if you have carried out any operations on the original sprite since\par
     doing the original PUTBLS or PUTXRS it may not work.\par
\par
 7.  If you want to leave a sprite on the screen but clear all other pixel data\par
     in its screen window use PUTNDS.  Again, be sure that no intermediary\par
     operations have taken place.\par
\par
\par
\par
\par
\par
\par
\par
45\page
 8.  If you wish to PUT a sprite onto the screen over the top of the existing\par
     data in the window, then you should use PUTORS.\par
\par
 9.  Points 6-8 apply to operations in memory, although the words used are\par
     of course different.\par
\par
10.  The best way to get to knew the PUTs and GETs is to experiment with them;\par
     you will soon realise how to move sprites.  For those of you not yet\par
     familiar with what "AND", "OR" and "XOR" mean, note the following:\par
\par
     a)  If two sprites are AND'ed, then only those pixels set in both will\par
         remain set when the sprites are AND'ed together.\par
\par
     b)  If two sprites are OR'ed, then all those pixels set in either sprite\par
         will be set in the result.\par
\par
     c)  If two sprites are XOR'ed, then all those pixels set in either\par
         sprite will be set in the result, but this time, all pixels where\par
         both were set will now be reset.\par
\par
     d)  All "Block Shift" commands will destroy whatever was previously\par
         in the window.\par
\par
11.  It is possible to set up "masks" in dummy sprites and use the boolean\par
     operations OR, XOR and AND to move windows around etc.\par
\par
12.  If you wish to make something appear at lightning speed, leave the data\par
     on the screen and fill the window with zero attributes or attributes with\par
     the same INK and PAPER colour.  To make the sprite appear you need only\par
     download the attributes using PWATTS; to make it disappear use\par
     PWATTS again, but this time, download stored attributes with the same ink\par
     and paper colour, or use SETAV.\par
\par
13.  It is possible to use the TEST command to gain direct access\par
     to the attributes in the sprite memory.  They are located at DPTR+ 8*LEN*HGT\par
     and can be easily block filled.\par
\par
14.  Most animation routines use only the variables:\par
\par
     HGT   Height of window\par
     LEN   Width of window\par
     COL   Screen column of top left character\par
     ROW   Screen row of top left character\par
     SCOL  Sprite column of top left character\par
     SROW  Sprite row of top left character\par
     SPN   Sprite number\par
     SP1   Number of first sprite in a double sprite operation\par
     SP2   Number of second sprite in a double sprite operation\par
\par
     Columns are measured in characters (8 pixels by 8 pixels) and are counted\par
     from the left, 0 to 31.\par
\par
     Rows are measured in characters and are counted from the top 0 to 23.\par
\par
     Remember, never change a variable unless you need to, they are not\par
     reset between instructions (with the exception of ADJM and ADJV, and\par
     you can always write your code to order the operations in such a way as\par
     to minimise the resetting of variables.\par
\par
\par
\par
\par
\par
\par
                                                                                46\page
15.  If a word ending in V (screen operation) does not execute, it is almost\par
     always because the window you have defined does not lie wholly on the\par
     screen.  That is to say, that COL + LEN is not in the range 1 to 32, or\par
     ROW + HGT is not in the range 1 to 24.  See ADJV.\par
\par
16.  If a word ending in S (screen/sprite operation) does not execute, then\par
     again, it is almost always because the sprite width + COL is not in the\par
     range 1 to 32 or the sprite height + ROW is not in the range 1 to 24.\par
     See ADJM.\par
\par
17.  If a word ending in S that is also a window command (second letter W)\par
     does not execute, it may be for the reasons outlined in 16, or it may be\par
     that SCOL + LEN or SROW + HGT do not lie within the width and height of\par
     the sprite containing the window.\par
\par
18.  If a word ending in M that is not a window command does not execute,\par
     the sprite probably does not exist; if it is a window command, then it\par
     is likely that the width of the first sprite + ROW or the height of the\par
     first sprite + SCOL do not lie within the width and height of the\par
     sprite containing the window.\par
\par
19.  Remember that the SPIN command needs a second sprite to rotate into,\par
     and that its dimensions should be the reverse of the sprite to be\par
     spun.  For real speed, it is best to store the sprite in each of its\par
     4 orientations.\par
\par
20.  If you wish to do a vertical mirror, just SPIN, do a horizontal\par
     mirror, and SPIN back.\par
\par
21.  It is good policy always to make the sprite one character higher and\par
     wider than the graphic character itself; this will enable you to scroll\par
     the character within the sprite and give pixel resolution when using\par
     the PUT commands.\par
\par
22.  If memory permits, it is a good idea to keep a "back-up" of each sprite\par
     held under a different number, so that if an error is made and a sprite\par
     corrupted, it can be copied back from the copy.  They can always be deleted\par
     from the final program.\par
\par
23.  Never execute the NEW or CLEAR commands when in BASIC.\par
\par
24.  If a sprite driven under interrupt disappears from the screen or\par
     flickers, it is probably a timing related problem and re-ordering\par
     the code will almost certainly solve the problem.\par
\par
25.  Screens can be moved up and down memory using the CMOVE word. Each screen\par
     occupies 512 bytes and the addresses are listed in Table 1, the Table\par
     of Screen Addresses.\par
\par
26.  If you are using the Background facility, the top 16 bytes of RAM will be\par
     used, so any data stored there will be corrupted.  To avoid this, make\par
     sure you have enough scrolling buffer and keep the top of sprite space\par
     below 65520.\par
\par
27.  If you execute SETAM or SETAV in background, set the FLASH attribute\par
     in the background program.\par
\par
28.  If you wish sprite space to "grow" upward use SPRITE and WIPE, otherwise\par
     always use ISPRITE and DSPRITE for sprite allocation.\par
\par
29.  BAD RAMTOP error, usually means you have not RESERVED sufficient\par
     space for your BASIC program.\par
\par
\par
47\page
{\b SPRITE UTILITIES}\par
\par
All the sprite utilities described in this section are available at run-time, but\par
we strongly recommend that all sprite allocation is undertaken at the sprite\par
development stage to save laboriously reloading sprite data if an error is made at\par
run-time.  They are provided for advanced programming applications only and should\par
never be executed in background.\par
\par
\par
{\b COLD #}\par
\par
This command sets the end of sprite space pointer SPND, to the value in SPST, the\par
start of sprite space pointer.  It then clears memory above SPST.  The size of the\par
memory cleared is specified in SLEN.  Each time a sprite is allocated space using\par
the SPRITE command, SPND is updated.  Vertical scroll data (pixel and attribute)\par
uses the space immediately above SPND so a COLD# is necessary at some stage before\par
executing the commands.  The amount of data required is given by the product of\par
the scroll width and the number of pixels scrolled.  sprites are stored in the\par
following format:\par
\par
First byte is the sprite number              (1 to 255)\par
Second and third bytes hold the address of the next sprite in memory.\par
Fourth byte is the sprite width              (1 to 255)\par
Fifth byte is the sprite height              (1 to 255)\par
The next 8*height*length bytes hold pixel data.\par
The final height*length bytes hold the attributes.\par
Therefore, each sprite requires 9*height*length+5 bytes.\par
\par
It should be noted that sprite numbers need not be allocated in any particular\par
order.  The best position for sprite space is at the top of memory and it is not\par
difficult to calculate space required, although the development package does this\par
automatically.\par
\par
To calculate the total sprite space that will be used, use 9*length*height+5 for\par
each sprite and then add buffer space for vertical scrolls, 256 should be\par
sufficient for most applications.  This total should be assigned to SLEN.  SPST\par
should then be assigned with 65520-SLEN.\par
\par
\par
Example:\par
\par
Suppose you wished to allocate space for 10 4 by 4 sprites, 3 8 by 6 sprites and a\par
5 by 4 sprite.  Suppose also that a 4 pixel scroll will be required for a 4\par
character wide sprite, and a screen window 9 characters wide will need to be\par
scrolled 3 pixels.  The 8 by 6 sprite is also to be rotated.  The following\par
procedure to calculate sprite space is required.\par
\par
10  4 by 4 sprites require      10*(4*4*9+5) = 1490 bytes\par
 3  8 by 6 sprites require       3*(8*6*9+5) = 1311 bytes\par
 1  5 by 4 sprite requires       1*(i*4*9+5) =  185 bytes\par
                                      TOTAL  = 2986 bytes\par
\par
The 4 character wide sprite scrolling 4 pixels would require 16 bytes.\par
The 9 character wide screen window scrolling 3 pixels would require 27 bytes.\par
If we allow 27, then this will cover both eventualities and we can forget the 16\par
bytes for the first case.\par
\par
                                      TOTAL  = 27 bytes\par
\par
\par
\par
\par
\par
\par
                                                                                48\page
A dummy sprite 6 by 8 is also required for the rotation so:\par
\par
 1  6 by 8 sprite requires       1*(6*8*9+5) =  437 bytes\par
\par
So the overall total is          2986+27+437 = 3450 bytes\par
\par
If this is to be located at the top of memory, then SPST will need to be set to\par
65520 - 3450 = 62070.  Note that memory 65520 to 65536 is used for background\par
applications.\par
\par
In this case you would use the following:\par
\par
62070 SPST ! 3450 SLEN ! COLD#\par
\par
SPND will be automatically set to 62070.\par
\par
If all this seems a bit complicated, don't worry.  A far simpler way of setting up\par
sprites is to use the ISPRITE and DSPRITE commands described later in this\par
section.  You won't even need to execute a COLD# command.\par
\par
\par
{\b SPRITE}\par
\par
Once the sprite space has been cleared, the sprites themselves can be set up.\par
\par
Parameters                 Use\par
\par
SPN           Number of the sprite to be set up\par
HGT           Height of the sprite in characters\par
LEN           Width of the sprite in characters\par
\par
\par
Command                  Action\par
\par
{\b SPRITE}        The five byte leader is set up and SPND adjusted\par
\par
Note:\par
\par
If space is dynamically allocated to a sprite, the sprite will not necessarily be\par
initialised and may contain garbage.  If a sprite is being set up at run-time, be\par
sure that sufficient memory is available.  If a sprite number is given that has\par
been previously used, the old sprite is destroyed and recreated with the new\par
dimensions.  If sufficient memory is not available, then either an old sprite can\par
be destroyed or the whole of sprite space can be relocated downwards if space is\par
available.  Most users will probably not use the SPRITE command, but instead, will\par
use the far simpler ISPRITE command.\par
\par
\par
{\b WIPE}\par
\par
This command will destroy the sprite whose number is held in SPN, relocate the\par
sprites above it downward, update the variable SPND (marking the end of sprite\par
space) and leave the particular sprite number free for reallocation.\par
\par
\par
Parameter               Use\par
\par
SPND          The number of the sprite to be wiped\par
\par
\par
\par
\par
\par
\par
49\page
Command              Action\par
\par
{\b WIPE}         Destroy a sprite and adjust memory\par
\par
\par
{\b RELOCATE}\par
\par
An alternative method for creating more space to define new sprites, is to\par
relocate sprite space downward.  Only one parameter is required, MLEN.  A positive\par
value in MLEN will relocate sprites to high memory and a negative value will\par
relocate them downward.  All pointers are reset.\par
\par
\par
Parameter             Use\par
\par
MLEN          Size and direction of relocation\par
\par
\par
Command              Action\par
\par
{\b RELOCATE}      Relocate all sprite data and reset pointers\par
\par
Example:\par
\par
If space for a 4 by 4 sprite is to be made and the existing buffer space\par
maintained, the sprites would need to be relocated downward by 4*4*9+5 = 149. To\par
do this use the following:\par
\par
-149 MLEN ! RELOCATE\par
\par
\par
{\b TEST}\par
\par
For advanced applications there is a command to interrogate sprite details.  SPN\par
is loaded with the number of the sprite to be interrogated, and after execution,\par
the following parameters will be set:\par
\par
HGT   will hold the height of the sprite\par
LEN   will hold the width of the sprite\par
SPTR  will hold the address of the first byte of the sprite header\par
DPTR  will hold the address of the first byte of the pixel data\par
SIZE  will hold the amount of memory occupied by the sprite\par
\par
In order to calculate the start of attribute data, use DPTR+8*HGT*LEN.  Note that\par
HGT, LEN, SPTR and DPTR will all be zero if the sprite wasn't found.\par
\par
A true or false flag is also placed on the stack.  True means the sprite exists\par
and false means it doesn't.\par
\par
\par
Examples:\par
\par
To see if sprite 34 exists, and print its dimensions if it does - use:\par
\par
34 SPN ! TEST IF HGT ? LEN ? CR ENDIF\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
                                                                                50\page
{\b ISPRITE AND DSPRITE}\par
\par
If sprites are located at the top of memory, then ISPRITE and DSPRITE can be used\par
to create and destroy sprites without the need for any complex calculations.\par
ISPRITE will insert a sprite at the top of memory, maintain the buffer space and\par
automatically relocate the rest of sprite space downward.  DSPRITE will destroy an\par
old sprite and relocate sprite space upward.  The easiest way to use this package\par
is to leave the buffer space as it is, then just use ISPRITE and DSPRITE to CREATE\par
and DESTROY sprites.  SPRITE, WIPE, COLD# and RELOCATE are for advanced\par
applications where sprites are created during program execution.  If a "ZAPPED"\par
program were to execute ISPRITE the sprites would extend downwards and could\par
overwrite the object code of the main program which lies just beneath SPST.  If a\par
program runs before being "ZAPPED", but the final run-time version crashes, this\par
is where to look!\par
\par
\par
Parameter              Use\par
\par
SPN          Number of the sprite to be inserted\par
HGT          Height of the sprite to be inserted\par
LEN          Length of the sprite be be inserted\par
\par
\par
Command              Action\par
\par
{\b ISPRITE}      Create new sprite and adjust memory\par
\par
\par
Parameter             Use\par
\par
SPN          Number of sprite to be inserted\par
\par
\par
Command              Action\par
\par
{\b DSPRITE}      Wipe old sprite and adjust memory\par
\par
\par
Note:\par
\par
Be sure sufficient memory is available before executing ISPRITE.  SPST holds the\par
start; after execution, SPST will became SPST - 9*HGT*LEN-5.\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
51\page
{\b SCROLLING}\par
\par
{\b SCREEN SCROLLS}\par
\par
The horizontal screen scrolls are by 1, 4 or 8 pixels, left or right and with or\par
without wrap.  The vertical scrolls are slightly more flexible.  The variable NPX\par
is loaded with the number of pixels to be scrolled, positive for upward movement\par
and negative for downward movement.  In each case, a screen window has to be\par
defined.\par
\par
\par
Horizontal Scrolls\par
\par
Parameter                  Use\par
\par
COL         Column of the left hand edge of the window (0-31)\par
ROW         Row of the top edge of the window (0-23)\par
LEN         Width of the window (1-32)\par
HGT         Height of the window (1-24)\par
\par
Command                 Action\par
\par
{\b WRL1V}       Scroll left  1 pixel  with wrap\par
{\b WRR1V}       Scroll right 1 pixel  with wrap\par
{\b SCL1V}       Scroll left  1 pixel,   no wrap\par
{\b SCR1V}       Scroll right 1 pixel,   no wrap\par
{\b WRL4V}       Scroll left  4 pixels with wrap\par
{\b WRR4V}       Scroll right 4 pixels with wrap\par
{\b SCL4V}       Scroll left  4 pixels,  no wrap\par
{\b SCR4V}       Scroll right 4 pixels,  no wrap\par
{\b WRL8V}       Scroll left  8 pixels with wrap\par
{\b WRR8V}       Scroll right 8 pixels with wrap\par
{\b SCL8V}       Scroll left  8 pixels,  no wrap\par
{\b SCR8V}       Scroll right 8 pixels,  no wrap\par
\par
Note:\par
\par
Before executing any of these commands, the window needs to be set up using the\par
four parameters above.  If the command does not execute, it is likely that part of\par
the window does not lie on the screen.  COL + LEN should be in the range 1 to 32\par
and LEN + HGT should be in the range 1 to 24.\par
\par
Example:\par
\par
To see these commands work, it is a good idea to do a VLIST first so that there is\par
some data on the screen.  The four parameters will need to be set, unless of\par
course they have previously been defined, but for this example let us assume that\par
they haven't.  To scroll a window at COL 4, ROW 5 with height 4 characters and\par
width 3 characters, with wrap, 4 pixels left, type the following:\par
\par
4 COL ! 5 ROW ! 4 HGT ! 3 LEN ! WRL4V <CR>\par
\par
If there is no data on the screen, type:\par
\par
VLIST 4 COL ! 5 ROW ! 4 HGT ! 3 LEN ! WRL4V <CR>\par
\par
A window column 4 Row 5 has been scrolled left 4 pixels - if you didn't see it\par
happen type:\par
\par
\par
\par
\par
\par
\par
                                                                                52\page
WRL4V WRL4V WRL4V\par
\par
and you should see it!\par
\par
Parameters do not reset after the execution of the commands,  so to repeat the\par
above, this time at column 10 and without wrap, you could use the following:\par
\par
10 COL ! SCL4V <CR>\par
\par
\par
{\b Vertical scrolls}\par
\par
These work in a similar way to the horizontal scrolls, but in addition to setting\par
up the window with the four window parameters COL, ROW, HGT and LEN, a further\par
variable NPX is used to give the size and direction of the scroll in pixels. A\par
positive value for NPX causes upward scrolling and a negative value causes\par
downward scrolling.\par
\par
\par
Parameter               Use\par
\par
COL          Column at left hand edge of window (0-31)\par
ROW          Row of top left edge of the window (0-23)\par
LEN          Width of the window (1-32)\par
HGT          Height of the window (1-24)\par
\par
Command               Action\par
\par
{\b WCRV}         Vertical scroll with wrap\par
{\b SCRV}         Vertical scroll, no wrap\par
\par
Note:\par
\par
All vertical scrolling of pixel data and/or attributes for screen or sprites,\par
requires buffer space.  The space required is calculated by multiplying NPX by\par
LEN.  The start of the buffer is taken as the next free byte after sprite space,\par
so be sure that either a COLD# has been executed, or that SPND has been set.  It\par
is safe practice to develop sprites using the software provided, and to allow 256\par
bytes buffer at the top before linking with the main program.  Be sure also that\par
the scroll length is not greater than the window's size.  On entry to White\par
Lightning a COLD# is automatically executed and a scrolling buffer of 256 bytes\par
is set up.  This is maintained so long as ISPRITE and DSPRITE are used in\par
preference to SPRITE and WIPE.\par
\par
\par
{\b Attribute Scrolls}\par
\par
Attribute scrolls are similar to the pixel data scrolls but all scrolls are always\par
by one character, with wrap.\par
\par
\par
Parameter                  Use\par
\par
COL        Column of the left hand edge of the window (0-31)\par
ROW        Row of the top edge of the window (0-23)\par
LEN        Width of the window (1-32)\par
HGT        Height of the window (1-24)\par
\par
\par
\par
\par
\par
\par
\par
53\page
Command                  Action\par
\par
{\b ATTLV}      Scroll attributes left  1 character with wrap\par
{\b ATTRV}      Scroll attributes right 1 character with wrap\par
{\b ATTUPV}     Scroll attributes up    1 character with wrap\par
{\b ATTDNV}     Scroll attributes down  1 character with wrap\par
\par
\par
{\b SPRITE SCROLLS}\par
\par
The format for these commands is similar to that for the screen scrolls, except\par
that these commands are postfixed with an M as opposed to a V.\par
\par
\par
{\b Horizontal Scrolls}\par
\par
Parameters            Use\par
\par
SPN        The number of the sprite to be scrolled (1 to 255)\par
\par
Command             Actions\par
\par
{\b WRL1M}      Scroll left  1 pixel  with wrap\par
{\b WRR1M}      Scroll right 1 pixel  with wrap\par
{\b SCL1M}      Scroll left  1 pixel,   no wrap\par
{\b SCR1M}      Scroll right 1 pixel,   no wrap\par
{\b WRL4M}      Scroll left  4 pixels with wrap\par
{\b WRR4M}      Scroll right 4 pixels with wrap\par
{\b SCL4M}      Scroll left  4 pixels,  no wrap\par
{\b SCR4M}      Scroll right 4 pixels,  no wrap\par
{\b WRL8M}      Scroll left  8 pixels with wrap\par
{\b WRR8M}      Scroll right 8 pixels with wrap\par
{\b SCL8M}      Scroll left  8 pixels,  no wrap\par
{\b SCR8M}      Scroll right 8 pixels,  no wrap\par
\par
Note:\par
\par
The chief purpose of these commands is to give pixel resolution to the PUT\par
command, and for this reason, a 1 character border along 2 edges of a sprite\par
character should always be allowed.\par
\par
Example:\par
\par
To scroll sprite number 7, 1 pixel right with wrap, use:\par
\par
7 SPN ! WRR1M\par
\par
{\b Vertical Scrolls}\par
\par
These work in the same way as the vertical screen scrolls where the signed\par
variable NPX is used to determine the size and direction of the scroll.\par
\par
Parameters            Use\par
\par
SPN           Number of the sprite to be scrolled\par
NPX           Number of pixels to be scrolled\par
\par
\par
\par
\par
\par
\par
\par
\par
                                                                                54\page
Command             Action\par
\par
{\b WCRM}          Vertical scroll with wrap\par
{\b SCRM}          Vertical scroll, no wrap\par
\par
Example:\par
\par
To scroll sprite 5 downward by 11 pixels with wrap, use:\par
\par
5 SPN ! -11 NPX ! WCRM\par
\par
\par
{\b Attribute Scrolls}\par
\par
There are four commands to scroll attributes in any of the four directions:\par
\par
Parameter               Use\par
\par
SPN          Number of the sprite to be scrolled\par
\par
Command               Action\par
\par
{\b ATTLM}        Scroll attributes left  with wrap\par
{\b ATTRM}        Scroll attributes right with wrap\par
{\b ATTUPM}       Scroll attributes up    with wrap\par
{\b ATTDNM}       Scroll attributes down  with wrap\par
\par
\par
{\b GETS AND PUTS}\par
\par
There are three groups of GETs and PUTs.  The first, and the fastest, carry out\par
operations between a full sprite and a previously defined window of the screen.\par
The second group carry out operations between sprite windows and screen windows.\par
The third, and probably most powerful group of commands in the sub-language, cover\par
operations between sprite windows and other sprites.\par
\par
Suppose you have designed a sprite 160 characters wide (5 screens) and you wish to\par
smoothly pixel scroll through this sprite via a screen window covering the bottom\par
five character rows of the screen.  A second dummy sprite, 1 character wider than\par
the screen can be used to GET from the larger sprite, scroll, PUT, scroll, Put and\par
so on for 1 character, then a second block, 1 character further into the larger\par
sprite can be GOT and so on.  Experimentation will soon show you how to do this.\par
These routines can be run in background to provide fast smooth scrolling\par
backdrops.\par
\par
\par
{\b Group 1}\par
\par
This group provides block moves and logical operations between sprites and screen\par
windows - these are the fastest commands in the set.  This particular group does\par
not include separate attribute commands but instead uses an attribute switch.  If\par
the switch is on, pixel data and attribute data are moved; if you do not require\par
to move attributes you can increase the speed of operations by switching off the\par
attribute switch.\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
55\page
Command                Action\par
\par
{\b ATTON}    Enable the flow of attribute data between the sprite and the screen\par
         window\par
{\b ATTOFF}   Disable the flow of attributes between the sprite and the screen\par
         window\par
\par
We now come to the group 1 commands themselves:\par
\par
\par
{\b GETS}\par
\par
Parameter                 Use\par
\par
SPN          Number of the sprite to be used (1 to 255)\par
COL          Left hand column of target screen window (0 to 31)\par
ROW          Top row of target screen window (0 to 23)\par
\par
Command                Action\par
\par
{\b GETBLS}       Block move screen window into sprite\par
{\b GETORS}       OR screen window into sprite\par
{\b GETXRS}       XOR screen window into sprite\par
{\b GETNDS}       AND screen window into sprite\par
\par
Note:\par
\par
The dimensions of the screen window are taken as the dimensions of the sprite.  If\par
the command doesn't execute, it is almost certainly because the width of the\par
sprite + COL or the height of the sprite + ROW, exceed 32 or 24 respectively, so\par
that part of the window lies off the screen.  Sprites must be previously set up\par
either by the development software, or the COLD# and SPRITE or ISPRITE commands\par
before these commands will execute.\par
\par
Example:\par
\par
To GET a screen sprite into sprite number 4 from column 5, row 4, with attributes\par
and "OR" it with the data currently held in sprite number 4, use the following:\par
\par
4 SPN ! 5 COL ! 4 ROW ! ATTON GETORS\par
\par
Note that if ATTON was the last switch command, it would not be needed in the\par
above.\par
\par
\par
{\b PUTS}\par
\par
These commands are identical to the group 1 "GETS" except that data transfer is\par
from the sprite to the screen.  The results of the various operations are\par
therefore displayed to the screen.  The parameters are identical in operation to\par
those of the "GETS", and the ATTON and ATTOFF switch commands also apply.\par
\par
\par
Parameter                 Use\par
\par
SPN         Number of the sprite to be used (1 to 255)\par
COL         Left hand column of target screen window (0 to 31)\par
ROW         Top row of target screen window (0 to 23)\par
\par
\par
\par
\par
\par
\par
                                                                                56\page
Command                Action\par
\par
{\b PUTBLS}      Block move sprite window into screen\par
{\b PUTORS}      OR sprite window into screen\par
{\b PUTXRS}      XOR sprite window into screen\par
{\b PUTNDS}      AND sprite window into screen\par
\par
\par
{\b Group 2}\par
\par
\par
These commands allow operations between sprite windows and screen windows.  Unlike\par
Group 1 commands, there are separate commands to move pixel data and attributes,\par
and the ATTON, ATTOFF commands have no effect on their operation.  Two new\par
parameters are introduced to specify the COLUMN and ROW of the top left hand\par
character of the sprite window.  In addition, HGT and LEN are required to specify\par
the dimensions of the window for the screen and sprite.\par
\par
\par
Parameters                  Use\par
\par
COL          Left hand column of target screen window (0 to 31)\par
ROW          Top row of target screen window (0 to 23)\par
SCOL         Left hand column of target sprite window (0 to sprite width -1)\par
SROR         Top row of target sprite window (0 to sprite height -1)\par
HGT          Height of window\par
LEN          Length of window\par
SPN          Sprite number\par
\par
\par
Command                    Action\par
\par
{\b GWBLS}        Get block of pixel data from screen window into sprite window\par
{\b GWORS}        OR pixel data from screen window into sprite window\par
{\b GWXRS}        XOR pixel data from screen window into sprite window\par
{\b GWNDS}        AND pixel data from screen window into sprite window\par
{\b GWATTS}       GET block of attribute data from screen window into sprite window\par
{\b PWBLS}        PUT block of pixel data from screen window into sprite window\par
{\b PWORS}        OR pixel data from sprite window into screen window\par
{\b PWXRS}        XOR pixel data from sprite window into screen window\par
{\b PWNDS}        AND pixel data from sprite window into screen window\par
{\b PWATTS}       PUT block of attribute data from sprite window into screen window\par
\par
Note:\par
\par
If the command does not execute, check that the window is not partially off the\par
screen or sprite.\par
\par
Example:\par
\par
To block move a window 3 characters high and 4 characters wide from row 2, column\par
3 of the screen to row 4, column 6 of sprite number 7, use the following:\par
\par
7 SPN ! 3 HGT ! 4 LEN ! 2 ROW ! 3 COL ! 4 SROW ! 6 SCOL ! GWBLS\par
\par
Note that sprite 7 must be at least 8 characters wide and 7 characters high for\par
the command to execute.\par
\par
\par
\par
\par
\par
\par
\par
57\page
{\b Group 3}\par
\par
This group, possibly the most useful in the whole set, comprises commands which\par
support operations between sprites and sprite windows.  The same set of commands\par
as those in Group 2 are available and the format for each word is the same as in\par
Group 2, except that the commands are postfixed with an "M" instead of an "S".\par
The chief difference to the user lies in the set of parameters.  The size of the\par
data window is set to have the dimensions of the first sprite, and its position in\par
the second sprite is set using the SCOL and SROW parameters.\par
\par
\par
Parameter                 Use\par
\par
SP1        Number of the first sprite\par
SP2        Number of the second sprite (containing the window)\par
SCOL       Left hand column of target sprite window\par
SROW       Top row of target sprite window\par
\par
\par
Command                 Action\par
\par
{\b GWBLM}      Block move pixel data from first sprite into window in second sprite\par
{\b GWORM}      OR pixel data from first sprite into window in second sprite\par
{\b GWXRM}      XOR pixel data from first sprite into window in second sprite\par
{\b GWNDM}      AND pixel data from first sprite into window in second sprite\par
{\b GWATTM}     Block move attribute data from first sprite into window in second\par
           sprite\par
{\b PWBLM}      Block move pixel data from window in second sprite into first sprite\par
{\b PWORM}      OR pixel data from window in second sprite into first sprite\par
{\b PWXRM}      XOR pixel data from window in second sprite into first sprite\par
{\b PWNDM}      AND pixel data from window in second sprite into first sprite\par
{\b PWATTM}     Block move attribute data from window in second sprite into first\par
           sprite\par
\par
Note:\par
\par
If the width of the first sprite added to SCOL, or the height of the first sprite\par
added to SROW exceeds either the width or height of the second sprite\par
respectively, then the command will not execute.\par
\par
\par
{\b COPY COMMANDS}\par
\par
These five commands, are in fact a sub-group of the Group 3 commands and allow\par
operations between pairs of sprites with the same dimensions.  It is necessary,\par
therefore, to provide only two parameters instead of four.\par
\par
\par
Parameter                 Use\par
\par
SP1          Number of first sprite\par
SP2          Number of second sprite\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
                                                                                58\page
Command                Action\par
\par
{\b COPYM}        Copy first sprite pixel data into second sprite\par
{\b COPORM}       OR first sprite pixel data into second sprite\par
{\b COPXRM}       XOR first sprite pixel data into second sprite\par
{\b COPNDM}       AND first sprite pixel data into second sprite\par
{\b COPATTM}      Copy first sprite attribute data into second sprite\par
\par
Note:\par
If the dimensions of the two sprites are not identical, then the command will not\par
execute.\par
\par
Example:\par
\par
To make a complete copy of sprite 10 into sprite 8, use the following:\par
\par
8 SP1 ! 10 SP2 ! COPYM COPATTM\par
\par
\par
{\b SPRITE TRANSFORMATIONS}\par
\par
To increase the utility of the package, four extra words have been added to\par
invert, spin, reflect and enlarge sprites.  The inversion and reflection routines\par
work for screen and sprite data but the rotation and enlargement commands work\par
only on sprites and a dummy sprite is required to rotate or enlarge into.\par
\par
\par
{\b Inversions}\par
\par
The sprite is "1's complemented"; in other words, all the pixels which are set\par
"on", became set "off" and vice-versa.  The attributes, however, remain\par
unchanged.\par
\par
\par
Parameter             Use\par
\par
SPN          The number of the sprite to be inverted\par
\par
\par
Command             Action\par
\par
{\b INVM}         The sprite is inverted (1's complemented)\par
\par
\par
Parameter             Use\par
\par
COL          Column of the left hand edge of the screen window (0 to 31)\par
ROW          Row of the top edge of the window (0 to 23)\par
LEN          Width of the screen window (1 to 32)\par
HGT          Height of the screen window (1 to 24)\par
\par
\par
Command             Action\par
\par
{\b INVV}         Invert screen window\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
59\page
{\b Reflections}\par
\par
There are four commands in this group for reflecting screen and memory, pixel and\par
attribute data.  A sprite is often required to point in two directions and the\par
command can either be used at the development stage or, if space is short, at\par
run-time.  The command causes horizontal reflection but vertical reflection is\par
possible, by combining rotations and reflections.\par
\par
\par
Parameter            Use\par
\par
SPN          Number of sprite to be reflected (1 to 255)\par
\par
Command             Action\par
\par
{\b MIRM}         Reflect sprite pixel data about its centre\par
{\b MARM}         Reflect sprite attribute data about its centre\par
\par
\par
Parameter            Use\par
\par
COL          Column of left hand edge of screen window (0 to 31)\par
ROW          Row of top edge of the window (0 to 23)\par
LEN          Width of screen window (1 to 32)\par
HGT          Height of screen window (1 to 24)\par
\par
\par
Command            Action\par
{\b MIRV}         Reflect screen pixel data about window centre\par
{\b MARV}         Reflect screen attribute data about window centre\par
\par
\par
{\b Spin}\par
\par
This command involves an operation between two sprites with transposed dimensions.\par
If, for example, a sprite with dimensions 8 by 3 is to be spun into a second\par
sprite, this second sprite must have dimensions 3 by 8.  Square sprites are, of\par
course, no problem.  Pixel and attribute data are both rotated.  If the command is\par
to be used, it is important to remember that a second sprite will be needed to be\par
rotated into and that it is necessary to set this up in advance.  Rotation is 90\par
degrees clockwise.\par
\par
\par
Parameter             Use\par
\par
SP2         Number of sprite to be rotated\par
SP1         Number of sprite to be rotated into\par
\par
\par
Command             Action\par
\par
{\b SPINM}       Rotate 90 degrees clockwise sprite SP2 into sprite SP1.\par
\par
\par
Note:\par
\par
A sprite cannot be rotated into itself, i.e. if SP1 and SP2 are the same number,\par
the rotation will not work.  The result is, however, well worth seeing!  Data is\par
"OR"ed from SP2 into SP1 so it is usually necessary to execute a CLSM to clear\par
sprite SP1 before execution.\par
\par
\par
\par
\par
                                                                                60\page
{\b Enlargement}\par
\par
One command is provided for enlarging a sprite and its attributes into a second\par
sprite which has dimensions exactly double those of the sprite being enlarged.\par
\par
\par
Parameter              Use\par
\par
SP1          Number of the sprite into which the enlargement is carried\par
             out.\par
SP2          Number of the sprite being enlarged.\par
\par
\par
Command                Action\par
\par
{\b DSPM}         Enlarge sprite SP2 into sprite SP1.\par
\par
Note:\par
\par
If the dimensions of sprite SP1 are not twice those of sprite SP2 the command will\par
not execute.\par
\par
\par
{\b INTERRUPT RELATED WORDS}\par
\par
Six interrupt related words are provided which control the Foreground/Background\par
execution of White Lightning words.  The first four have no parameters.\par
\par
\par
Command                 Action\par
\par
{\b HALT}        Suspend CPU operation until the next interrupt.  Executing\par
            HALT in background mode will freeze the system permanently.\par
\par
{\b EI}          Enable the interrupt.\par
\par
{\b DI}          Disable the interrupt.\par
\par
{\b EXX}         Exchange IDEAL variables with the alternate IDEAL variables.\par
            This command is executed automatically each time an\par
            interrupt occurs and at the end of the interrupt routine\par
            to restore foreground variables.  If a background program\par
            is not being used EXX can be used to provide extra variables.\par
\par
{\b INT-ON}      The specified word (see next example) is executed on the\par
            receipt of each interrupt.\par
\par
{\b INT-OFF}     Following execution of INT-OFF the Z80 returns to interrupt\par
            mode 1 and polls the keyboard 50 times a second.  The\par
            background program ceases execution.\par
\par
Example:\par
\par
To set a word running in background type:\par
\par
' WORD INT-ON\par
\par
Where "WORD" is the word to be run in background.\par
\par
\par
\par
\par
\par
\par
61\page
{\b BASIC INTERFACE WORDS}\par
\par
These words are provided to enable you to mix BASIC and Forth in your program.\par
The section covering the access of BASIC should be read carefully before an\par
attempt is made to use these commands.\par
\par
\par
Command                Action\par
\par
{\b PROG}         Enter BASIC at command level.\par
\par
{\b RESERVE}      Reserve space in the dictionary for the insertion of BASIC\par
             source.  The size of the space to be reserved is taken from\par
             the stack.\par
\par
Example:\par
\par
1024 RESERVE\par
\par
will reserve 1k from the current value of HERE.\par
\par
{\b GOTO}         The BASIC program is executed from the line number held\par
             on the stack.  Forth can be called from BASIC using\par
             RANDOMISE USR 30000 and Forth can be re-entered using\par
             PRINT USR 30006.\par
\par
Example:\par
\par
100 GOTO\par
\par
will commence execution of the BASIC source from line 100.\par
\par
{\b RETUSR}       Control is returned to the BASIC program from Forth.\par
             Execution of the BASIC program proceeds with the first\par
             instruction after the RANDOMISE USR 30000 with which Forth\par
             was called.  Do not execute a RETUSR in Forth if Forth has\par
             not been called using a RANDOMISE USR 30000 call.\par
\par
\par
{\b MISCELLANEOUS WORDS}\par
\par
There are 18 words provided which cover general aspects of games development.\par
\par
\par
Command                 Action\par
\par
{\b SETAV}        Set the attributes to the current INK and PAPER colours in\par
             the screen window defined by HGT, LEN, COL, ROW.\par
\par
{\b SETAM}        Set the attributes to the current INK and PAPER colours in\par
             the sprite whose number is held in SPN.\par
\par
{\b CLSV}         Clear the screen window (defined by HGT, LEN, COL, ROW)\par
             of pixel data and set the attributes throughout to the\par
             current INK and PAPER colours.\par
\par
{\b CLSM}         Clear the pixel data of the sprite whose number is held\par
             in SPN.  Attribute data is unaffected.\par
\par
\par
\par
\par
\par
\par
                                                                                62\page
{\b ADJM}         This command is used to ensure the execution of group2 GET\par
             and PUT instructions.  The parameters are SPN, COL and ROW.\par
             First HGT and LEN are set to the dimensions of the sprite\par
             whose number is held in SPN.  If COL or ROW are "off\par
             screen" or if COL + LEN, HGT + ROW are off screen, then\par
             the parameters COL, ROW, HGT, LEN, SCOL, SROW are set such\par
             that the sprite will be partially PUT to the screen or\par
             GOT from the screen.  This is an extremely useful command\par
             and can be used in conjunction with any of the group 2 GETs\par
             and PUTS.\par
\par
Example:\par
\par
-1 COL ! -1 ROW ! 1 SPN ! ADJM PWBLS\par
\par
This will PUT part of sprite 1 in the top left hand corner.  After execution, COL\par
and ROW will have been made 0 and SCOL and SROW will have the value 1.\par
\par
{\b ADJV}         Essentially the same idea as ADJM but this time the screen\par
             window defined by HGT, LEN, COL, ROW is adjusted to lie\par
             "on screen"\par
\par
{\b SCANM}        The sprite whose number is held in SPN is scanned for\par
             pixel data.  If data is found a true (non-zero) flag is\par
             placed on the stack, otherwise a false (zero) flag is\par
             placed on the stack.  This command is used extensively for\par
             collision detection.\par
\par
{\b SCANV}        The character cell at screen positions defined by COL and\par
             ROW is scanned for screen data and a true or false flag\par
             stacked accordingly.  This command executes more rapidly\par
             than SCAM.\par
\par
{\b RND}          Replace the value at the top of the stack by a random\par
             number between zero and the value at the top of the stack.\par
\par
Example:\par
\par
10 RND\par
\par
will leave a number between 0 and 10 on the stack.\par
\par
{\b OUT#}         Output the second value on the stack to the port address\par
             at the top of the stack.\par
\par
{\b IN#}          Replace the port address an the top of the stack by the\par
             16 bit representation of the 8 bit number read from the\par
             port.\par
\par
Example:\par
\par
The following will poll the Kempston Joystick and execute one of 8 words depending\par
on the joystick position.  Finally, the fire button will be tested. Type:\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
63\page
: JOYSTICK 31 IN# DUP CASE <CR>\par
 0 OF ." CENTRE " ENDOF <CR>\par
 1 OF ." RIGHT " FNDOF <CR>\par
 2 OF ." LEFT " ENDOF <CR>\par
 4 OF ." DOWN " ENDOF <CR>\par
 8 OF ." UP " ENDOF <CR>\par
 9 OF ." UPRIGHT " ENDOF <CR>\par
10 OF ." UPLEFT " ENDOF <CR>\par
 5 OF ." DOWNRIGHT " ENDOF <CR>\par
 6 OF ." DOWNLEFT " ENDOF <CR>\par
ENDCASE <CR>\par
15 > IF ." FIRE " ENDIF ; <CR>\par
: JTEST BEGIN JOYSTICK CR 1 1 KB UNTIL ;<CR>\par
\par
To run type:\par
\par
JTEST <CR>\par
\par
To halt press CAPS SHIFT\par
\par
\par
{\b KB}           This command is provided for the detection of multiple key\par
             presses.  All it does, in fact, is test the specified key\par
             and stack a true flag if the key is pressed and a false flag if\par
             it is not.  The key to be tested is specified by the top two\par
             numbers on the stack.  The second value specifies the half ROW\par
             and the top value the COLUMN.  For a full description\par
             of the COLUMNS and ROWS of the Spectrum keyboard see page 160\par
             of the Spectrum manual.  Below is a summary.\par
\par
                  ROW               KEYS\par
\par
                   1               CAPS SHIFT to V\par
                   2               A to G\par
                   3               Q to T\par
                   4               1 to 5\par
                   5               0 to 6\par
                   6               P to 7\par
                   7               ENTER to H\par
                   8               SPACE to B\par
\par
\par
Columns are organised from 1 to 5 and counted from the outside in.  This is the\par
order above.\par
\par
\par
{\b BLEEP}        This operates in the same way as the Spectrum's BEEP\par
             command with the second number on the stack providing\par
             duration and top number pitch.\par
Example:\par
\par
100 200 BLEEP\par
\par
\par
{\b ATTON}        After the execution of ATTON, group 1 GETs and PUTs will GET\par
             and PUT attribute data at the same time as they GET and PUT\par
             pixel data.  The GW and PW commands, however, are unaffected\par
             by ATTON or ATTOFF and always use separate commands to\par
             move pixel data.  After the execution of a GW or PW command\par
             the attribute switch is always set to 'OFF'.\par
\par
\par
\par
\par
                                                                                64\page
{\b ATTOFF}       After the execution of ATOFF, group GETs and PUTs will move\par
             pixel data only.\par
\par
\par
{\b CALL}         Control jumps to a machine code subroutine whose address\par
             is held at the top of the stack.\par
\par
Example:\par
\par
HEX D000 CALL\par
\par
would execute a machine code subroutine at location D000 HEX. Don't type this\par
unless you have a machine code routine at HEX D000!\par
\par
\par
{\b ZAP}          Once program development is completed and you have compiled\par
             your final program into the dictionary, typing ZAP will\par
             produce a run-time version.  The length of the final\par
             version is displayed to the screen and a copy can be saved\par
             by typing:\par
\par
                        SAVE "filename" CODE 24832, LENGTH\par
\par
             the length being the length displayed.  Typing:\par
\par
                        PRINT USR 24832\par
\par
              will execute the last word defined before the ZAP command.\par
              This is the only form in which White Lightning programs\par
              can be commercially sold.\par
\par
\par
{\b ZAPINT}        As above except that programs which utilise the\par
              Foreground/Background facility must be produced using the\par
              ZAPINT command as opposed to the ZAP command.  The only\par
              real difference is that the first five screens also need\par
              to be saved and that the top 16 bytes of RAM will be\par
              used by the final program.\par
\par
\par
{\b PRT-ON}        All subsequent screen output is to ZX-Printer only.\par
\par
\par
{\b PRT-OFF}       All subsequent output is to screen only.\par
\par
Example:\par
\par
PRT-ON VLIST PRT-OFF\par
\par
will list the current FORTH dictionary to the ZX-Printer.\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
65\page
{\b FORTH/BASIC WORDS}\par
\par
For those users who have mastered and grown used to the Spectrum's own graphics\par
commands, a set of 18 Forth implementations of Spectrum words is provided.\par
Parameters are placed on the stack in the same order as they occur in their BASIC\par
implementations.  If an error occurs during the execution of a BASIC word, Forth\par
should be re-entered via a WARM start, i.e. PRINT USR 24836.  For a full\par
description of the action of each of these words refer to your Spectrum manual.\par
\par
\par
PARAMETERS      WORD      ACTION\par
\par
                {\b COPY}      The screen in 'dumped' to the ZX-Printer.\par
\par
ROW, COL        {\b AT}        The print position is moved the specified\par
                          Column and Row.\par
\par
COLOUR          {\b BORDER}    The border colour is set to one of the 8\par
                          Spectrum colours.\par
\par
                {\b CLS}       The screen is cleared of pixel data and the\par
                          attributes set to the current INK, PAPER,\par
                          BRIGHT and FLASH values.\par
\par
X,Y,ANGLE       {\b DRAW-ARC}  See Spectrum manual page 122.\par
\par
X,Y,RADIUS      {\b CIRCLE}    See Spectrum manual page 123.\par
\par
X,Y             {\b DRAW}      See Spectrum manual page 121.\par
\par
X,Y             {\b PLOT}      See Spectrum manual page 121.\par
\par
ROW, COL        {\b SCREEN$}   The character at the screen position defined\par
                          by the two values at the top of the stack is\par
                          tested to see if it is one of the Spectrum's\par
                          pre-defined characters.  The ASCII value\par
                          is left on the stack.\par
\par
ROW, COL        {\b ATTR}      The code for the attribute at the screen\par
                          position defined by the top two values on the\par
                          stack is left on the stack.\par
\par
X,Y             {\b POINT}     The pixel at the (x,y) co-ord defined by the\par
                          top two values on the stack is tested and\par
                          a true or false flag stacked depending on\par
                          whether the pixel is set or not.\par
\par
COL             {\b TAB}       Set the horizontal print position to the\par
                          value at the top of the stack.\par
\par
COLOUR          {\b INK}       Set the INK colour to the value at the top\par
                          of the stack.\par
\par
COLOUR          {\b PAPER}     Set the PAPER colour to the value at the top\par
                          of the stack.\par
\par
FLAG            {\b OVER.}     Note the full stop at the end of OVER.\par
                          This sets the printing mode according to\par
                          the value of FLAG which is zero or one.\par
\par
FLAG            {\b INVERSE}   As for OVER.\par
\par
FLAG            {\b BRIGHT}    As for OVER.\par
\par
                                                                                66\page
{\b FOREGROUND BACKGROUND}\par
\par
\par
Mastering machine code does give most programmers access to the speed of\par
commercial games, but often the smoothness and continuity are lacking.  One of the\par
greatest difficulties facing any games designer is timing.  The basic problem is\par
that some parts of the program need to execute at regular intervals, and trying to\par
achieve this can involve a lot of calculation and wasted processor time.  The\par
solution to this is to use interrupts to execute particular sections of code.\par
White Lightning does this for you, using the words INT-ON and INT-OFF.\par
\par
The Spectrum interrupt occurs 50 times a second, so background words can be\par
executed at this frequency, or by counting interrupts, at lower frequencies.\par
\par
If you list any of the screens 1 to 5, you will see that they are apparently\par
filled with garbage.  This is because the area in memory occupied by these screens\par
contains the machine code that enables the background facility.  If you are not\par
intending to use this facility, then you can clear screens 1 to 5 and use them\par
normally for source code.  If you do this, however, don't forget that you won't be\par
able to use any of the graphics words in background mode, or the system will crash\par
in no uncertain manner!\par
\par
When an interrupt occurs, the foreground program stops exactly where it is, saves\par
off its parameters and then executes the background word.  The background word\par
will then execute fully before continuing execution of the foreground program,\par
from the exact point at which it was halted.  Three important points should be\par
borne in mind.  Firstly, if the execution time of the background word exceeds a\par
fiftieth of a second, it is not possible to execute it more than twenty five times\par
a second, if it exceeds a twenty-fifth of a second, it can only be executed at\par
half that frequency, and so on.  There is, however, no limit to the length of the\par
background execution time itself.  Secondly, as the execution time approaches a\par
fiftieth of a second, or some multiple of a fiftieth of a second, then less and\par
less processor time will be available for the foreground program and sometimes it\par
is necessary to extend the length of the background program to make the foreground\par
program run more quickly, by reducing the frequency of the background program.\par
Experimentation will familiarise the user with the techniques required for the\par
best effects.  More foreground time can also be taken by disabling and then re-\par
enabling the interrupt using DI and EI respectively.  This brings us to the third,\par
and most important point.  Remember that when an interrupt occurs, the foreground\par
program will stop whatever it is doing, execute the background program and then\par
continue with the foreground execution.  Suppose the background program is a\par
sideways scroll of a user defined screen window and the foreground program PUTs a\par
character into the window.  A problem arises if an interrupt occurs halfway\par
through the PUT, because the top half of the character will be scrolled before the\par
second half of the character is PUT to the screen.  To circumvent this problem,\par
where an operation is carried out on the same screen or sprite data by both the\par
foreground and background programs, the background program should be temporarily\par
disabled using DI, the foreground word executed, and then the background program\par
re-enabled using EI ready for the next interrupt to occur.  The safest way to\par
proceed until you have really mastered the language, is to avoid the situation\par
altogether and make sure the foreground and background programs don't operate on\par
the same sprite or screen area.\par
\par
To set the background program running, simply type an apostrophe (shifted 7), a\par
space, the word to be executed, a space and then INT-ON.  Don't forget that if the\par
background word does not set its own parameters, then these will need to be set\par
before execution and if these are the IDEAL variables, then the alternate set will\par
be used.\par
\par
\par
\par
\par
\par
\par
67\page
For example, suppose you wanted to scroll a window, four characters square, in the\par
middle of the screen and invert it after each sideways scroll.  First we need to\par
define a word to do the scrolling and the inverting.  For some reason, most test\par
programs are called FRED and there is no reason for breaking with convention.  To\par
define the word type:\par
\par
: FRED WRR1V INVV ; <CR>\par
\par
To set up the parameters type:\par
\par
4 HGT' ! 4 LEN' ! 14 COL' ! 9 ROW' ! <CR>\par
\par
To make sure there is some data in the window, type:\par
\par
VLIST <CR>\par
\par
You are now ready to execute the background program by typing:\par
\par
' FRED INT-ON <CR>\par
\par
To halt this program type:\par
\par
INT-OFF <CR>\par
\par
This program is running a bit too fast to see, so let's write another program\par
which slows this down to every fifth interrupt, i.e. ten times a second.  We will\par
need to define a variable and a new word.  To set up the variable type:\par
\par
0 VARIABLE ICNT <CR>\par
\par
This sets up a variable called ICNT and assigns to it the value 0.  We'll call\par
this new background word FREDA.  Type:\par
\par
: FREDA ICNT @ 1+ 5 > IF FRED 0 ICNT ! ELSE 1 ICNT + ! ENDIF ; <CR>\par
\par
Now type:\par
\par
' FREDA INT-ON <CR>\par
\par
All "FREDA" does, is to increment ICNT and compare it with 5 and if it is greater\par
than 5 then "FREDA" is executed and ICNT set back to zero.\par
\par
It would be useful to be able to control the speed that "FREDA" ran at, so, let's\par
modify "FREDA" to do this.  First, type INT-OFF FORGET FREDA <CR> to get rid of\par
the old definition and then set up a new variable and construct a slightly\par
different program.  A variable which sets the limit on the number of interrupts\par
needs to be set up, so type: 4 VARIABLE LCNT <CR>.  The new definition is set up\par
by typing:\par
\par
: FREDA ICNT @ 1+ LCNT @ > IF FRED 0 ICNT ! ELSE 1 ICNT +! FNDIF ; <CR>\par
\par
To execute the new word type:\par
\par
0 ICNT ! ' FREDA INT-ON <CR>\par
\par
This program increments ICNT, compares it with LCNT and executes when ICNT is\par
equal to LCNT.  Increasing LCNT then, will slow the background execution and\par
decrementing LCNT will speed it up.  If LCNT is put equal to 1, execution will\par
occur every cycle.\par
\par
\par
\par
\par
\par
                                                                                68\page
To speed up "FREDA" type: 0 ICNT ! 2 LCNT ! <CR> and to slow "FREDA" type 10 LCNT\par
! <CR> and so on.  Type: INT-OFF <CR> to halt FREDA.  Now type: FORGET FREDA <CR>\par
\par
\par
{\b Frequency and Phase}\par
\par
One of the problems with executing a word on each interrupt,  is that the dot\par
scanning the screen may overtake the screen operation in the same position on each\par
execution.  This can produce some strange effects, and often, sections of the\par
screen window will appear to be "sliced".  It is more usual to execute on selected\par
interrupts.  We can do this very simply using modular arithmetic.\par
\par
Suppose we have four different words that we wish to execute with four different\par
frequencies.  Suppose they are as follows.\par
\par
                    INVV   every 50 cycles\par
                    MIRV   every 20 cycles\par
                    WRR1V  every  4 cycles\par
                    WCRV   every  5 cycles\par
\par
We now define a variable to count interrupts and four constants to store the\par
frequencies.\par
\par
0 VARIABLE ICNT 50 CONSTANT F1 20 CONSTANT F2 4 CONSTANT F3 5 CONSTANT F4 <CR>\par
: MAO MOD ABS 0= ; <CR>\par
: IRUN ICNT @ DUP DUP DUP <CR>\par
F1 MAO IF INVV ENDIF <CR>\par
F2 MAO IF MIRV ENDIF <CR>\par
F3 MAO IF WRR1V ENDIF <CR>\par
F4 MAO IF WCRV ENDIF <CR>\par
1 ICNT @ +! ; <CR>\par
\par
All we need to do now is set up the parameters by typing:\par
\par
10 COL' ! 10 ROW' ! 6 HGT' ! 8 LEN' ! 2 NPX' ! <CR>\par
\par
then put some data on to the screen and execute:\par
\par
VLIST 0 0 AT ' IRUN INT-ON <CR>\par
\par
To terminate, type INT-OFF <CR>\par
\par
If we had made the F1 to F4 variables, we could have controlled the background\par
program from the foreground by resetting them.\par
\par
Sometimes, controlling the frequencies of events is not sufficient and phase\par
information needs to be introduced.  In the previous example, values of 0, 100,\par
200, 300 and so on cause all four events.  Supposing we wanted to maintain these\par
frequencies, but change the order in which the words execute - we need to\par
introduce the concept of phase.\par
\par
In this example we need four more constants, so type:\par
\par
FORGET IRUN <CR>\par
\par
31 CONSTANT PH1 5 CONSTANT PH2 0 CONSTANT PH3 3 CONSTANT PH4 <CR>\par
\par
\par
\par
\par
\par
\par
\par
\par
69\page
Now type:\par
\par
: IRUN ICNT @ DUP DUP DUP <CR>\par
F1 MOD ABS PH1 = IF INVV ENDIF <CR>\par
F2 MOD ABS PH2 = IF MIRV ENDIF <CR>\par
F3 MOD ABS PH3 = IF WRR1V ENDIF <CR>\par
F4 MOD ABS PH4 = IF WCRV ENDIF <CR>\par
1 ICNT +! ; <CR>\par
\par
This can be executed using VLIST ' IRUN INT-ON <CR>\par
Halted using: INT-OFF <CR>\par
and cleared using: FORGET IRUN <CR>\par
\par
\par
{\b Forth/BASIC Words}\par
\par
Sinclair's graphics and sound commands have been replicated as Forth words for\par
continuity - they also execute slightly more rapidly than their BASIC\par
counterparts.  For a full list, see the section on Forth/BASIC WORDS.\par
\par
They all execute code in Sinclair's own ROM which, unlike Forth and IDEAL, is not\par
re-entrant.  This means that these words cannot be executed in foreground and\par
background simultaneously.  The FORTH words ." , . and U. should also not be\par
executed simultaneously with themselves or any of the BASIC words.  None of the\par
Forth/BASIC words, ." , . or U. should be executed in background while Forth is in\par
command mode.\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
                                                                                70\page
{\b LOGICAL OPERATIONS}\par
\par
There are three types of logical operation included in the IDEAL sub-language;\par
these are OR, XOR and AND.  To get the best out of this package it is important to\par
make full use of these commands.\par
\par
If a GET or PUT postfixed with "BLS" or "BLM" is executed,  then data is block\par
moved from the source which may be part of the screen, a sprite, or a sprite\par
window, in such a way that whatever was previously held at the destination which\par
may also be part of the screen, a sprite, or a sprite window, is obliterated and\par
replaced by whatever was at the source.  This may not always be the desired effect\par
and quite often the user will want to merge characters or remove parts of the\par
characters and so on.\par
\par
If two sprites are "OR"ed together, the resulting sprite will have pixels set\par
where pixels were set in either or both of the sprites being "OR"ed.\par
\par
If two sprites are "AND"ed together, the resulting sprite will have pixels set\par
where pixels were set in both of the sprites being "AND"ed.\par
\par
If two sprites are "XOR"ed together, the resulting sprite will have pixels set\par
where pixels were set in either but reset where pixels were set or reset in both.\par
\par
These results are summarised as follows and should make things a little clearer:\par
\par
\par
{\b SOURCE}         {\b DESTINATION}         {\b OPERATION}        {\b RESULT}\par
\par
  on               on                 OR              on\par
  on               off                OR              on\par
  off              on                 OR              on\par
  off              off                OR              off\par
\par
  on               on                 OR              on\par
  on               off                OR              off\par
  off              on                 OR              off\par
  off              off                OR              off\par
\par
  on               on                 XOR             off\par
  on               off                XOR             on\par
  off              on                 XOR             on\par
  off              off                XOR             off\par
\par
\par
We can now use the sample sprites to illustrate the effects of these operations.\par
First FORGET any previously defined words and type: DECIMAL <CR> to ensure that\par
you are in decimal mode. Now type:\par
\par
7 INK 0 PAPER CLS ." LOGICAL OR " CR ." LOGICAL OR " <CR>\par
\par
This will clear the screen and put some data in the top left hand corner.\par
\par
Now type:\par
\par
3 SPN ! 0 COL ! 0 ROW 1 ATTOFF PUTORS <CR>\par
\par
You will see that the data has been merged together, both the dragster and the\par
letters remain.\par
\par
\par
\par
\par
\par
\par
71\page
Now type:\par
\par
CLS ." LOGICAL AND " CR ." LOGICAL AND " PUTNDS <CR>\par
\par
This time, the only data remaining is at those points where the data coincided.\par
Logical "AND"s are normally used to mark off sections of the screen or sprites.\par
They are also used extensively for collision detection.  If a window of the screen\par
is "AND"ed into a sprite, and then a SCANM performed, it is possible to determine\par
whether a collision would occur if the sprite were PUT; before actually PUTting\par
the sprite.\par
\par
We now come to the logical XOR.  This is probably the most useful operation of the\par
lot. "XOR"s have the peculiar property of restoring the destination data to its\par
former state if the operation is performed twice.  This is how Sinclair's own\par
"OVER" operation works.  To see this happen type:\par
\par
CLS ." XOR " CR ." XOR " PUTXRS <CR>\par
\par
To restore the text type:\par
\par
PUTXRS <CR>\par
\par
We can even use this property to swap two sprites without using a third.  This\par
example will swap the data but not the attributes.  We will "PUT" two sprites at\par
each stage so you can see what is happening.  Type:\par
\par
CLS ATTON 0 SCOL ! 0 SROW ! 1 SP1 ! 2 SP2 ! 23 COL ! 6 0 AT <CR>\par
\par
Now type:\par
\par
1 SPN ! PUTBLS 2 SPN ! 27 COL ! PUTBLS <CR>\par
\par
These are the two sprites before the operations begin.\par
\par
Now type:\par
\par
GWXRM 2 ROW ! 23 COL ! 1 SPN ! PUTBLS 27 COL ! 2 SPN ! PUTBLS <CR>\par
\par
sprite 1 has now been "XOR"ed into sprite 2.  Now type:\par
\par
PWXRM 4 ROW ! 23 COL ! 1 SPN ! PUTBLS 27 COL 1 2 SPN ! PUTBLS <CR>\par
\par
sprite 2 is now in sprite 1.  Finally, type:\par
\par
GWXRM 6 ROW ! 23 COL ! 1 SPN ! PUTBLS 27 COL ! 2 SPN ! PUTBLS <CR>\par
\par
The operation is now complete.\par
\par
If we wanted to add a new word to the language which swaps two equally sized\par
sprites whose numbers were in SP1 and SP2, we would now do so.\par
\par
: SWOP 0 SCOL ! 0 SROW 1 GWXRM PWXRM GWXRM ; <CR>\par
\par
In fact we could also use:\par
\par
: SWOP 0 SCOL ! 0 SROW ! PWXRM GXXRM PWXRM ; <CR>\par
\par
for exactly the same effect.  You will get MSG # 4 if you type the second word\par
before typing FORGOT SWOP <CR>\par
\par
Ironically, even though we can swap pixel data, there is no simple method for\par
swapping attribute data unless a third sprite is involved.\par
\par
\par
                                                                                72\page
{\b COLLISION DETECTION AND SPRITE RECOGNITION}\par
\par
Two words are provided for collision detection, these are SCANV and SCANM.\par
\par
SCANV is used to scan a particular character position on the screen.  If any data\par
is present in the specified square (co-ords are held in COL and ROW), then a true\par
flag is placed on the stack and if the square is empty (contains no pixel data), a\par
false flag is placed on the stack. Type:\par
\par
CLS VLIST 0 VARIABLE CNT <CR>\par
\par
This will put some data on the screen and initiate the variable CNT.  Now type:\par
\par
: GO 0 CNT ! 24 0 DO I ROW ! 32 0 <CR>\par
DO I COL ! SCANV IF 1 CNT +! <CR>\par
ENDIF LOOP LOOP CNT ? ; <CR>\par
\par
This defines a word which simply counts the number of characters on the screen.\par
Type:\par
\par
GO <CR>\par
\par
This should print a number somewhere around 250.\par
\par
Often it is insufficient to determine whether a particular character square\par
contains data or not, and for this reason the slower, but more powerful command\par
SCANM, has been included. This will scan the sprite whose number is held in SPN\par
and put a true flag on the stack if the sprite contains pixel data, or a false\par
flag if it does not.  SCANM is normally used to perform one of three functions:\par
\par
1.  To see if data will collide.\par
\par
2.  To detect an exact pattern.\par
\par
3.  To detect the presence of a pattern.\par
\par
Collision detection is most commonly used to detect a collision between a sprite\par
moving across the screen and any data which lies in its path.  Often the sprite\par
can pass through an occupied character position without a collision occurring, so\par
the SCANM command is insufficient.  The procedure is basically to load a dummy\par
sprite with the section of screen into which the sprite is about to be put, "AND"\par
it with the sprite about to be PUT and then use SCANM.  If a true flag is on the\par
stack the dummy sprite contains data and therefore a collision has occurred.  This\par
is all very well, but a problem occurs if the new sprite position overlaps the old\par
sprite position, because this means that the old sprite has to be removed from the\par
screen before beginning the above detection procedure and subsequently PUTting the\par
new sprite.  This delay causes flicker.  The easiest solution is to work with\par
"XOR"s so that the window can be GOT, "XOR"ed with the old sprite in memory to\par
remove the old sprite data, and then to do the detection followed finally by the\par
blotting and then immediate PUTting.\par
\par
Once an impending collision is detected it is frequently useful to determine what\par
the sprite has collided with.  To begin with, let's assume that the screen window\par
we're examining contains one of a known set of objects and that no other data is\par
present in the window.  The method is to load the dummy sprite with the object to\par
be tested and then compare it against the set of sprites with which a match is\par
being sought.  To compare the dummy sprite with a known sprite, all you need to do\par
is XOR the sprite being tested into the dummy and do a SCANM.  If the result is\par
zero, an exact match was found, if not, do a second XOR into the dummy to restore\par
it and test the next candidate.\par
\par
\par
\par
\par
73\page
Finally, consider the case where the object being tested contains extraneous data\par
in addition to one of the possible sprites.  This time, the dummy  sprite is\par
loaded with the contents of the screen window, but the candidates are first\par
"AND"ed into the dummy to remove extraneous data before the XOR and SCANM.\par
Finally the dummy needs to be reloaded from the screen before the next test.  This\par
latter test is limited by the fact that its conclusion is only that the screen\par
contained all the parts of the sprite with which a comparison was made. In the\par
extreme case of the screen window containing all pixels set, then an agreement\par
would be found with all the sprites tested.\par
\par
\par
{\b SCROLLING LANDSCAPES}\par
\par
Scrolling landscapes are an integral part of so many video games that it is worth\par
a brief description of how they can best be produced using White Lightning.\par
\par
The first and most obvious point is never to scroll more than you have to.  If,\par
for instance, you are moving a mountain range where the variation takes place over\par
the top three characters, then only the top three characters need to be stored and\par
moved.\par
\par
The simplest and most effective method of producing smooth scrolls is to sacrifice\par
a column of the screen for transactions with the sprite being scrolled.  Suppose\par
we are scrolling a sprite of 4 or 5 screens width which uses rows 8 to 10 (3\par
rows).  Suppose we require pixel scrolling and there is no horizontal variation in\par
attributes.  It doesn't really matter which column we sacrifice, far right (column\par
31) or far left (column 0), but let's, for this example, use column 0.  All that\par
we need to do is set up a window 1 character wide and 3 characters high on the far\par
left of the landscape to have the same INK and PAPER colours.  This means that\par
pixel data cannot be seen in this region.  Use the SETAV command to do this.  To\par
begin with, 31 columns of the sprite are PUT to the active part of the screen\par
using the PWBLS command.  If scrolling is to the left, then the dummy column\par
should be loaded with the next column to the right of the sprite now 'on screen'.\par
If scrolling is to the right then the column to the left of the sprite window\par
should be inserted.  The full 32 column screen window is now wrapped in the\par
appropriate direction until a total of + or - 8 pixels has been accrued.  The\par
dummy column is then loaded from the appropriate sprite column and so on.  The\par
method can be simply adapted to make the landscape wrap and is usually implemented\par
under interrupt.\par
\par
{\b PROGRAMMABLE SPRITES}\par
\par
One of the most common applications of the background mode is the setting of\par
sprites into automatic motion.  Perhaps the chief advantage that a language has\par
over a games designer, is that the sprites thus created can have as much\par
'intelligence' as the programmer requires.  A sprite can bounce off the edge of\par
the screen and/or other sprites until a particular event, and then totally change\par
its behaviour - possibly to follow a previously stored track.\par
\par
We have included a very simple listing which sets a sprite in motion, that just\par
bounces off the edges of the screen, to give you some idea of what is involved.\par
This sample program assumes you have the demonstration sprites in memory.\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
                                                                                74\page
SCR # 6\par
  0\par
  1\par
  2\par
  3 0 VARIABLE DELAY : WAIT DELAY @ 0 DO NOOP LOOP ;\par
  4 : BASE 0 COL ! 18 ROW ! 32 LEN ! 6 HGT ! 0 PAPER 0 INK\par
  5 SETAV 7 INK ;\par
  6 : GO16 6 PAPER 0 INK 0 BORDER CLS 7 0 AT\par
  7 10 0 DO ." WHITE LIGHTNING " LOOP 0 0 AT BASE ; -->\par
\par
SCR # 7\par
  0 8 VARIABLE PX 8 VARIABLE PY 1 VARIABLE DX 1 VARIABLE DY\par
  1 0 VARIABLE SP 0 VARIABLE CL 0 VARIABLE RW : PCAL PX @ ABS\par
  2 2 /MOD CL ! PY @ ABS 2 /MOD RW ! DUP + + 251 + SP ! ;\par
  3 : MOVE PX @ 56 > IF DX @ MINUS DX ! ENDIF PX @ 0 > IF NOOP\par
  4 ELSE DX @ MINUS DX ! ENDIF\par
  5 PY @ 28 > IF DY @ MINUS DY ! FNDIF PY @ 0 > IF NOOP ELSE DY @\par
  6 MINUS DY ! ENDIF DY @ PY @ + PY ! DX @ PX @ + PX ! ;\par
  7 : LO RW @ ROW ! CL @ COL 1 SP @ SPN ! ; -->\par
\par
SCR # 8\par
  0 : SOT PCAL LD EXX LD EXX PUTXRS ;\par
  1 : GO PCAL MOVE PUTXRS LD PUTXRS ;\par
  2 0 VARIABLE ICNT 2 VARIABLE LCNT\par
  3 : IRUN 1 ICNT +! ICNT @ DUP 2000 = IF -2 DX ! ENDIF DUP 4002 =\par
  4 IF 2 DY ! ENDIF DUP 6000 = IF 3 DY ! ENDIF DUP 8000 = IF 1 DY\par
  5 ! 1 DX ! ENDIF 9000 = IF INT-OFF ENDIF ;\par
  6 : TRY SOT ' GO INT-ON 9000 0 DO IRUN LOOP  INT-OFF ;\par
  7 : SCN16 GO16 9999 DELAY ! WAIT 1 DX ! 1 DY ! 8 PX ! 8 PY ! -->\par
\par
SCR # 9\par
  0 0 ICNT ! TRY WAIT 0 PAPER 7 INK CLS ;\par
  1\par
  2\par
  3\par
  4\par
  5\par
  6\par
  7\par
\par
To compile this type:\par
\par
6 LOAD <CR>\par
\par
and to execute type:\par
\par
SCN16 <CR>\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
75\page
{\b THE BASIC INTERFACE}\par
\par
The BASIC interface was provided to increase the flexibility of the language and\par
allow the newcomer to Forth, a gradual transition.  Some applications are actually\par
more suited to BASIC but for games writing in general, Forth is much more\par
appropriate and we hope that this facility will not discourage people from\par
experimenting with Forth.\par
\par
There are four words to master at the Forth end and 3 USR calls to master at the\par
BASIC end.  Do not use CLEAR or NEW whilst in BASIC.\par
\par
\par
{\b The Command Level}\par
\par
When White Lightning is first entered from a COLD start, BASIC is located beneath\par
Forth and there is approximately 1k of program space if microdrives are not in\par
use.  This is ample space if BASIC is only to be used at command level, to LOAD\par
and SAVE for instance, but if programs are to be written you will need to execute\par
the RESERVE command.  For the time being, however, let's just consider operation\par
at the command level.  To enter BASIC from Forth type:\par
\par
PROG <CR>\par
\par
To re-enter Forth from BASIC just use:\par
\par
PRINT USR 24836 <CR>\par
\par
This is the normal WARM start entry.  Note that PRINT USR must be used and not\par
RANDOMIZE USR, or an OUT OF SCREEN error may occur.\par
\par
\par
{\b BASIC AS A SUBROUTINE}\par
\par
At the next level, lines of BASIC can be executed as if they were subroutines and\par
then return made to your Forth program.  The word at the Forth end is GOTO.  To\par
return to Forth and continue execution use PRINT USR 30006.\par
\par
To begin with, space needs to be made in the dictionary for the basic program.\par
The word used to do this is RESERVE.  What RESERVE actually does, is to make space\par
in the dictionary and reset BASIC's system variables to point to this new area.\par
This does mean, however, that if a second reserve is done, without FORGETting the\par
old space, then the old space is lost and can never be re-accessed.  Do not\par
execute a Forth COLD start while BASIC is reserved or a RAMTOP error may occur if\par
insufficient memory is reserved.  Always execute PROG as the next command after\par
RESERVE.\par
\par
As an example, try the following:\par
\par
DECIMAL 2000 RESERVE PROG <CR>\par
\par
This will set up the BASIC space and then enter it at command mode.  The following\par
lines of BASIC can now be entered:\par
\par
1000 PRINT "LINE 1000 OF BASIC" : PRINT USR 30006\par
2000 PRINT "LINE 2000 OF BASIC"\par
2010 FOR I = 1 TO 8 : PRINT I : NEXT I\par
2020 PRINT USR 30006\par
\par
\par
\par
\par
\par
\par
\par
                                                                                76\page
After entering these lines type:\par
\par
PRINT USR 24836\par
\par
to re-enter Forth at command level.\par
\par
Let's now define a word which executes some Forth, some BASIC, some more Forth,\par
some more BASIC, and finally some more Forth.  To begin executing BASIC at a\par
particular line, all that we need to do is put the line number on the stack and\par
then execute GOTO. Try the following:\par
\par
: FBDEM ." IN FORTH " CR 1000 GOTO ." BACK IN FORTH " <CR>\par
CR 2000 GOTO ." FORTH AGAIN " ; <CR>\par
\par
Now type FBDEM <CR>\par
\par
A more useful application would be to define words to handle cassette loading and\par
saving.  BASIC source is saved and loaded in the normal way from the reserved\par
BASIC area.\par
\par
\par
{\b Forth As A Subroutine}\par
\par
If you're an "out and out BASIC person" you're probably more likely to want to\par
execute Forth as a subroutine.  To return to BASIC from Forth use the word RETUSR.\par
To call Forth from BASIC use RANDOMIZE USR 30000.  Note that on this occasion it\par
is a RANDOMIZE USR and not a PRINT USR.  Using the previously reserved space we\par
can try another example.  First type:\par
\par
PROG <CR>\par
\par
to enter BASIC, then add the following lines:\par
\par
3000 PRINT " CALLING FORTH " : RANDOMIZE USR 30000\par
3010 PRINT " BACK IN BASIC " : PRINT USR 30006\par
\par
Now type PRINT USR 24836 to re-enter Forth.\par
\par
Now type:\par
\par
: BFDEM ." GOTO BASIC " CR 30000 GOTO ." FORTH CALLED " <CR>\par
RETUSR ." ENDING IN FORTH " CR ; <CR>\par
\par
Now type\par
\par
BFDEM <CR>\par
\par
to see the result.\par
\par
Now type\par
\par
FORGET FBDEM <CR>\par
\par
\par
{\b Passing Parameters}\par
\par
Forth variables can easily be PEEK'ed and POKE'd from BASIC and used not only to\par
pass data, but also to control the execution of Forth.  As an example, suppose we\par
wished to select one of 4 Forth words at any one time with a call from BASIC.  Let\par
the Forth words simply be ." WORD1 ", ." WORD2 ", ." WORD3 ", ." WORD4 ". First\par
we'll need a variable to pass the parameter, so type:\par
\par
\par
\par
77\page
0 VARIABLE CONTROL CONTROL U. <CR>\par
\par
This will set up a variable called CONTROL, set it to zero and then print the\par
address of the least significant byte which we'll use to pass the information.\par
For the sake of this example suppose the address was 50000.  We'll now use the\par
CASE construct to select the word to execute.  Use the following definitions:\par
\par
: SELECT CASE 1 OF ." WORD1 " ENDOF 2 OF ." WORD2 " <CR>\par
ENDOF 3 OF ." WORD3 " ENDOF 4 OF ." WORD4 " ENDOF <CR>\par
ENDCASE CR ; <CR>\par
\par
If the value in CONTROL is 1 to 4, the appropriate word will be executed.\par
\par
: RUN 4000 GOTO BEGIN CONTROL @ <CR>\par
DUP SELECT DUP IF RETUSR ENDIF 0= UNTIL ; <CR>\par
\par
The BASIC program is initially entered at 4000 and could take the following form:\par
\par
4000 REM REPLACE ADDRESS 5000 WITH THE ADDRESS OF CONTROL\par
4010 PRINT " EXECUTE WORD1 " : GOSUB 5000\par
4020 PRINT " EXECUTE WORD2 " : GOSUB 5010\par
4030 PRINT " EXECUTE WORD3 " : GOSUB 5020\par
4040 PRINT " EXECUTE WORD4 " : GOSUB 5030\par
4050 PRINT " FINISH " : POKE 50000,0 : PRINT USR 30006\par
5000 POKE 5000,1 : RANDOMISE USR 30000 : RETURN\par
5010 POKE 5000,2 : RANDOMISE USR 30000 : RETURN\par
5020 POKE 5000,3 : RANDOMISE USR 30000 : RETURN\par
5030 POKE 5000,4 : RANDOMISE USR 30000 : RETURN\par
\par
Note that when final return is made to Forth a PRINT USR 30006 is used.  If a\par
RANDOMISE USR 30006 CALL is made to Forth a RETUSR must be executed or the BASIC\par
stack will be left corrupted.  To reset the stack if it has been corrupted, use\par
PROG to enter BASIC and then re-enter Forth with the WARM start, PRINT USR 24836.\par
\par
This concludes the section on the BASIC Interface.\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
                                                                                78\page
{\b PROGRAM DEVELOPMENT}\par
\par
At any one time, there are up to five areas of development:  Forth source code,\par
BASIC source code, sprites, the Forth language itself, and finally the compiled\par
and completed program.\par
\par
\par
{\b Forth Source}\par
\par
As previously discussed under the section on editing, Forth source is divided into\par
screens, each of 512 bytes in length.   Each screen can be individually loaded,\par
saved and compiled in any order required.  Screens can even be saved and then\par
loaded back into different screens.  The real advantage of this comes when you're\par
writing really large programs.  As sprite space becomes large, it will work down\par
over the higher screens and this can be clearly seen when an attempt is made to\par
List them. Don't CLEAR these screens or the sprite data will be lost!\par
\par
If really large programs are required and sprites have over-run the top screens,\par
then programs can be compiled a few screens at a time, loading each time into the\par
available screens, compiling and then loading the next section.  Of course, you\par
don't need to load the sprites until compilation is complete, but it's useful to\par
have the facility just in case.\par
\par
To save Forth source you'll need to consult Table 1, the table of Screen\par
Addresses.  If, for instance, you wanted to save screens 6 to 11, then the start\par
address would be 52224 decimal and the length, just 6 times 512.  Type 6 512 * .\par
<CR> to find this figure, which is 3072.  To save the source, type PROG to enter\par
BASIC and then type:\par
\par
SAVE "filename" CODE 52224,3072\par
\par
To re-enter White Lightning, type PRINT USR 24836 to do a WARM start.\par
\par
To Load the source, either type Y in response to the LOAD SOURCE Y/N prompt at the\par
beginning of the session, or exit to BASIC using PROG, then type:\par
\par
LOAD "filename" CODE     where filename is optional.\par
\par
If you want to load the code into a different screen area from that in which it\par
was Saved, type:\par
\par
LOAD "filename" CODE start, length\par
\par
where start is the address of the screen to be loaded, and length is the number of\par
screens to be loaded multiplied by 512.  Again, White Lightning should be\par
re-entered with a PRINT USR 24836.  Do not use RANDOMISE USR 24836 or an OUT OF\par
SCREEN error may occur.\par
\par
\par
{\b BASIC Source}\par
\par
Before BASIC source can be used in White Lightning programs, the user must execute\par
a RESERVE to make space for the BASIC program.  To reserve, for example, 1K, type:\par
DECIMAL 1024 RESERVE.  This will allocate 1024 bytes for BASIC source code within\par
the dictionary.  If at some later stage you execute a second RESERVE the previous\par
1024 bytes are not reclaimed, so if you find you have not allocated enough space,\par
Save the BASIC source, FORGET all previous definitions, execute a COLD START, and\par
start the compilation from scratch. You can now do a second RESERVE.\par
\par
\par
\par
\par
\par
\par
79\page
To save BASIC source, type PROG <CR> to enter BASIC if you're not already there,\par
then just type SAVE "filename" as normal and re-enter White Lightning with PRINT\par
USR 24836.  Likewise, source can be reloaded by entering BASIC with a PROG, using\par
LOAD "filename" and then re-entering Forth with a PRINT USR 24836.\par
\par
\par
{\b Sprites}\par
\par
Sprites can be saved from White Lightning and then re-Loaded into White Lightning,\par
but sprites saved by White Lightning, cannot be loaded into the sprite development\par
software which requires the additional array information preceding sprites  which\par
is not SAVEd by White Lightning.  Sprite development should always be done using\par
the development software, but if you do wish to save the sprites for later merging\par
then do the following:\par
\par
1.  Find the start of sprites by typing SPST @ U.\par
\par
2.  Find the length to save by typing SPND @ SPST @ - 1+ U.\par
\par
3.  Note the start and length, then return to BASIC using PROG.\par
\par
4.  Save using SAVE "filename" CODE start, length.\par
\par
5.  Re-enter White Lightning using PRINT USR 24836.\par
\par
\par
{\b Merging Sprites}\par
\par
Two blocks of sprites can be merged together in the main program using the\par
following procedure:\par
\par
1.  Make a note of the SPST and SPND values of the second block to be\par
    merged. These are displayed by the sprite development software.\par
\par
2.  Load the main White Lightning package and then load the first block\par
    of sprites in response to the "LOAD SPRITES Y/N" prompt.\par
\par
3.  Load source as required and once in the main program relocate\par
    the first block of sprites downwards by the size of the second\par
    block.  Suppose the decimal values for SPST and SPND of the second\par
    block were 60000 and 65280 respectively, then type:\par
\par
    DECIMAL 60000 65280 - SPST @ + U. <CR>\par
\par
    (The DECIMAL is not required if you are already in DECIMAL mode).\par
    This will calculate the new start after relocation.  It is well worth\par
    checking that this will not run over your source code, so here is a\par
    quick calculation that will tell you if you have enough space.\par
    You need to know the highest screen number that you intend to use, for\par
    example screen 18.  Type:\par
\par
    18 512 * 49664 + U. <CR>\par
\par
    This will print the first free byte after screen 18.  So long as\par
    this result is lower than the new sprite start after relocation you\par
    can proceed.  Again, using the previous example where the block to be\par
    merged has SPST and SPND of 60000 and 65280 respectively, the line\par
    to type is:\par
\par
    DECIMAL 60000 65280 - MLEN ! RELOCATE <CR>\par
\par
\par
\par
\par
                                                                                80\page
    The relocate command uses the value held in MLEN as the relocation\par
    length, a negative value, as above, relocates downward and a positive\par
    value upward.\par
\par
4.  Before loading the second block of sprites, the values of the new\par
    SPST and SPND should be calculated and noted.  Type:\par
\par
    SPST @ U. SPND @ 65280 60000 - + DUP SPND ! U. <CR>\par
\par
    Take a note of these two values.  If the previous steps have been\par
    carried out correctly the second number (the new SPND) should be the\par
    same value as the old SPND before relocation.\par
\par
5.  Type: PROG <CR> to exit back to BASIC then type LOAD "" CODE.  The\par
    array of pointers will be ignored but the sprites will be loaded.\par
    This assumes that this second block of sprites was also saved using\par
    the sprite development software.\par
\par
6.  Type PRINT USR 24836 to re-enter Forth and your sprites should be\par
    merged.  Note that if a sprite number used in the second block has\par
    also been used in the first block, that only the first occurrence\par
    will be found.  If the first occurrence is destroyed using WIPE or\par
    DSPRITE, then the second occurrence will be found.\par
\par
\par
{\b Extending the Forth Itself}\par
\par
One of the beauties of the Forth language is that it is extendable, so if you've\par
added a few of your own commands which you would like to become a permanent\par
feature of your customised version, you will need to make a copy.  For this\par
reason, no attempt has been made to protect the software; but we do appeal to\par
users not to take advantage of this facility to pirate the program.  Piracy pushes\par
up the price of software to genuine users, so if you've bought a genuine copy, do\par
yourself a favour and keep the price of your future software affordable.  Copying\par
the manual, however, will result in immediate court action and a reward will be\par
paid to anyone offering information leading to the successful prosecution of\par
offenders.\par
\par
To save the Forth use the following procedure:\par
\par
1.  Type: WARM->COLD <CR> to embed the commands.\par
\par
2.  Type: HERE 24832 - 1+ U. <CR> to print the length to be Saved.\par
\par
3.  Type: PROG <CR> to enter BASIC.\par
\par
4.  Save using SAVE "FORTH" CODE 24832, length.\par
\par
5.  Re-enter using PRINT USR 24836.\par
\par
To use the amended version, LOAD White Lightning as normal, exit using PROG, LOAD\par
the new Forth over the old Forth and execute a Cold start using 24832.\par
\par
Oasis make no undertakings to support customised versions, and make no guarantee\par
as to the success of the operation.\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
81\page
{\b Compiled and Completed Programs}\par
\par
Once the program is fully debugged and running, a final run-time version can be\par
produced.  This is the only form in which programs generated from White Lightning\par
can be marketed.\par
\par
If the program makes use of the foreground/background facility, ZAPINT should be\par
typed, if not, then ZAP should be typed.  The length of the compiled program is\par
then displayed until a key is pressed and control returned to BASIC to make a\par
copy.\par
\par
The final program should be saved using:\par
\par
SAVE "filename" CODE 24832, length\par
\par
and executed using PRINT USR 24832.  Do not use RANDOMISE USR 24832.\par
\par
Remember that a lot of run-time software is saved with your final code, so even if\par
your program is only two lines long, the resulting program will be pretty large.\par
\par
\par
                             {\b TABLE 1}\par
                  {\b Table of Screen Numbers and Addresses}\par
\par
\par
Screen           Start\par
Number          Address\par
\par
   1             49664          Each screen used for editing\par
   2             50176          into consists of\par
   3             50688          8 lines x 64 characters\par
   4             51200                  = 512 bytes.\par
   5             51712\par
   6             52224\par
   7             52736          Therefore, if you have only\par
   8             53248          edited into screens 6-9,\par
   9             53760          then there is no need to save\par
  10             54272          ALL of the screens 1-22\par
  11             54784          since you only need save\par
  12             55296          from 52224 to 54271 (end of\par
  13             55808          screen 9), i.e. 2k bytes.\par
  14             56320\par
  15             56832\par
  16             57344\par
  17             57856\par
  18             58368\par
  19             58880\par
  20             59392\par
  21             59904\par
  22             60416\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
                                                                                82\page
{\b FUNCTION KEY SUMMARY}\par
\par
{\b KEY}\par
\par
{\b A}        Activates the ATIRIBUTE switch.\par
         Press 1 to set switch ON.\par
         Press 0 to set switch OFF.\par
\par
{\b B}        Activates the BRIGHT variable.\par
         Press 1 to set BRIGHT to ON.\par
         Press 0 to set BRIGHT to OFF.\par
\par
{\b C}        Activates the PAPER variable.\par
         Press any key between 0 and 7 to activate the colour indicated\par
         above the key.\par
\par
{\b D}        Activates DIRECT DATA INPUT\par
         Accepts 8 bytes of data, one byte at a time, followed by ENTER, via\par
         the keyboard, to the position on the sprite Screen indicated by\par
         the cursors.  Inputted data must be in the range 0 to 255 Decimal\par
         or, H00 to HFF HEX (the character H must precede Hex entry).\par
\par
         NOTE:  If Attribute switch = 1, then the four current attributes will\par
         be used at the same position as well.\par
\par
{\b E}        Activates the SCREEN FUNCTIONS.\par
         You will be given three options: press 1, 2 or 3.\par
\par
         1 INVERT\par
         Option 1, INVERT, sets all 0 bits to 1 and all 1 bits to 0,\par
         in a window whose length is held in the "Sprite length"\par
         variable and whose height is held in the "Sprite height"\par
         variable.  The inversion will take place from the positioning\par
         of the sprite screen cursors, i.e. at the intersection of an\par
         imaginary line drawn from each cursor.\par
\par
         2 MIRROR\par
         Option 2 MIRROR, 'Flips' a window whose height is held in the\par
         "Sprite height" variable and whose length is held in the "Sprite\par
         length" variable.  The Mirroring will take place about the\par
         vertical centre of the screen window.\par
\par
         3 MIRROR ATTRIBUTES\par
         Option 3 MIRROR ATTRIBUTES, 'Flips' the attributes in a window\par
         whose height is held in the "Sprite height" variable and whose\par
         length is held in the "Sprite length" variable.  The Mirroring of\par
         Attributes will take place about the vertical centre of the screen\par
         window\par
\par
{\b F}        Activates FLASH WINDOW.\par
         Flashes the current screen window whose height is held in the\par
         SPRITE HEIGHT variable and whose length is held in the SPRITE LENGTH\par
         variable.  The Flash will take place at the position of the sprite\par
         screen cursors.\par
\par
         Flash is used to check the position of the sprite screen cursors,\par
         to check that the height and length parameters are as required or\par
         to check that the window is correctly positioned.\par
\par
\par
\par
\par
\par
\par
83\page
{\b G}        Activates GET SPRITE function.\par
         Gets a sprite of the dimensions held in the "Sprite height" and\par
         "Sprite length" variables, using the number held in the "Sprite\par
         Number" variable and at the window indicated by the sprite screen\par
         cursor - and stores it in memory.\par
\par
         NOTE:  If the Attribute switch = 1, the sprite and attributes\par
         are stored; if the Attribute switch = 0, then any Attributes will\par
         be ignored. When a sprite is first defined with Attribute\par
         switch = 0 the attribute data will probably be garbage.\par
\par
{\b H}        Activates the SPRITE HEIGHT Variable.\par
         Permits the input of the height of a sprite window from 1-15.\par
\par
{\b I}        Activates the ATTRIBUTE DUMP function.\par
         Places the four Attributes set in the four Attribute Variables,\par
         to the sprite screen, at the position indicated by the sprite\par
         screen cursors - with a resolution of one character.\par
\par
         NOTE:  This function is independent of the Attribute Switch, e.g.\par
         to place Attributes at position x=4, y=4:  position sprite screen\par
         cursors at x=4 and y=4, then set the four attributes as required\par
         (you can then set the Attribute switch to 0 (OFF) if you like)\par
         and press I.\par
\par
{\b J}        Activates the move CHR$ SQR TO SPRITE SCREEN function.\par
         Dumps the bit pattern set in the CHR$ SQR to a character square\par
         in the sprite screen, indicated by the sprite screen cursors.\par
\par
         NOTE:  If the Attribute Switch = 0, no Attributes will move with\par
         the pattern.  If the Attribute switch = 1, then the Attributes\par
         held in the Attribute Variables will move with the pattern.\par
\par
{\b K}        Activates the MOVE SPRITE SCREEN CHARACTER TO CHR$ SQR\par
         function.\par
         Picks up the Character Square indicated by the Sprite Screen\par
         Cursors, into the CHR$ SQR.\par
\par
         NOTE:  ATTR = 0 ignores Character Attributes.  ATTR = 1 takes the\par
         Attributes of the character and loads them into the Attribute\par
         Variables.\par
\par
{\b L}        Activates the SPRITE LENGTH variable.\par
         Permits the input of the length of a Sprite Window from 1-15.\par
\par
{\b M}        Activates the Sprite Functions.\par
         You will be given three options which act in the same way as the\par
         'SCREEN FUNCTIONS E', except that these functions operate on\par
         the sprite in memory only and have no effect directly on the\par
         screen.\par
\par
{\b N}        Activates the No, negative response to (Y/N) questions.\par
\par
{\b O}        Activates the Sprite Logic functions.\par
         You will be given three options.  Each option GETS an area of the\par
         sprite screen, the dimensions of which are specified as those of\par
         the defined sprite, having a top left-hand corner at the sprite screen\par
         cursor positions and logically GETs the data into the defined sprite -\par
         whose number is in the Sprite Number Variable.\par
\par
\par
\par
\par
\par
                                                                                84\page
         NOTE:  ATTR = 0 leaves the attributes of the sprite as they are.\par
         ATTR = 1 takes the attributes from the screen and places them\par
         into the sprite.\par
\par
         1 GETORS, ORs the screen data with the pre-defined sprite, and\par
         leaves the result in the sprite (screen display unaffected).\par
\par
         2 GETXRS, XORs the screen data with the data of a pre-defined\par
         sprite, and leaves the result in the sprite, (screen\par
         display unaffected).\par
\par
         3 GETNDS, ANDs the screen data with the data of a pre-defined\par
         sprite, and leaves the result in the sprite (screen display\par
         unaffected).\par
\par
\par
{\b P}        Activates the PUT functions.\par
         You will be given four options.  Each option PUTS a sprite\par
         whose number is specified in the variable "Sprite Number" onto\par
         the sprite screen, having a top left-hand corner at the sprite\par
         screen cursor positions.\par
\par
         NOTE:  ATTR = 0 leaves the Screen Attributes unaffected.\par
         ATTR = 1 PUTs sprite Attributes to the sprite Screen.\par
\par
         1 PUTBLS is a straightforward PUT, placing data directly to\par
         the sprite screen, destroying anything that is on that part of\par
         the screen (Sprite unaffected).\par
\par
         2 PUTORS, ORs the sprite data with the data on the sprite screen,\par
         leaving the result on the screen (Sprite unaffected).\par
\par
         3 PUTXRS, XORs the sprite data with the data on the sprite screen,\par
         leaving the result on the screen (Sprite unaffected).\par
\par
         4 PUTNDS, ANDs the sprite data with the data on the sprite screen,\par
         leaving the result on the screen (Sprite unaffected).\par
\par
{\b Q}        Activates the CLEAR CHR$ SQR function.  Sets all CHR$ SQR bits\par
         to zero.\par
\par
{\b <=}       Activates the CLEAR SPRITE SCREEN function.  Clears the sprite\par
{\b (SYMBOL}   screen of all data and attributes.\par
{\b SHIFT Q)}\par
\par
\par
{\b R}        Activates the ROTATE SPRITE function.\par
         Rotates a sprite, in memory, by 90 degrees, leaving the original\par
         sprite unaffected.  The new Rotated sprite must be given a new\par
         sprite number, as asked for.  Attributes are automatically\par
         Rotated with the pixel data.\par
\par
{\b S}        Activates the SPRITE NUMBER variable.\par
         Permits the defining of sprites and asks for a sprite number in\par
         the range 1 to 255\par
\par
         NOTE:  If a sprite to be defined is given an existing sprite\par
         number, a warning is displayed, advising you of this fact.  The\par
         existing sprite, or the new sprite, are in no way corrupted.\par
\par
\par
\par
\par
\par
85\page
{\b T}        Activates the TEST SPRITE function.\par
         Performs a test on the sprite whose number is held in the "Sprite\par
         Number" variable, and does the following:\par
\par
         1.  Places the sprite height into the "Sprite height" variable.\par
         2.  Places the sprite length into the "Sprite length" variable.\par
         3.  Places the address in memory of where the sprite data starts,\par
             into the "Sprite" variable.\par
         4.  Places the address of the start of sprite space into the variable\par
             "SPST"\par
         5.  Places the address of the end of sprite space into the\par
             variable "SPND".\par
         6.  Calculates the remaining memory available for sprite\par
             storage and places it into the "Memory Left" variable.\par
\par
         NOTE:  The screen display of these variables will be updated\par
         if necessary.\par
\par
{\b U}        Activates the PICK UP ATTRIBUTES function.\par
         Picks up the attributes of the character from the sprite screen,\par
         indicated by the position of the sprite screen cursors and\par
         Loads them into the four Attribute variables.\par
\par
{\b V}        Activates the FLASH variable. This is one of the four attributes.\par
         Press 1 to put switch ON.\par
         Press 0 to put switch OFF.\par
\par
{\b W}        Activates the WIPE SPRITE function.\par
         Wipes the sprite indicated by the "Sprite number" variable\par
         totally from memory.  All other sprites stored in memory below\par
         that sprite are moved up to fill the space previously\par
         occupied by the Wiped sprite.\par
\par
{\b X}        Activate the INK variable which is one of the four attributes.\par
         Press any key between 0 and 7 to set the colour indicated\par
         above the key.\par
\par
{\b Y}        Activates the YES, positive response to (Y/N) questions.\par
\par
{\b Z}        Activates the pre-defined ARCADE CHARACTER function.\par
         Place a pre-defined Arcade Character to the sprite screen.\par
         The top left hand corner of the character is indicated by\par
         the sprite screen cursors.  Input a number between 1 and 167\par
         followed by ENTER.\par
\par
         NOTE:  Each character, with its number, can be seen on the Demo B\par
         tape.  A list is given at the back of this section.\par
\par
{\b NOT}      Activates the SAVE SPRITES TO TAPE facility.\par
{\b (SYMBOL}   Place a suitable cassette in your cassette recorder and\par
{\b SHIFT S)}  position as desired.  Press NOT, enter your filename (1 to 8\par
         characters).  The program will save three groups of data;\par
         an array and two sections of code.\par
         After SAVEing, you will be asked to rewind the tape and VERIFY -\par
         be sure to only press PLAY on your cassette recorder.\par
         If the programs VERIFY, the Sprite Development Program will\par
         return to command level with the Text Line cleared.\par
\par
         NOTE:  If the program breaks because of failure to VERIFY,\par
         type GOTO 3 and execute a WARM START; your data will not be lost.\par
\par
\par
\par
\par
                                                                                86\page
{\b -}        Activates the LOAD SPRITES FROM TAPE facility.\par
{\b (SYMBOL}  Place tape in your cassette recorder.  Press SYMBOL SHIFT J\par
{\b SHIFT J)} and press PLAY on the cassette recorder.  Three groups of data\par
         will load.  When loaded, the Text Line will clear and the\par
         program will resume.\par
\par
         NOTE:  Any sprites in memory will be destroyed when this command\par
         is executed.\par
\par
{\b 5}        Activates the MOVE CHR$ SQR CURSOR 1 place to the left - non-\par
         destructive.\par
\par
{\b 6}        Activates the MOVE CHR$ SQR CURSOR 1 place down - non-destructive.\par
\par
{\b 7}        Activates the MOVE CHR$ SQR CURSOR 1 place up - non-destructive.\par
\par
{\b 8}        Activates the MOVE CHR$ SQR CURSOR 1 place to the right -\par
         non-destructive.\par
\par
{\b 9}        Activates the SET CHR$ at current position.\par
\par
{\b 0}        Activates the CLEAR CHR$ SQR at current position.\par
\par
{\b %}        Activates the MOVE SPRITE SCREEN CURSOR 1 place to the left.\par
{\b (SYMBOL}\par
{\b SHIFT 5)}\par
\par
\par
{\b &}        Activates the MOVE SPRITE SCREEN CURSOR 1 place down.\par
{\b (SYMBOL}\par
{\b SHIFT 6)}\par
\par
\par
{\b '}        Activates the  MOVE SPRITE SCREEN CURSOR 1 place up.\par
{\b (SYMBOL}\par
{\b SHIFT 7)}\par
\par
\par
{\b (}        Activates the MOVE SPRITE SCREEN CURSOR 1 place to the right.\par
{\b (SYMBOL}\par
{\b SHIFT 8)}\par
\par
\par
{\b <}        Activates the RELOCATE SPRITES function.\par
{\b (SYMBOL}  Allows the user to move the sprite data about in memory,\par
{\b SHIFT R)}    between the top of the Sprite Generator Program and address\par
         65520.\par
\par
         e.g.  a positive number i.e. 50, moves the data 50 bytes up\par
         in memory.  A negative number i.e. -50, moves the data 50\par
         bytes down in memory.\par
         CAUTION - use this function with care.\par
\par
{\b BREAK}    Activates the PLACE SPRITE INTO SPRITE WINDOW function.\par
and      This allows you to place a sprite of smaller dimensions into\par
{\b SPACE}    a sprite of greater dimensions, at a position of ROW,\par
         COL in the greater sprite in memory - the smaller sprite is\par
         left unaltered.\par
\par
\par
\par
\par
\par
\par
87\page
         NOTE:  ATTR = 0, Attributes of smaller sprite ignored.\par
         ATTR = 1, Attributes of smaller sprite taken and placed with\par
         sprite.\par
         Three options given:\par
\par
         1 GETBLS\par
         GETs the smaller sprite directly into the window of the larger\par
         sprite.\par
\par
         2 GETORS\par
         GETs the smaller sprite and ORs it into the window of the\par
         larger sprite.\par
\par
         3 GETXRS\par
         GETs the smaller sprite and XORs it into the window of the\par
         larger sprite.\par
\par
         4 GETNDS\par
         GETs the smaller sprite and ANDs it into the window of the\par
         larger sprite.\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
                                                                                88\page
                           {\b THE WHITE LIGHTNING ARCADE}\par
                                {\b GRAPHICS LIBRARY}\par
\par
\par
     {\b ARCADE CHAR-}\par
     {\b ACTER NUMBER}\par
\par
         1-  8            Asteroids Space Ships\par
         9- 11            Asteroids\par
            12            Asteroids Flying Saucer\par
        13- 20            Pac-Men\par
        21- 22            Pac-Men Ghosts\par
        23- 25            Fruit\par
        26- 33            Pac-Men Maze Parts\par
        34- 44            Assault Course type games\par
        45- 54            Defender type games\par
        55- 62            Defender type landscapes\par
        63- 67            Space Invaders\par
        68- 70            Space Invaders Bases\par
        71- 74            Space Invaders Guns etc.\par
        75- 84            City Bomber type games\par
        85- 88            Lunar Lander type games\par
        89- 98            Frogger type games\par
        99-107            Centipede type games\par
       108-117            War type games\par
       118-130            Donkey Kong type games\par
       131-136            Space War type games\par
       137-141            Explosions\par
       142-148            Bug-Eyed Monsters\par
       149-152            Robots\par
       153-158            Adventure type games Treasure\par
       159-167            Zaps\par
\par
\par
\par
                         {\b WHITE LIGHTNING DEMONSTRATION}\par
                                {\b SPRITE LIBRARY}\par
\par
\par
{\b SPRITE}        {\b DESCRIPTION}       {\b INK}   {\b PAPER}   {\b LENGTH}  {\b HEIGHT}\par
{\b NUMBER}                          {\b COL}    {\b COL}\par
\par
  1     VINTAGE CAR               4     0        4       2\par
  2     VAN                       5     0        4       2\par
  3     DRAGSTER                  6     0        4       2\par
  4     DUCK                      6     0        3       3\par
  5     DANCER                    7     0        2       4\par
  6     ROCKET                    5     0        4       2\par
  7     SPIDER #1                 5     0        4       5\par
  8     SPIDER #2                 5     0        4       5\par
  9     TOP OF TRAIN              4     0       11       2\par
 10     RAILWAY TRACK             6     0        8       1\par
 11     SMALL WALL               1,5    7        4       1\par
 12     OASIS LOGO               5,7    0       12       4\par
 13     T.V.                      2     0       15      12\par
 14     TOP OF RAILWAY COACH      5     0       10       2\par
 15     SPACE SHIP                0     5        4       2\par
 16     SHADOW OF SPACE SHIP      5     7        4       1\par
\par
\par
\par
\par
\par
\par
89\page
 17     LARGE WALL               2,7    7        8       2\par
 18     TRAIN WHEELS #1          4,7    0       11       1\par
 19     TRAIN WHEELS #2          4,7    0       11       1\par
 20     TRAIN WHEELS #3          4,7    0       11       1\par
 21     TRAIN WHEELS #4          4,7    0       11       1\par
 22     RAILWAY COACH #1          7     0       10       1\par
 23     RAILWAY COACH #2          7     0       10       1\par
 24     INVADER 0 DEGREES         6     0        2       2\par
 25     INVADER 90 DEGREES        6     0        2       2\par
 26     INVADER 180 DEGREES       6     0        2       2\par
 27     INVADER 270 DEGREES       6     0        2       2\par
 28     FACE WITH HAT #1          4     0        4       3\par
 29     FACE WITH HAT #2          4     0        4       3\par
 30     'WHITE'                  5,7    0        7       2\par
 31     'LIGHTNING'              5,7    0       10       2\par
 32     LIGHTNING BOLT            5     0       13       4\par
 33     CRAB                     4,7    0        5       3\par
 34     LUNAR LANDER              7     0        6       4\par
 35     RADAR #1                  7     0        2       1\par
 36     RADAR #2                  7     0        2       1\par
 37     RADAR #3                  7     0        2       1\par
 38     RADAR #4                  7     0        2       1\par
 39     RADAR #5                  7     0        2       1\par
 40     RADAR #6                  7     0        2       1\par
 41     RADAR #7                  7     0        2       1\par
 42     RADAR #8                  7     0        2       1\par
 43     EXPLOSION                 7     0        2       2\par
 44     LUNAR SURFACE             6     0       15       1\par
 45     ROTATING BALL #1          6     0        4       4\par
 46     ROTATING BALL #2          6     0        4       4\par
 47     ROTATING BALL #3          6     0        4       4\par
 48     ROTATING BALL #4          6     0        4       4\par
 49     CLOCKWORK TOYS #1         4     0        3      12\par
 50     CLOCKWORK TOYS #2         4     0        3      12\par
 59     'TRY THIS'                4     0        8       1\par
 60     'WITHOUT'                 4     0        8       1\par
 61     'FROM'                    5     0        5       1\par
251     BOUNCING BALL #1          0     6        3       3\par
252     BOUNCING BALL #2          0     6        3       3\par
253     BOUNCING BALL #3          0     6        3       3\par
254     BOUNCING BALL #4          0     6        3       3\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
                                                                                90\page
{\b Fig-FORTH GLOSSARY}\par
\par
\par
This glossary contains all of the word definitions in Release 1 of fig-FORTH.  The\par
definitions are presented in the order of their ASCII sort and are reproduced\par
courtesy of the FORTH INTEREST GROUP, P.O. BOX 1105, SAN CARLOS, CA 94070.\par
\par
The first line of each entry shows a symbolic description of each action of the\par
procedure on the parameter stack.  The symbols indicate the order in which input\par
parameters have been placed on the stack.  Three dashes "---" indicate the\par
execution point; any parameters left on the stack are listed. In this notation,\par
the top of the stack is to the right.\par
\par
The symbols include:\par
\par
addr    memory address\par
b       8 bit byte (i.e. hi 8 bits zero)\par
c       7 bit ASCII character (hi 9 bits zero)\par
d       32 bit signed double integer, most significant portion with sign\par
        on top of stack.\par
f       boolean flag.  0 = false, non-zero = true.\par
ff      boolean false flag = 0\par
n       16 bit signed integer number\par
u       16 bit unsigned integer\par
tf      boolean true flag = non-zero\par
\par
The capital letters on the right show definition characteristics:\par
\par
C       May only be used within a colon definition.  A digit indicates\par
        number of memory addresses used, if other than one.\par
E       Intended for execution only.\par
L0      Level zero definition of FORTH-78\par
L1      Level 1 definition of FORTH-78\par
P       Has precedence bit set.  Will execute even when compiling.\par
U       A user variable.\par
\par
Unless otherwise noted, all references to numbers are for 16 bit signed integers.\par
The high byte of a number is on top of the stack, with the sign on the leftmost\par
bit.  For 32 bit signed double numbers, the most significant bit (with the sign)\par
is on top.\par
\par
All arithmetic is implicitly 16 bit signed integer math, with error and underflow\par
indication specified.\par
\par
NOTE:   All references to disc in this documentation can be read as references to\par
the disc simulation area in memory from C200H to F000H, which are treated as a\par
very limited disk capacity by White Lightning, and do not in any way change the\par
operation or description of any of the FORTH words defined in this documentation.\par
DO NOT use DR0, DR1 or GO.\par
\par
\par
{\b !}               n addr ---                                                       L0\par
\par
Store 16 bits of n at address.  Pronounced "store".\par
\par
\par
{\b !CSP}\par
\par
Save the stack position in CSP.  Used as part of the compiler security.\par
\par
\par
\par
\par
\par
91\page
{\b #}                   d1 --- d2                             L0\par
\par
Generate from a double number d1, the next ASCII character which is placed in an\par
output string.  Result d2 is the quotient after division by BASE, and is\par
maintained for further processing.  Used between <# and #>.  See #S.\par
\par
\par
{\b #>}                   d --- addr count                     L0\par
\par
Terminates numeric output conversion by dropping d, leaving the text address and\par
character count suitable for TYPE.\par
\par
\par
{\b #BUF}                   --- n\par
\par
A constant returning the number of disc buffers allocated.\par
\par
\par
{\b #S}                  d1 --- d2                             L0\par
\par
Generates ascii text in the text output buffer, by the use of #, until a zero\par
double number results.  Used between <# and #>.\par
\par
\par
{\b '}                      --- addr                         P,L0\par
\par
Used in the form:  ' nnnn\par
\par
Leaves the parameter field address of dictionary word nnnn.  As a compiler\par
directive, executes in colon definition to compile the address as a literal.  If\par
the word is not found after a search of CONTEXT and CURRENT, an appropriate error\par
message is given.  Pronounced "tick".\par
\par
\par
{\b (}                                                       P,L0\par
\par
Used in the form: ( cccc)\par
\par
Ignore a comment that will be delimited by a right parenthesis on the same line.\par
May occur during execution or in a colon-definition.  A blank after the leading\par
parenthesis is required.\par
\par
\par
{\b (.")}                                                      C+\par
\par
The run-time procedure, compiled by ." which transmits the following in-line text\par
to the selected output device.  See ."\par
\par
\par
{\b (;CODE)}                                                    C\par
\par
The run-time procedure, compiled by ;CODE, that re-writes the code field of the\par
most recently defined word to point to the following machine code sequence.  See\par
;CODE.\par
\par
\par
{\b (+LOOP)}              n ---                                C2\par
\par
The run-time procedure compiled by +LOOP, which increments the loop index by n and\par
tests for loop completion.  See +LOOP.\par
\par
\par
\par
\par
                                                                                92\page
{\b (ABORT)}\par
\par
Executes after an error when WARNING is -1.  This word normally executes ABORT,\par
but may be altered (with care) to a user's alternative procedure.  See WARNING.\par
\par
\par
{\b (DO)}                                                       C\par
\par
The run-time procedure compiled by DO which moves the loop control parameters to\par
the return stack.  See DO.\par
\par
\par
{\b (FIND)}     addr1 addr2 --- pfa b tf (ok)\par
           addr1 addr2 --- ff      (bad)\par
\par
Searches the dictionary starting at the name field address addr2, matching to the\par
text at addr1.  Returns parameter field address, length byte of name field and\par
boolean true for a good match.  If no match is found, only a boolean false is\par
left.\par
\par
\par
{\b (LINE)}           n1 n2 --- addr count\par
\par
Convert the line number n1 and the screen n2 to the disc buffer address containing\par
the data.  A count of 64 indicates the full line text length.\par
\par
\par
{\b (LOOP)}                                                    C2\par
\par
The run-time procedure compiled by LOOP which increments the loop index and tests\par
for loop completion.  See LOOP.\par
\par
\par
{\b (NUMBER)}      d1 addr1 --- d2 addr2\par
\par
Convert the ASCII text beginning at addr1 + 1 with regard to BASE.  The new value\par
is accumulated into double number d1, being left as d2.  Addr2 is the address of\par
the first unconvertible digit.  Used by NUMBER.\par
\par
\par
{\b *}                n1 n2 --- prod                           L0\par
\par
Leave the signed product of two signed numbers.\par
\par
\par
{\b */}            n1 n2 n3 --- n4                             L0\par
\par
Leave the ratio n4 = n1*n2/n3 where all are signed numbers.  Retention of an\par
intermediate 31 bit product permits greater accuracy than would be available with\par
the sequence n1 n2 * n3 /.\par
\par
\par
{\b */MOD}         n1 n2 n3 --- n4 n5                          L0\par
\par
Leave the quotient n5 and remainder n4 of the operation n1*n2/n3.  A 31 bit\par
intermediate product is used as for */.\par
\par
\par
{\b +}                n1 n2 --- sum                            L0\par
\par
Leave the sum of n1+n2.\par
\par
\par
\par
93\page
{\b +!}              n addr ---                                L0\par
\par
Add n to the value at the address.  Pronounced "plus-store".\par
\par
\par
{\b +-}               n1 n2 --- n3\par
\par
Apply the sign of n2 to n1, which is left as n3.\par
\par
\par
{\b +BUF}              add1 --- addr2 f\par
\par
Advance the disc buffer address addr1 to the address of the next buffer addr2.\par
Boolean f is false when addr2 is the buffer presently pointed to by variable\par
PREV.\par
\par
\par
{\b +LOOP}               n1 --- (run)\par
               addr n2 --- (compile)                 P,C2,L0\par
\par
Used in a colon-definition in the form:\par
                DO  ...  n1  +LOOP\par
At run-time, +LOOP selectively controls branching back to the corresponding DO\par
based on n1, the loop index and the loop limit.  The signed increment n1 is added\par
to the index and the total compared to the limit.  The branch back to DO occurs\par
until the new index is equal to or greater than the limit (n1>0), or until the new\par
index is equal to or less than the limit (n1<0).  Upon exiting the loop, the\par
parameters are discarded and the execution continues ahead.\par
\par
At compile time, +LOOP compiles the run-time word (+LOOP) and the branch offset\par
computed from HERE to the address left on the stack by DO.  n2 is used for compile\par
time error checking.\par
\par
\par
{\b +ORIGIN}              n --- addr\par
\par
Leave the memory address relative by n to the origin parameter area.  n is the\par
minimum address unit, either byte or word.  This definition is used to access or\par
modify the boot-up parameters at the origin area.\par
\par
\par
{\b ,}                    n --- ,                              L0\par
\par
Store n into the next available dictionary memory cell, advancing the dictionary\par
pointer.  (comma)\par
\par
\par
{\b -}                n1 n2 --- diff                           L0\par
\par
Leave the difference of n1-n2.\par
\par
\par
{\b -->}                                                     P,L0\par
\par
Continue interpretation with the next screen.  (Pronounced next-screen).\par
\par
\par
{\b -DUP}                n1 --- n1     (if zero)\par
                    n1 --- n1 n1  (non-zero)              L0\par
\par
Reproduce n1 only if it is non-zero.  This is usually used to copy a value just\par
before IF, to eliminate the need for an ELSE part to drop it.\par
\par
\par
                                                                                94\page
{\b -FIND}                  --- pfa b tf  (found)\par
                       --- ff        (not found)\par
\par
Accepts the next text word (delimited by blanks) in the input stream to HERE, then\par
searches the CONTEXT and then CURRENT vocabularies for a matching entry.  If\par
found, the dictionary entry's parameter field address, its length byte, and a\par
boolean true is left.  Otherwise, only a boolean false is left.\par
\par
\par
{\b -TRAILING}      addr n1 --- addr n2\par
\par
Adjusts the character count n1 of a text string beginning address to suppress the\par
output of trailing blanks.  i.e. the characters at addr+n1 to addr+n2 are blanks.\par
\par
\par
{\b .}                    n ---                                L0\par
\par
Print a number from a signed l6 bit two's complement value, converted according to\par
the numeric BASE.  A trailing blanks follows.  Pronounced "dot".\par
\par
\par
{\b ."}                                                      P,L0\par
\par
Used in the form:  ." cccc "\par
\par
Compiles an in-line string cccc (delimited by the trailing "), with an execution\par
procedure to transmit the text to the selected output device.  If executed outside\par
a definition, ." will immediately print the text until the final ".  See (.").\par
\par
\par
{\b .LINE}         line scr ---\par
\par
Print on the terminal device, a line of text by its line and screen number.\par
Trailing blanks are suppressed.\par
\par
\par
{\b .R}               n1 n2 ---\par
\par
Print the number n1 right aligned in a field whose width is n2.  No following\par
blanks printed.\par
\par
\par
{\b /}                n1 n2 --- quot                           L0\par
\par
Leave the signed quotient of n1/n2.\par
\par
\par
{\b /MOD}             n1 n2 --- rem quot                       L0\par
\par
Leave the remainder and signed quotient of n1/n2.  The remainder has the sign of\par
the dividend.\par
\par
\par
{\b 0 1 2 3}                --- n\par
\par
These small numbers are used so often, that it is attractive to define them by\par
name in the dictionary as constants.\par
\par
\par
\par
\par
\par
\par
\par
95\page
{\b 0<}                   n --- f                              L0\par
\par
Leave a true flag if the number is less than zero (negative), otherwise leave a\par
false flag.\par
\par
\par
{\b 0=}                   n --- f                              L0\par
\par
Leave a true flag is the number is equal to zero, otherwise leave a false flag.\par
\par
\par
{\b 0BRANCH}              f ---                                C2\par
\par
The run-time procedure to conditionally branch.  If f is false (zero), the\par
following in-line parameter is added to the interpretive pointer to branch ahead\par
or back.  Compiled by IF, UNTIL, and WHILE.\par
\par
\par
{\b 1+}                  n1 --- n2                             L1\par
\par
Increment n1 by l.\par
\par
\par
{\b 2+}                  n1 --- n2                             L1\par
\par
Leave n1 incremented by 2.\par
\par
\par
{\b 2!}     nlow nhigh addr ---\par
\par
32 bit store, nhigh is stored at addr; nlow is stored at addr+2.\par
\par
\par
{\b 2@}                addr --- nlow nhigh\par
\par
32 bit fetch, nhigh is fetched from addr; nlow is fetched from addr-2.\par
\par
\par
{\b 2DUP}             n2 n1 --- n2 n1 n2 n1\par
\par
Duplicates the top two values on the stack.  Equivalent to OVER OVER.\par
\par
\par
{\b :}                                                     P,E,L0\par
\par
Used in the form called a colon-definition:\par
               : cccc  ...  ;\par
Creates a dictionary entry defining cccc as equivalent to the following sequence\par
of Forth word definitions '...' until the next ';' or ';CODE'.  The compiling\par
process is done by the text interpreter as long as STATE is non-zero.  Other\par
details are that the CONTEXT vocabulary is set to the CURRENT vocabulary and that\par
words with the precedence bit set (P) are executed rather than being compiled.\par
\par
\par
{\b ;}                                                     P,C,L0\par
\par
Terminate a colon-definition and stop further compilation.  Compiles the run-time\par
;S.\par
\par
\par
\par
\par
\par
\par
                                                                                96\page
{\b ;CODE}                                                 P,C,L0\par
\par
Used in the form:\par
               : cccc  ....  ;CODE\par
               assembly mnemonics\par
Stop compilation and terminate a new defining word cccc by compiling (;CODE).  Set\par
the CONTEXT vocabulary to ASSEMBLER, assembling to machine code the following\par
mnemonics.  This facility is included for those users who may wish to write a Z80\par
Assembler in FORTH.\par
\par
When cccc later executes in the form:\par
                  cccc   nnnn\par
the word nnnn will be created with its execution procedure given by the machine\par
code following cccc.  That is, when nnnn is executed, it does so by jumping to the\par
code after nnnn.  An existing defining word must exist in cccc prior to ;CODE.\par
\par
\par
{\b ;S}                                                      P,L0\par
\par
Stop interpretation of a screen.  ;S is also the run-time word compiled at the end\par
of a colon-definition, which returns execution to the calling procedure.\par
\par
\par
{\b <}                n1 n2 --- f                              L0\par
\par
Leave a true flag if n1 is less than n2; otherwise leave a false flag.\par
\par
\par
{\b <#}                                                        L0\par
\par
Setup for pictured numeric output formatting using the words:\par
               <#  #  #S  SIGN  #>\par
The conversion is done on a double number producing text at PAD.\par
\par
\par
{\b <BUILDS}                                                 C,L0\par
\par
Used within a colon-definition:\par
             :  cccc  <BUILDS  ...\par
                      DOES>    ...  ;\par
Each time cccc is executed, <BUILDS defines a new word with a high-level execution\par
procedure.  Executing cccc in the form:\par
                cccc  nnnn\par
uses <BUILDS to create a dictionary entry for nnnn with a call to the DOES> part\par
for nnnn.  When nnnn is later executed, it has the address of its parameter area\par
on the stack and executes the words after DOES> in cccc.  <BUILDS and DOES> allow\par
run-time procedures to written in high-level, rather than in assembler code (as\par
required by ;CODE).\par
\par
\par
{\b =}                n1 n2 --- f                              L0\par
\par
Leave a true flag if n1=n2 otherwise leave a false flag.\par
\par
\par
{\b >}                n1 n2 --- f                              L0\par
\par
Leave a true flag if n1 is greater than n2 otherwise a false flag.\par
\par
\par
\par
\par
\par
\par
97\page
{\b >R}                   n ---                              C,L0\par
\par
Remove a number from the computation stack and place as the most accessible on the\par
return stack.  Use should be balanced with R> in the same definition.\par
\par
\par
{\b ?}                 addr ---                                L0\par
\par
Print the value contained at the address in free format according to the current\par
base.\par
\par
\par
{\b ?COMP}\par
\par
Issue error message if not compiling.\par
\par
\par
{\b ?CSP}\par
\par
Issue error message if stack position differs from value saved in CSP.\par
\par
\par
{\b ERROR}              f n ---\par
\par
Issue an error message number n, if the boolean flag is true.\par
\par
\par
{\b ?EXEC}\par
\par
Issue an error message if not executing.\par
\par
\par
{\b ?LOADING}\par
\par
Issue an error message if not loading\par
\par
\par
{\b ?PAIRS}           n1 n2 ---\par
\par
Issue an error message if n1 does not equal n2.  The message indicates that\par
compiled conditionals do not match.\par
\par
\par
{\b ?STACK}\par
\par
Issue an error message is the stack is out of bounds.\par
\par
\par
{\b ?TERMINAL}              --- f\par
\par
Perform a test of the terminal keyboard for actuation of the break key.  A true\par
flag indicates actuation.\par
\par
\par
{\b @}                 addr --- n                              L0\par
\par
Leave the 16 bit contents of address.\par
\par
\par
\par
\par
\par
\par
\par
                                                                                98\page
{\b ABORT}                                                     L0\par
\par
Clear the stacks and enter the execution state.  Return control to the operator's\par
terminal, printing a message appropriate to the installation.\par
\par
\par
{\b ABS}                  n --- u                              L0\par
\par
Leave the absolute value of n as u.\par
\par
\par
{\b AGAIN}           addr n --- (compiling)               P,C2,L0\par
\par
Used in a colon-definition in the form:\par
                BEGIN  ...  AGAIN\par
At run-time, AGAIN forces execution to return to corresponding BEGIN.  There is no\par
effect on the stack.  Execution cannot leave this loop (unless R> is executed one\par
level below).\par
\par
At compile time, AGAIN compiles BRANCH with an offset from HERE to addr.  n is\par
used for compile-time error checking.\par
\par
\par
{\b ALLOT}                n ---                                L0\par
\par
Add the signed number to the dictionary pointer DP.  May be used to reserve\par
dictionary space or re-origin memory.  n is with regard to computer address type\par
(byte or word).\par
\par
\par
{\b AND}              n1 n2 --- n2                             L0\par
\par
Leave the bitwise logical "AND" of n1 and n2 as n3.\par
\par
\par
{\b B/BUF}                  --- n\par
\par
This constant leaves the number of bytes per disc buffer, the byte count read from\par
disc by BLOCK.\par
\par
\par
{\b B/SCR}                  --- n\par
\par
This component leaves the number of blocks per editing screen.  By convention, an\par
editing screen is 512 bytes, organised as 8 lines of 64 characters each.\par
\par
\par
{\b BACK}              addr ---\par
\par
Calculate the backward branch offset from HERE to addr and compile into the next\par
available dictionary memory address.\par
\par
\par
{\b BASE}                   --- addr\par
\par
A user variable containing the current number base used for input and output\par
conversion.\par
\par
\par
\par
\par
\par
\par
\par
99\page
{\b BEGIN}                  --- addr n (compilation)         P,L0\par
\par
Occurs in a colon-definition in form:\par
              BEGIN  ...  UNTIL\par
              BEGIN  ...  AGAIN\par
              BEGIN  ...  WHILE  ...  REPEAT\par
At run-time, BEGIN marks the start of a sequence that may be repetitively\par
executed.  It serves as a return point from the corresponding UNTIL, AGAIN or\par
REPEAT.  When executing UNTIL, a return to BEGIN will occur if the top of the\par
stack is false; for AGAIN and REPEAT, a return to BEGIN always occurs.\par
\par
At compile time BEGIN leaves its return address and n for compiler error checking.\par
\par
\par
{\b BL}                     --- c\par
\par
A constant that leaves the ASCII value for blank.\par
\par
\par
{\b BLANKS}      addr count ---\par
\par
Fill in an area of memory beginning at addr with blanks.\par
\par
\par
{\b BLK}                    --- addr                           L0\par
\par
A user variable containing the block number being interpreted.  If zero, input is\par
being taken from the terminal input buffer.\par
\par
\par
{\b BLOCK}                n --- addr                           L0\par
\par
Leave the memory address of the block buffer containing block n.  If the block is\par
not already in memory, it is transferred from disc to whichever buffer was least\par
recently written.  If the block occupying that buffer has been marked as updated,\par
it is re-written to disc before block n is read into the buffer. See also BUFFER,\par
R/W UPDATE FLUSH.\par
\par
\par
{\b BRANCH}                                                 C2,L0\par
\par
The run-time procedure to unconditionally branch.  An in-line offset is added to\par
the interpretive pointer IP to branch ahead or back.  BRANCH is compiled by ELSE,\par
AGAIN, REPEAT.\par
\par
\par
{\b BUFFER}               n --- addr\par
\par
Obtain the next memory buffer, assigning it to block n.  If the contents of the\par
buffer are marked up as updated, it is written to the disc.  The block is not read\par
from the disc.  The address left is the first cell within the buffer for data\par
storage.\par
\par
\par
{\b C!}              b addr ---\par
\par
Store 8 bits at address.\par
\par
\par
\par
\par
\par
\par
\par
                                                                               100\page
{\b C,}                   b ---\par
\par
Store 8 bits of b into the next available dictionary byte, advancing the\par
dictionary pointer.\par
\par
\par
{\b C@}                addr --- b\par
\par
Leave the 8 bit contents of memory address.\par
\par
\par
{\b CASE}                   --- n (compiling)\par
\par
Occurs in a colon definition in the form:\par
            CASE\par
            n OP ..... ENDOF\par
            .....\par
            ENDCASE\par
At run-time, CASE marks the start of a sequence of OF ... ENDOF statements.\par
\par
At compile time CASE leaves n for compiler error checking.\par
\par
\par
{\b CFA}                pfa --- cfa\par
\par
Convert the parameter field address of a definition to its code field address.\par
\par
\par
{\b CMOVE}    from to count ---\par
\par
Move the specified quantity of bytes beginning at address 'from' to address 'to'.\par
The contents of address 'from' are moved first proceeding toward high memory.\par
\par
\par
{\b COLD}\par
\par
The cold start procedure to adjust the dictionary pointer to the minimum standard\par
and restart via ABORT.  May be called from the terminal to remove application\par
programs and restart.\par
\par
\par
{\b COMPILE}                                                   C2\par
\par
When the word containing COMPILE executes, the execution address of the word\par
following COMPILE is copied (compiled) into the dictionary.  This allows specific\par
compilation situations to be handled in addition to simply compiling an execution\par
address (which the interpreter already does).\par
\par
\par
{\b CONSTANT}             n ---                                L0\par
\par
A defining word used in the form:\par
              n  CONSTANT  cccc\par
to create word cccc, with its parameter field containing n.  When cccc is later\par
executed, it will push the value of n to the stack.\par
\par
\par
{\b CONTEXT}                --- addr                         U,L0\par
\par
A user variable containing a pointer to the vocabulary within which dictionary\par
searches will first begin.\par
\par
\par
\par
101\page
{\b COUNT}            addr1 --- addr2 n                        L0\par
\par
Leave the byte address addr2 and byte count n of a message text beginning at\par
address addr1.  It is presumed that the first byte at addr1 contains the text byte\par
count and that the actual text starts with the second byte.  Typically, COUNT is\par
followed by TYPE.\par
\par
\par
{\b CR}                                                        L0\par
\par
Transmit a carriage return and line feed to the selected output device.\par
\par
\par
{\b CREATE}\par
\par
A defining word used in the form:\par
               CREATE cccc\par
by such words as CODE and CONSTANT to create a dictionary header for a Forth\par
definition.  The code field contains the address of the word's parameter field.  A\par
new word is created in the CURRENT vocabulary.\par
\par
\par
{\b CSP}                    --- addr                            U\par
\par
A user variable temporarily storing the stack pointer position, for compilation\par
error checking.\par
\par
\par
{\b D+}               d1 d2 --- dsum\par
\par
Leave the double number sum of two double numbers.\par
\par
\par
{\b D+-}               d1 n --- d2\par
\par
Apply the sign of n to the double number d1, leaving it as d2.\par
\par
\par
{\b D.}                   d ---                                L1\par
\par
Print a signed double number from a 32 bit two's complement value.  The high-order\par
l6 bits are most accessible on the stack.  Conversion is performed according to\par
the current base.  A blank follows.  Pronounced D-dot.\par
\par
\par
{\b D.R}                d n ---                                L0\par
\par
Print a signed double number d right aligned in a field n characters wide.\par
\par
\par
{\b DABS}                 d --- ud\par
\par
Leave the absolute value of a double number.\par
\par
\par
{\b DECIMAL}                                                   L0\par
\par
Set the numeric conversion BASE for decimal input-output.\par
\par
\par
\par
\par
\par
\par
                                                                               102\page
{\b DEFINITIONS}                                               L1\par
\par
Used in the form:\par
              cccc DEFINITIONS\par
Set the CURRENT vocabulary to the CONTEXT vocabulary.  In the example, executing\par
vocabulary name cccc made it in the CONTEXT vocabulary, and executing DEFINITIONS\par
made both specify vocabulary cccc.\par
\par
\par
{\b DIGIT}             c n1 --- n2 tf  (ok)\par
                  c n1 --- ff     (bad)\par
\par
Converts the ASCII characters c (using base n1) to its binary equivalent n2,\par
accompanied by a true flag.  If the conversion is invalid, leaves only a false\par
flag.\par
\par
\par
{\b DLITERAL}             d --- d  (executing)\par
                     d ---    (compiling)                  P\par
\par
If compiling, compile a stack double number into a literal.  Later execution of\par
the definition containing the literal will push it to the stack.  If executing,\par
the number will remain on the stack.\par
\par
\par
{\b DMINUS}              d1 --- d2\par
\par
Convert d1 to its double number two's complement.\par
\par
\par
{\b DO}               n1 n2 --- (execute)\par
                addr n --- (compile)                 P,C2,L0\par
\par
Occurs in a colon-definition in form:\par
              DO  ...  LOOP\par
              DO  ... +LOOP\par
At run time, DO begins a sequence with repetitive execution controlled by a loop\par
limit n1 and an index with initial value n2.  DO removes these from the stack.\par
Upon reaching LOOP the index is incremented by one.  Until the new index equals or\par
exceeds the limit, execution loops back to just after DO otherwise the loop\par
parameters are discarded and execution continues ahead.  Both n1 and n2 are\par
determined at run-time and may be the result of other operations.  Within a loop,\par
'I' will copy the current value of the index to the stack.  See I, LOOP, +LOOP,\par
LEAVE.\par
\par
When compiling within the colon definition, DO compiles (DO), leaving the\par
following address addr and n for later error checking.\par
\par
\par
{\b DOES>}                                                     L0\par
\par
A word which defines the run-time action within a high-level defining word.  DOES>\par
alters the code field and first parameter of the new word, to execute the sequence\par
of compiled word addresses following DOES>.  Used in combination with <BUILDS.\par
When the word DOES> part executes, it begins with the address of the first\par
parameter of the new word on the stack.  This allows interpretation using this\par
area or its contents.  Typical uses include the Forth assembler, multi-dimensional\par
arrays and compiler generation.\par
\par
\par
\par
\par
\par
\par
103\page
{\b DP}                     --- addr                          U,L\par
\par
A user variable, the dictionary pointer, which contains the address of the next\par
free memory above the dictionary.  The value may be read by HERE and altered by\par
ALLOT.\par
\par
\par
{\b DPL}                    --- addr                         U,L0\par
\par
A user variable containing the number of digits to the right of the decimal on\par
double integer input.  It may also be used to hold output column location of a\par
decimal point, in user generated formatting.  The default value on single number\par
input is -1.\par
\par
\par
{\b DROP}                 n ---                                L0\par
\par
Drop the number from the stack.\par
\par
\par
{\b DUMP}              addr ---                                L0\par
\par
Print the contents of n memory locations beginning at addr.  Both addresses and\par
contents are shown in the current numeric base.\par
\par
\par
{\b DUP}                  n --- n n                            L0\par
\par
Duplicate the value on the stack.\par
\par
\par
{\b ELSE}          addr1 n1 --- addr2 n2\par
                    (compiling)                      P,C2,L0\par
\par
Occurs within a colon-definition within the form:\par
              IF  ...  ELSE  ...  ENDIF\par
At run-time, ELSE executes after the true part following IF.  ELSE forces the\par
execution to skip over the following false part, and resumes execution after the\par
ENDIF.  It has no stack effect.\par
\par
A compile time ELSE emplaces branch reserving a branch offset, leaves the address\par
addr2 and n2 for error treating.  ELSE also resolves the pending forward branch\par
from IF by calculating the offset from addr1 to HERE and storing at addr1.\par
\par
\par
{\b EMIT}                 c ---                                L0\par
\par
Transmit ASCII character c to the selected output device.  OUT is incremented for\par
each character output.\par
\par
\par
{\b EMPTY-BUFFERS}                                             L0\par
\par
Mark all block-buffers as empty, not necessarily affecting the contents.  Updated\par
blocks are not written to the disc.  This is also an initialization procedure\par
before first use of the disc.\par
\par
\par
\par
\par
\par
\par
\par
\par
                                                                               104\page
{\b ENCLOSE}        addr1 c --- addr1 n1 n2 n3\par
\par
The text scanning primitive used by WORD.  From the text address addr1 and an\par
ASCII delimiting character c, is determined the byte offset to the first\par
non-delimiter character n1, the offset to the first delimiter after the text n2,\par
and the offset to the first character not included.  This procedure will not\par
process past an ASCII 'null', treating it as an unconditional delimiter.\par
\par
\par
{\b END}                                                  P,C2,L0\par
\par
This is an 'alias' or duplicate definition for UNTIL.\par
\par
\par
{\b ENDCASE}         addr n --- (compile)\par
\par
Occurs in a colon definition in the form:\par
          CASE\par
          n OF ..... ENDOF\par
          .....\par
          ENDCASE\par
At run-time ENDCASE marks the conclusion of a CASE statement.\par
\par
At compile time ENDCASE computes forward branch offsets.\par
\par
\par
{\b ENDIF}           addr n --- (compile)                 P,C0,L0\par
\par
At run-time, ENDIF serves only as the destination of a forward branch from IF or\par
ELSE.  It marks the conclusion of the conditional structure.  THEN is another name\par
for ENDIF.  Both names are supported in Fig-FORTH.  See also IF and ELSE.\par
\par
At compile time, ENDIF computes the forward branch offset from addr to HERE and\par
stores it at addr.  n is used for error tests.\par
\par
\par
{\b ENDOF}           addr n --- (compile)\par
\par
Used as ENDIF but in CASE statements.\par
\par
\par
{\b ERASE}           addr n ---\par
\par
Clear a region of memory to zero from addr over n addresses.\par
\par
\par
{\b ERROR}             line --- in blk\par
\par
Execute error notification and restart of system.  WARNING is first examined.  If\par
1, the text of line n, relative to screen 4 of drive 0 is printed.  This line\par
number may be positive or negative, and beyond just screen 4.  If WARNING=0, n is\par
just printed as a message number (non disc installation).  If warning is -l, the\par
definition ABORT is executed, which executes the system ABORT.  The user may\par
cautiously modify this by altering (ABORT).  Fig-FORTH saves the contents of IN\par
and BLK to assist in determining the location of the error.  Final action is\par
execution of QUIT.\par
\par
\par
\par
\par
\par
\par
\par
\par
105\page
{\b EXECUTE}           addr ---\par
\par
Execute the definition whose code field address is on the stack.  The code field\par
address is also called the compilation address.\par
\par
\par
{\b EXPECT}      addr count ---                                L0\par
\par
Transfer characters from the terminal to address, until a return or the count of\par
characters has been received.  One or more nulls are added at the end of the\par
text.\par
\par
\par
{\b FENCE}                  --- addr                            U\par
\par
A user variable containing an address below which FORGETting is trapped.  To\par
forget below this point the user must alter the contents of FENCE.\par
\par
\par
{\b FILL}       addr quan b ---\par
\par
Fill memory at the address with the specified quantity of bytes b.\par
\par
\par
{\b FIRST}                  --- n\par
\par
A constant that leaves the address of the first (lowest) block buffer.\par
\par
\par
{\b FLD}                    --- addr                            U\par
\par
A user variable for control of number output field width.  Presently unused in\par
Fig-FORTH.\par
\par
\par
{\b FORGET}                                                  E,L0\par
\par
Deletes definition named cccc from the dictionary with all entries physically\par
following it.  In Fig-FORTH, an error message will occur if the CURRENT and\par
CONTEXT vocabularies are not currently the same.\par
\par
\par
{\b FORTH}                                                   P,L1\par
\par
The name of the primary vocabulary.  Execution makes FORTH the CONTEXT vocabulary.\par
Until additional user vocabularies are defined, new user definitions become a part\par
of FORTH.  FORTH is immediate, so it will execute during the creation of a\par
colon-definition, to select this vocabulary at compile time.\par
\par
\par
{\b HERE}                   --- addr                           L0\par
\par
Leave the address of the next available dictionary location.\par
\par
\par
{\b HEX}                                                       L0\par
\par
Set the numeric conversion base to sixteen (hexadecimal).\par
\par
\par
\par
\par
\par
\par
                                                                               106\page
{\b HLD}                    --- addr                           L0\par
\par
A user variable that holds the address of the latest character of text during\par
numeric output conversion.\par
\par
\par
{\b HOLD}                 c ---                                L0\par
\par
Used between <# and #> to insert an ASCII character into a pictured numeric output\par
string.\par
\par
e.g.  2E HOLD will place a decimal point.\par
\par
\par
{\b I}                      --- n                            C,L0\par
\par
Used within a DO-LOOP to copy the loop index to the stack.  Other use is\par
implementation dependent.  See R.\par
\par
\par
{\b ID.}               addr ---\par
\par
Print a definition's name from its name field address.\par
\par
\par
{\b IF}                   f ---          (run-time)\par
                       --- addr n   (compile)        P,C2,L0\par
\par
Occurs in a colon-definition in the form:\par
              IF  (tp)  ...  ENDIF\par
              IF  (tp)  ...  ELSE  (fp)  ...  ENDIF\par
At run-time, IF selects execution based on a boolean flag.  If f is a true\par
(non-zero), execution continues ahead through the true part.  If f is false\par
(zero), execution skips till just after ELSE to execute the false part.  After\par
either part, execution resumes after ENDIF.  ELSE and its false part are optional;\par
if missing, false execution skips to just after ENDIF.\par
\par
At compile time, IF compiles 0BRANCH and reserves space for an offset at addr.\par
addr and n are used later for resolution of the offset and error testing.\par
\par
\par
{\b IMMEDIATE}\par
\par
Mark the most recently made definition so that when encountered at compile time it\par
will be executed rather than compiled, i.e.  the precedence bit in its header is\par
set.  This method allows definitions to handle unusual compiling situations,\par
rather than build them into the fundamental compiler.  The user may force\par
compilation of an immediate definition by preceding it with [COMPILE].\par
\par
\par
{\b IN}                     --- addr                           L0\par
\par
A user variable containing the byte offset within the current input text buffer\par
(terminal or disc) from which the next text will be accepted.  WORD uses and moves\par
the value of IN.\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
107\page
{\b INDEX}          from to ---\par
\par
Print the first line of each screen over the range from, to.  This is used to view\par
the comment lines of an area of text on disc screens.\par
\par
\par
{\b INTERPRET}\par
\par
The outer text interpreter which sequentially executes or compiles text from the\par
input stream (terminal or disc) depending on STATE.  If the word name cannot be\par
found after a search of CONTEXT and then CURRENT, it is converted to a number\par
according to the current base.  That also failing, an error message echoing the\par
name with a "?" will be given.  Text input will be taken according to the\par
convention for WORD.  If a decimal point is found as part of a number, a double\par
number value will be left.  The decimal point has no other purpose than to force\par
this action.  See NUMBER.\par
\par
\par
{\b KEY}                    --- c                              L0\par
\par
Leave the ASCII value of the next terminal key struck.\par
\par
\par
{\b LATEST}                 --- addr\par
\par
Leave the name field address of the topmost word in the CURRENT vocabulary.\par
\par
\par
{\b LEAVE}                                                   C,L0\par
\par
Force termination of a DO-LOOP at the next opportunity by setting the loop limit\par
equal to the current value of the index.  The index itself remains unchanged, and\par
execution proceeds normally until LOOP or +LOOP is encountered.\par
\par
\par
{\b LFA}                pfa --- lfa\par
\par
Convert the parameter field address of a dictionary definition to its link field\par
address.\par
\par
\par
{\b LIMIT}                  --- n\par
\par
A constant leaving the address just above the highest memory available for a disc\par
buffer.  Usually this is the highest system memory.\par
\par
\par
{\b LINE}                 n --- addr\par
\par
Leave address of line n of current screen.  This address will be in the disc\par
buffer area\par
\par
\par
{\b LIST}                 n ---                                L0\par
\par
Display the ASCII text of screen n on the selected output device.  SCR contains\par
the screen number during and after this process.\par
\par
\par
\par
\par
\par
\par
\par
                                                                               108\page
{\b LIT}                    --- n                            C,L0\par
\par
Within a colon-definition, LIT is automatically compiled before each 16 bit\par
literal number encountered in input text.  Later execution of LIT causes the\par
contents of the next dictionary address to be pushed to the stack.\par
\par
\par
{\b LITERAL}              n --- (compiling)               P,C2,L0\par
\par
If compiling, then compile the stack value n as a 16 bit literal.  This definition\par
is immediate so that it will execute during a colon definition.  The intended use\par
is:\par
              :  xxx   (calculate) LITERAL  ;\par
Compilation is suspended for the compile time calculation of a value.  Compilation\par
is resumed and LITERAL compiles this value.\par
\par
\par
{\b LOAD}                 n ---                                L0\par
\par
Begin interpretation of screen n.  Loading will terminate at the end of the screen\par
or at ;S.  See ;S and -->.\par
\par
\par
{\b LOOP}            addr n --- (compiling)               P,C2,L0\par
\par
Occurs in a colon-definition in form:\par
              DO  ...  LOOP\par
At run-time, LOOP selectively controls branching back to the corresponding DO\par
based on the loop index and limit.  The loop index is incremented by one and\par
compared to the limit.  The branch back to DO occurs until the index equals or\par
exceeds the limit; at that time, the parameters are discarded and execution\par
continues ahead.\par
\par
At compile-time.  LOOP compiles (LOOP) and uses addr to calculate an offset to DO.\par
n is used for error testing.\par
\par
\par
{\b M*}               n1 n2 --- d\par
\par
A mixed magnitude math operation which leaves the double number signed product of\par
two signed numbers.\par
\par
\par
{\b M/}                d n1 --- n2 n3\par
\par
A mixed magnitude math operator which leaves the signed remainder n2 and signed\par
quotient n3, from a double number dividend and divisor n1.  The  remainder takes\par
its sign from the dividend.\par
\par
\par
{\b M/MOD}           ud1 u2 --- u3 ud4\par
\par
An unsigned mixed magnitude math operation which leaves a double quotient ud4 and\par
remainder u3, from a double dividend ud1 and single divisor u2.\par
\par
\par
{\b MAX}              n1 n2 --- max                            L0\par
\par
Leaves the greater of two numbers.\par
\par
\par
\par
\par
\par
109\page
{\b MESSAGE}              n ---\par
\par
Print on the selected output device the text of line n relative to screen 4 of\par
drive 0.  n may be positive or negative.  MESSAGE may be used to print incidental\par
text such as report headers.  If WARNING is zero, the message will simply be\par
printed as a number (disc unavailable).\par
\par
\par
{\b MIN}              n1 n2 --- min                            L0\par
\par
Leave the smaller of two numbers.\par
\par
\par
{\b MINUS}               n1 --- n2                             L0\par
\par
Leave the two's complement of a number.\par
\par
\par
{\b MOD}              n1 n2 --- mod                            L0\par
\par
Leave the remainder of n1/n2, with the same sign as n1.\par
\par
\par
{\b NEXT}\par
\par
This is the inner interpreter that uses the interpretive IP to execute compiled\par
Forth definitions.  It is not directly executed but is the return point for all\par
code procedures.  It acts by fetching the address pointed by IP, and storing this\par
value in register W.  It then jumps to the address pointed to by the address\par
pointed to by W.  W points to the code field of a definition which contains the\par
address of the code which executes for that definition.  This usage of indirect\par
threaded code is a major contributor to the power, portability, and extensibility\par
of Forth.\par
\par
\par
{\b NFA}                pfa --- nfa\par
\par
Convert the parameter field address of a definition to its name field. See PFA.\par
\par
\par
{\b NUMBER}            addr --- d\par
\par
Convert a character string left at addr with a preceding count, to a signed\par
double number, using the current numeric base.  If a decimal point is encountered\par
in the text, its position will be given in DPL, but no other effect occurs.  If\par
numeric conversion is not possible, an error message will be given.\par
\par
\par
{\b OFFSET}                 --- addr                            U\par
\par
A user variable which may contain a block offset to disc drives.  The contents of\par
OFFSET is added to the stack number by BLOCK.  Messages by MESSAGE are independent\par
of OFFSET.  See BLOCK, DR0, DR1, MESSAGE.\par
\par
\par
{\b OR}               n1 n2 --- or                             L0\par
\par
Leave the bit-wise logical "OR" of two l6 bit values.\par
\par
\par
\par
\par
\par
\par
                                                                               110\page
{\b OUT}                    --- addr                            U\par
\par
A user variable that contains a value incremented by EMIT.  The user may alter and\par
examine OUT to control display formatting.\par
\par
\par
{\b OVER}             n1 n2 --- n1 n2 n1                       L0\par
\par
Copy the second stack value, placing it as the new top.\par
\par
\par
{\b PAD}                    --- addr                           L0\par
\par
Leave the address of the text output buffer, which is a fixed offset above HERE.\par
\par
\par
{\b PFA}                nfa --- pfa\par
\par
Convert the name field address of a compiled definition to its parameter field\par
address.\par
\par
\par
{\b POP}\par
\par
The code sequence to remove a stack value and return to NEXT.  POP is not directly\par
executable, but is s Forth re-entry point after machine code.\par
\par
\par
{\b PREV}                   --- addr\par
\par
A variable containing the address of the disc buffer most recently referenced.\par
The UPDATE command marks this buffer to be later written to disc.\par
\par
\par
{\b PUSH}\par
\par
This code sequence pushes machine registers to the computation stack and returns\par
to NEXT.  It is not directly executable, but is a Forth re-entry point after\par
machine code.\par
\par
\par
{\b PUT}\par
\par
This code sequence stores machine register contents over the topmost computation\par
value and returns to NEXT.  It is not directly executable, but is a Forth re-entry\par
point after machine code.\par
\par
\par
{\b QUERY}\par
\par
Input 80 characters of text (or until a "return") from the operator's terminal.\par
Text is positioned at the address contained in TIB with IN set to zero.\par
\par
\par
{\b QUIT}                                                      L1\par
\par
Clear the return stack, stop compilation, and return control to the operator's\par
terminal.  No message is given.\par
\par
\par
\par
\par
\par
\par
111\page
{\b R}                      --- n\par
\par
Copy the top of the return stack to the computation stack.\par
\par
\par
{\b R#}                     --- addr                            U\par
\par
A user variable which may contain the location of an editing cursor, or other file\par
related function.\par
\par
\par
{\b R/W}         addr blk f ---\par
\par
The Fig-FORTH standard read-write linkage.  addr specifies the source or\par
destination block buffer.  blk is the sequential number of the referenced block;\par
and f is a flag for f=0 write and f=1 read.  R/W determines the location on mass\par
storage, performs the read-write and any error checking.\par
\par
\par
{\b R>}                     --- n                              L0\par
\par
Remove the top value from the return stack and leave it on the computation stack.\par
See >R and R.\par
\par
\par
{\b R0}                     --- addr                            U\par
\par
A user variable containing the initial location of the return stack.  Pronounced\par
R-zero.  See RP!\par
\par
\par
{\b REPEAT}          addr n --- (compiling)                  P,C2\par
\par
Used within a colon-definition in the form:\par
                BEGIN  ...  WHILE  ...  REPEAT\par
At run-time, REPEAT forces an unconditional branch back to just after the\par
corresponding BEGIN.\par
\par
At compile-time, REPEAT compiles BRANCH and the offset from HERE to addr.  n is\par
used for error testing.\par
\par
\par
{\b ROT}           n1 n2 n3 --- n2 n3 n1                       L0\par
\par
Rotate the top three values on the stack, bringing the third to the top.\par
\par
\par
{\b RP@}               addr\par
\par
Leaves the current value in the return stack pointer register.\par
\par
\par
{\b RP!}\par
\par
A computer dependent procedure to initialise the return stack pointer from user\par
variable R0.\par
\par
\par
{\b S->D}                 n --- d\par
\par
Sign extend a single number to form a double number.\par
\par
\par
\par
                                                                               112\page
{\b S0}                     --- addr                            U\par
\par
A user variable that contains the initial value for the stack pointer.  Pronounced\par
S-zero.  See SP!\par
\par
\par
{\b SCR}                    --- addr                            U\par
\par
A user variable containing the screen number most recently reference by LIST.\par
\par
\par
{\b SIGN}               n d --- d                              L0\par
\par
Stores an ASCII "-"  sign just before a converted numeric output string in the\par
text output buffer when n is negative.  n is discarded, but double number d is\par
maintained.  Must be used between <# and #>.\par
\par
\par
{\b SMUDGE}\par
\par
Used during word definition to toggle the "smudge bit" in a definition's name\par
field.  This prevents an uncompleted definition from being found during dictionary\par
searches, until compiling is completed without error.\par
\par
\par
{\b SP!}\par
\par
A computer dependent procedure to initialize the stack pointer from S0.\par
\par
\par
{\b SP@}                    --- addr\par
\par
A computer dependent procedure to return the address of the stack position to the\par
top of the stack, as it was before SP@ was executed. (e.g. 1 2 SP@ @ . . . would\par
print 2 2 1).\par
\par
\par
{\b SPACE}\par
\par
Transmit an ASCII blank to the output device.\par
\par
\par
{\b SPACES}               n ---                                L0\par
\par
Transmit n ASCII blanks to the output device.\par
\par
\par
{\b STATE}                  --- addr                         L0,U\par
\par
A user variable containing the compilation state.  A non-zero indicates\par
compilation.  The value itself may be implementation dependent.\par
\par
\par
{\b SWAP}             n1 n2 --- n2 n1                          L0\par
\par
Exchange the top two values On the stack.\par
\par
\par
\par
\par
\par
\par
\par
\par
113\page
{\b TASK}\par
\par
A no-operation word which can mark the boundary between applications.  By\par
forgetting TASK and re-compiling, an application can be discarded in its entirety.\par
\par
\par
{\b TEXT}                 c ---\par
\par
Accept the following test to PAD.  c is the text delimiter.\par
\par
{\b THEN}                                                 P,C0,L0\par
\par
An alias for ENDIF.\par
\par
\par
{\b TIB}                    --- addr                            U\par
\par
A user variable containing the address of the terminal input buffer.\par
\par
\par
{\b TOGGLE}          addr b ---\par
\par
Complement the contents of addr by the bit pattern b.\par
\par
\par
{\b TRAVERSE}       addr1 n --- addr2\par
\par
Move across the name field of a Fig-FORTH variable length name field.  addr1 is\par
the address of either the length byte or the last letter.  If n=-1, the motion is\par
toward low memory.  The addr2 resulting is the address of the other end of the\par
name.\par
\par
\par
{\b TYPE}        addr count ---                                L0\par
\par
Transmit count characters from addr to the selected output device.\par
\par
\par
{\b U<}               u1 u2 --- f\par
\par
Leave the boolean value of an unsigned less-than comparison.  Leaves f=1 for u1 >\par
u2; otherwise leaves 0.  This function should be used when comparing memory\par
addresses.\par
\par
\par
{\b U*}               u1 u2 --- ud\par
\par
Leave the unsigned double number product of two unsigned numbers.\par
\par
\par
{\b U.}                   u ---\par
\par
Prints an unsigned 16 bit number converted according to BASE. A trailing blank\par
follows.\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
                                                                               114\page
{\b U/}               ud u1 --- u2 u3\par
\par
Leave the unsigned remainder u2 and unsigned quotient u3 from the unsigned double\par
dividend ud and unsigned divisor u1.\par
\par
\par
{\b UNTIL}                f --- (run-time)\par
                addr n --- (compile)                 P,C2,L0\par
\par
Occurs within a colon-definition in the form:\par
                         BEGIN ... UNTIL\par
At run-time, UNTIL controls the conditional branch back to the corresponding\par
BEGIN.  If f is false, execution returns to just after BEGIN, if true, execution\par
continues ahead.\par
\par
At compile-time, UNTIL compiles (0BRANCH) and an offset from HERE to addr.  n is\par
used for error tests.\par
\par
\par
{\b UPDATE}                                                    L0\par
\par
Marks the most recently referenced block (pointed to by PREV) as altered.  The\par
block will subsequently be transferred to disc should its buffer be required for\par
storage of a different block.\par
\par
\par
{\b USE}                    --- addr\par
\par
A variable containing the address of the block buffer to use next, as the least\par
recently written.\par
\par
\par
{\b USER}                 n ---                                L0\par
\par
A defining word used in the form:\par
                   n USER cccc\par
which creates a user variable cccc.  The parameter field of cccc contains n as a\par
fixed offset relative to the user pointer register UP for this upper variable.\par
When cccc is later executed, it places the sum of its offset and the user base\par
address on the stack, as the storage address of that particular variable.\par
\par
\par
{\b VARIABLE}                                                E,L0\par
\par
A defining word used in the form:\par
                   n VARIABLE cccc\par
When VARIABLE is executed, it creates the definition cccc with its parameter field\par
initialised to n.  When cccc is later executed, the address of its parameter field\par
(containing n) is left on the stack, so that a fetch or store may access this\par
location.\par
\par
\par
{\b VOC-LINK}               --- addr                            U\par
\par
A user variable containing the address of a field in the definition of the most\par
recently created vocabulary.  All vocabulary names are linked by these fields, to\par
allow control for FORGETting through multiple vocabularies.\par
\par
\par
\par
\par
\par
\par
\par
115\page
{\b VOCABULARY}                                               E,L\par
\par
A defining word used in the form:\par
               VOCABULARY cccc\par
to create a vocabulary definition cccc.  Subsequent use of cccc will make it the\par
CONTEXT vocabulary which is searched first by INTERPRET.  The sequence "cccc\par
DEFINITIONS" will also make cccc the CURRENT vocabulary, into which, new\par
definitions are placed.\par
\par
In Fig-FORTH, cccc will also be chained so as to include all definitions of the\par
vocabulary in which cccc is itself defined. All vocabularies ultimately chain to\par
Forth.  By convention, vocabulary names are to be declared IMMEDIATE.  See\par
VOC-LINK.\par
\par
\par
{\b VLIST}\par
\par
List the names of the definitions in the context vocabulary.  Pressing "Break"\par
will terminate the listing.\par
\par
\par
{\b WARNING}                --- addr                            U\par
\par
A user variable containing a value controlling messages.\par
If = 1 disc is present, and screen 4 of drive 0 is the base location for messages.\par
If = 0, no disc is present and messages will be presented by number.  If = -1,\par
execute (ABORT)  for a user specified procedure.  See MESSAGE, ERROR, ABORT.\par
\par
\par
{\b WHERE}            n1 n2 ---\par
\par
If an error occurs during LOAD from disc, ERROR leaves these values on the stack\par
to show the user where the error occurred. WHERE uses these to print the screen\par
and line number of where this is.\par
\par
\par
{\b WHILE}                f --- (run-time)\par
              addr1 n1 --- addr1 n1 addr2 n2            P,C2\par
\par
Occurs in a colon-definition in the form:\par
                  BEGIN ... WHILE (tp) ... REPEAT\par
At run-time, WHILE selects conditional execution based on boolean flag f.  If f is\par
true (non-zero), WHILE continues execution of the true part through to REPEAT,\par
which then branches back to BEGIN.  If f is false (zero), execution skips to just\par
after REPEAT, exiting the structure.\par
\par
At compile time, WHILE emplaces (0BRANCH) and leaves addr2 of the reserved offset.\par
The stack values will be resolved by REPEAT.\par
\par
\par
{\b WIDTH}                  --- addr                            U\par
\par
In Fig-FORTH, a user variable containing the maximum number of letters saved in\par
the compilation of a definitions name.  It must be 1 through to 31, having a\par
default value of 31.  The name character count and its natural characters are\par
saved, up to the value of WIDTH.  The value may be changed at any time within the\par
above limits.\par
\par
\par
\par
\par
\par
\par
\par
                                                                               116\page
{\b WORD}                 c ---                                L0\par
\par
Read the next text characters from the input stream being interpreted, until a\par
delimiter c is found, storing the packed character string beginning at the\par
dictionary buffer HERE. WORD leaves the character count in the first byte, the\par
characters, and ends with two or more blanks.  Leading occurrences of c are\par
ignored.  If BLK is zero, text is taken from the terminal input buffer, otherwise\par
from the disc block stored in BLK.  See BLK, IN.\par
\par
\par
{\b X}\par
\par
This is pseudonym for the "null" or dictionary entry for a name of one character\par
of ASCII null.  It is the execution procedure to terminate interpretation of a\par
line of text from the terminal or within a disc buffer, as both buffers always\par
have a null at the end.\par
\par
\par
{\b XOR}              n1 n2 --- xor                            L1\par
\par
Leave the bit-wise logical Exclusive-OR of two values.\par
\par
\par
{\b [}                                                       P,L1\par
\par
Used in a colon-definition in the form:\par
                  : xxx   words   more   ;\par
Suspend  compilation.  The words after [ are executed, not compiled.  This allows\par
calculation or compilation exceptions before resuming compilation with ].  See\par
LITERAL, ].\par
\par
\par
{\b [COMPILE]}                                                P,C\par
\par
Used in a colon-definition in the form:\par
                  : xxx [COMPILE] FORTH  ;\par
[COMPILE] will force the compilation of an immediate definition, that would\par
otherwise execute during compilation. The above example will select the FORTH\par
vocabulary when xxx executes, rather than at compile time.\par
\par
\par
{\b ]}                                                         L1\par
\par
Resume compilation, to the completion of a colon-definition.  See [.\par
\par
\par
\par
{\b ADDITIONAL GLOSSARY}\par
\par
\par
{\b C/L}                    --- n\par
\par
A constant containing the number of characters per line (64).\par
\par
\par
{\b WARM}                   ---\par
\par
This will perform a warm-start.\par
\par
\par
\par
\par
\par
\par
117\page
{\b NOOP}                   ---\par
\par
This will perform a no-operation, i.e. do nothing.\par
\par
\par
{\b WARM->COLD}\par
\par
This allows you to preserve any FORTH word defined to date, so that a COLD start\par
will not delete them.  When saving your code, save from 24832 to HERE.\par
\par
e.g.  : NEWWORD ." THIS WILL BE PRESERVED BY WARM->COLD " ;\par
\par
If we now do a COLD start this will be lost, but if we first key in WARM->COLD and\par
then do a COLD start, it will still be there.\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
                                                                               118\page
                                 {\b IDEAL GLOSSARY}\par
\par
\par
{\b WORD}     {\b PARAMETERS}         {\b ACTION}\par
\par
{\b WCRV}     HGT, LEN, COL,     Scroll the window vertically with wrap by\par
         ROW, NPX           NPX pixels.\par
\par
{\b SCRV}     HGT, LEN, COL,     Scroll the window vertically without\par
         ROW, NPX           wrap by NPX pixels.\par
\par
{\b WRR1V}    HGT, LEN, COL,     Scroll the window 1 pixel right with wrap.\par
         ROW\par
\par
{\b WRL1V}    HGT, LEN, COL,     Scroll the window 1 pixel left with wrap.\par
         ROW\par
\par
{\b WRR4V}    HGT, LEN, COL,     Scroll the window 4 pixels right with wrap.\par
         ROW\par
\par
{\b WRL4V}    HGT, LEN, COL,     Scroll the window 4 pixels left with wrap.\par
         ROW\par
\par
{\b WRR8V}    HGT, LEN, COL,     Scroll the window 8 pixels right with wrap.\par
         ROW\par
\par
{\b WRL8V}    HGT, LEN, COL,     Scroll the window 8 pixels left with wrap.\par
         ROW\par
\par
{\b SCR1V}    HGT, LEN, COL,     Scroll the window 1 pixel right without\par
         ROW                wrap.\par
\par
{\b SCL1V}    HGT, LEN, COL,     Scroll the window 1 pixel left without\par
         ROW                wrap.\par
\par
{\b SCR4V}    HGT, LEN, COL,     Scroll the window 4 pixels right without\par
         ROW                wrap.\par
\par
{\b SCL4V}    HGT, LEN, COL,     Scroll the window 4 pixels left without\par
         ROW                wrap.\par
\par
{\b SCR8V}    HGT, LEN, COL,     Scroll the window 8 pixels right without\par
         ROW                wrap.\par
\par
{\b SCL8V}    HGT, LEN, COL,     Scroll the window 8 pixels left without\par
         ROW                wrap.\par
\par
{\b ATTRV}    HGT, LEN, COL,     Scroll the window attributes 1 character\par
         ROW                right with wrap.\par
\par
{\b ATTLV}    HGT, LEN, COL,     Scroll the window attributes 1 character\par
         ROW                left with wrap.\par
\par
{\b ATTUPV}   HGT, LEN, COL,     Scroll the window attributes 1 character\par
         ROW                up with wrap.\par
\par
{\b ATTDNV}   HGT, LEN, COL,     Scroll the window attributes 1 character\par
         ROW                down with wrap.\par
\par
{\b WCRM}     SPN                Scroll the Sprite vertically with wrap by\par
                            NPX pixels.\par
\par
\par
\par
119\page
{\b SCRM}     SPN                Scroll the Sprite vertically without wrap\par
                            by NPX pixels.\par
\par
{\b WRR1M}    SPN                Scroll the Sprite 1 pixel right with wrap.\par
\par
{\b WRL1M}    SPN                Scroll the Sprite 1 pixel left with wrap.\par
\par
{\b WRR4M}    SPN                Scroll the Sprite 4 pixels right with wrap.\par
\par
{\b WRL4M}    SPN                Scroll the Sprite 4 pixels left with wrap.\par
\par
{\b WRR8M}    SPN                Scroll the Sprite 8 pixels right with wrap.\par
\par
{\b WRL8M}    SPN                Scroll the Sprite 8 pixels left with wrap.\par
\par
{\b SCR1M}    SPN                Scroll the Sprite 1 pixel right without wrap.\par
\par
{\b SCL1M}    SPN                Scroll the Sprite 1 pixel left without wrap.\par
\par
{\b SCR4M}    SPN                Scroll the Sprite 4 pixels right without wrap.\par
\par
{\b SCL4M}    SPN                Scroll the Sprite 4 pixels left without wrap.\par
\par
{\b SCR8M}    SPN                Scroll the Sprite 8 pixels right without wrap.\par
\par
{\b SCL8M}    SPN                Scroll the Sprite 8 pixels left without wrap.\par
\par
{\b ATTRM}    SPN                Scroll the Sprite attributes 1 character\par
                            right with wrap.\par
\par
{\b ATTLM}    SPN                Scroll the Sprite attributes 1 character\par
                            left with wrap.\par
\par
{\b ATTUPM}   SPN                Scroll the Sprite attributes 1 character\par
                            up with wrap.\par
\par
{\b ATTDNM}   SPN                Scroll the Sprite attributes 1 character\par
                            down with wrap.\par
\par
{\b GETBLS}   SPN, COL, ROW      Block move screen data from screen to\par
                            Sprite.\par
\par
{\b GETXRS}   SPN, COL, ROW      Logically XOR screen data into Sprite data.\par
\par
{\b GETORS}   SPN, COL, ROW      Logically OR screen data into Sprite data.\par
\par
{\b GETNDS}   SPN, COL, ROW      Logically AND screen data into Sprite data.\par
\par
{\b PUTBLS}   SPN, COL, ROW      Block move Sprite data from Sprite to\par
                            screen.\par
\par
{\b PUTXRS}   SPN, COL, ROW      Logically XOR Sprite data into screen data.\par
\par
{\b PUTORS}   SPN, COL, ROW      Logically OR Sprite data into screen data.\par
\par
{\b PUTNDS}   SPN, COL, ROW      Logically AND Sprite data into screen data.\par
\par
{\b GWBLS}    SPN, COL, ROW,     Block move screen data from screen window\par
         SCOL, SROW, HGT,   into Sprite window.\par
         LEN.\par
\par
\par
\par
\par
                                                                               120\page
{\b GWXRS}    SPN, COL, ROW,     Logically XOR screen data from screen window\par
         SCOL, SROW, HGT,   into Sprite window.\par
         LEN\par
\par
{\b GWORS}    SPN, COL, ROW,     Logically OR screen data from screen window\par
         SCOL, SROW, HGT,   into Sprite window.\par
         LEN\par
\par
{\b GWNDS}    SPN, COL, ROW,     Logically AND screen data from screen window\par
         SCOL, SROW, HGT,   into Sprite window.\par
         LEN\par
\par
{\b GWATTS}   SPN, COL, ROW,     Block move attributes from screen window into\par
         SCOL, SROW, HGT,   Sprite window.\par
         LEN\par
\par
{\b PWBLS}    SPN, COL, ROW,     Block move Sprite data from Sprite window\par
         SCOL, SROW, HGT,   into screen window.\par
         LEN\par
\par
{\b PWXRS}    SPN, COL, ROW,     Logically XOR Sprite window data into screen\par
         SCOL, SROW, HGT,   window.\par
         LEN\par
\par
{\b PWORS}    SPN, COL, ROW,     Logically OR Sprite window data into screen\par
         SCOL, SROW, HGT,   window.\par
         LEN\par
\par
{\b PWNDS}    SPN, COL, ROW,     Logically AND Sprite window data into screen\par
         SCOL, SROW, HGT,   window.\par
         LEN\par
\par
{\b PWATTS}   SPN, COL, ROW,     Block move Sprite window attributes into\par
         SCOL, SROW, HGT,   screen window.\par
         LEN\par
\par
{\b GWBLM}    SP1, SP2, SCOL,    Block move Sprite SP1 into Sprite SP2 at\par
         SROW               SCOL,SROW.\par
\par
{\b GWXRM}    SP1, SP2, SCOL,    Logically XOR Sprite SP1 into Sprite SP2\par
         SROW               at SCOL,SROW.\par
\par
{\b GWORM}    SP1, SP2, SCOL,    Logically OR Sprite SP1 into Sprite SP2 at\par
         SROW               SCOL,SROW.\par
\par
{\b GWNDM}    SP1, SP2, SCOL,    Logically AND Sprite SP1 into Sprite SP2\par
         SROW               at SCOL,SROW.\par
\par
{\b GWATTM}   SP1, SP2, SCOL,    Block move attributes of Sprite SP1 into\par
         SROW               Sprite SP2 at SCOL,SROW.\par
\par
{\b PWBLM}    SP1, SP2, SCOL,    Block move window at SCOL,SROW of Sprite\par
         SROW               SP2 into Sprite SP1.\par
\par
{\b PWXRM}    SP1, SP2, SCOL,    Logically XOR window at SCOL,SROW of Sprite\par
         SROW               SP2 into Sprite SP1.\par
\par
{\b PWORM}    SP1, SP2, SCOL,    Logically OR window at SCOL,SROW of Sprite\par
         SROW               SP2 into Sprite SP1.\par
\par
\par
\par
\par
\par
121\page
{\b PWNDM}    SP1, SP2, SCOL,    Logically AND window at SCOL,SROW of Sprite\par
         SROW               SP2 into Sprite SP1.\par
\par
{\b PWATTM}   SP1, SP2, SCOL,    Block move attributes of window at\par
         SROW               SCOL,SROW of Sprite SP2 into Sprite SP1.\par
\par
{\b COPYM}    SP1, SP2           As GWBLM but SCOL,SROW assumed zero.\par
\par
{\b COPXRM}   SP1, SP2           As GWXRM but SCOL,SROW assumed zero.\par
\par
{\b COPORM}   SP1, SP2           As GWORM but SCOL,SROW assumed zero.\par
\par
{\b COPNDM}   SP1, SP2           As GWNDM but SCOL,SROW assumed zero.\par
\par
{\b COPATTM}  SP1, SP2           As GWATTM but SCOL,SROW assumed zero.\par
\par
{\b INVV}     HGT, LEN, COL,     Invert screen window.\par
         ROW\par
\par
{\b MIRV}     HGT, LEN, COL,     Mirror screen window about its centre.\par
         ROW\par
\par
{\b MARV}     HGT, LEN, COL,     Mirror screen window attributes about\par
         ROW                centre.\par
\par
{\b INVM}     SPN                Invert Sprite data.\par
\par
{\b MIRM}     SPN                Mirror Sprite about its centre.\par
\par
{\b MARM}     SPN                Mirror Sprite attributes about centre.\par
\par
{\b SPINM}    SP1, SP2           Rotate Sprite SP2 90 degrees clockwise\par
                            into Sprite SP1.\par
\par
{\b DSPM}     SP1, SP2           Enlarge Sprite SP2 into Sprite SP1.\par
\par
{\b HALT}                        Suspend CPU operation until next interrupt.\par
\par
{\b EI}                          Enable interrupt.\par
\par
{\b DI}                          Disable interrupt.\par
\par
{\b EXX}                         Exchange Ideal variables with the alternate\par
                            Ideal variables.\par
\par
{\b INT-ON}   FORTH WORD         Execute specified Forth Word under interrupt.\par
\par
{\b INT-OFF}                     Terminate execution of interrupt driven\par
                            word.\par
\par
{\b PROG}                        Enter BASIC.\par
\par
{\b RESERVE}  N1                 Reserve N1 bytes in the dictionary for\par
                            BASIC source.\par
\par
{\b GOTO}     N1                 Begin execution of BASIC at line N1.\par
\par
{\b RETUSR}                      Return to BASIC from RANDOMIZE USR 30000\par
                            call.\par
\par
\par
\par
\par
\par
                                                                               122\page
{\b DSPRITE}  SPN                Delete Sprite and recover bytes from below.\par
\par
{\b ISPRITE}  SPN, HGT, LEN      Create Sprite and move current Sprites\par
                            down to accommodate.\par
\par
{\b WIPE}     SPN                Delete Sprite and recover bytes from above.\par
\par
{\b SPRITE}   SPN, HGT, LEN      Create Sprite at free space after last\par
                            Sprite.\par
\par
{\b RELOCATE} MLEN               Relocate Sprite space by signed 16 bit\par
                            length MLEN.\par
\par
{\b COLD#}    SPST, SLEN         Reset Sprite space to begin at SPST with\par
                            SLEN bytes cleared to zeros.\par
\par
{\b SETAV}    HGT, LEN, COL,     Fill the screen window with the current\par
         ROW                attributes.\par
\par
{\b SETAM}    SPN                Fill the Sprite with the current attributes.\par
\par
{\b CLSV}     HGT, LEN, COL,     Clear the screen window and fill with the\par
         ROW                current attributes.\par
\par
{\b CLSM}     SPN                Clear the Sprite.\par
\par
{\b ADJV}     HGT, LEN, COL,     Adjust the screen window to lie on the\par
         ROW                screen.\par
\par
{\b ADJM}     SPN, COL, ROW      Adjust COL, ROW, HGT, LEN, SCOL, SROW such\par
                            that GETS and PUTS lie on the screen.\par
\par
{\b RND}      N1                 Leave a random number between 0 and N1 on\par
                            the stack.\par
\par
{\b OUT#}     N1, N2             Output LSB of N1 to 16 bit port address N2.\par
\par
{\b IN#}      N1                 Leave on the stack, byte from 16 bit port\par
                            address N1.\par
\par
{\b ZAPINT}                      Create run time program with interrupt\par
                            facility.\par
\par
{\b ZAP}                         Create run time program without interrupt\par
                            facility.\par
\par
{\b CALL}     N1                 Execute machine code subroutine at address\par
                            N1.\par
\par
{\b KB}       N1, N2             Test for key press at row N1, col N2 and\par
                            stack true or false flag.\par
\par
{\b SCANV}    COL, ROW           The character position is scanned for screen\par
                            data and a true or false flag stacked.\par
\par
{\b SCANM}    SPN                The Sprite is scanned for data and a true\par
                            or false flag stacked.\par
\par
{\b BLEEP}    N1, N2             Sinclair BEEP.  N1 is duration, N2 is pitch.\par
\par
\par
\par
\par
\par
123\page
{\b ATTON}                       Enable attribute switch.\par
\par
{\b ATTOFF}                      Disable attribute switch.\par
\par
\par
\par
                              {\b FORTH/BASIC GLOSSARY}\par
\par
\par
{\b WORD}     {\b PARAMETERS}         {\b ACTION}\par
\par
{\b COPY}                        Copy screen to ZX-Printer.\par
\par
{\b AT}       N1, N2             Move print position to N1,N2.\par
\par
{\b BORDER}   N1                 Set border colour to N1.\par
\par
{\b CLS}                         Clear whole screen, home cursor and fill\par
                            with current attributes.\par
\par
{\b DRAW-ARC} N1, N2, N3         \'b1X,\'b1Y,ANGLE.  As Sinclair's own.\par
\par
{\b CIRCLE}   N1, N2, N3         X,Y,RADIUS.  As Sinclair's own.\par
\par
{\b DRAW}     N1, N2             \'b1X,\'b1Y.  As Sinclair's own.\par
\par
{\b PLOT}     N1, N2             X,Y.  As Sinclair's own.\par
\par
{\b SCREEN$}  N1, N2             Leave on the stack the ASCII code of the\par
                            character at ROW N1, COL N2.\par
\par
{\b ATTR}     N1, N2             Leave on the stack the attribute code of\par
                            the character at ROW N1, COL N2.\par
\par
{\b POINT}    N1, N2             Test pixel at N1,N2 and leave a true or\par
                            false flag on the stack.\par
\par
{\b TAB}      N1                 Set print position to COL N1.\par
\par
{\b OVER}     N1                 Zero or one, as Sinclair's own.\par
\par
{\b INVERSE}  N1                 Zero or one, as Sinclair's own.\par
\par
{\b BRIGHT}   N1                 Zero or one, as Sinclair's own.\par
\par
{\b FLASH}    N1                 Zero or one, as Sinclair's own.\par
\par
{\b PAPER}    N1                 Set paper colour, as Sinclair's own.\par
\par
{\b INK}      N1                 Set ink colour, as Sinclair's own.\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
                                                                               124\page
                                   {\b USR CALLS}\par
\par
\par
{\b PRINT USR 24832}             Enter Forth from BASIC via a COLD START.\par
\par
{\b PRINT USR 24836}             Enter Forth from BASIC via a WARM START.\par
\par
{\b PRINT USR 30006}             Re-enter Forth from BASIC and continue\par
                            execution of the next Forth word.\par
\par
{\b RANDOMIZE USR 30000}         Call Forth and continue execution\par
                            up to the first occurrence of the Forth\par
                            word RETUSR.\par
\par
\par
\par
                        {\b EXTENDED SPECTRA FORTH GLOSSARY}\par
\par
\par
{\b WORD}     {\b PARAMETERS}         {\b ACTION}\par
\par
\par
{\b PRT-ON}                      Send all subsequent output to the printer.\par
\par
{\b PRT-OFF}                     Send all subsequent output to the screen.\par
\par
{\b EDIT}     N1                 Edit line number N1 from the current screen.\par
\par
{\b WARM->COLD}                  Create extended Forth.\par
\par
{\b J}                           Copy second loop index to the top of the\par
                            stack.\par
\par
{\b K}                           Copy third loop index to the top of the\par
                            stack.\par
\par
{\b DUMP}     N1                 Memory dump from address N1.\par
\par
{\b WARM}                        Perform a warm start.\par
\par
{\b EMITC}    N1                 As EMIT but control characters are also\par
                            supported.\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
125\page
{\b THE DEMONSTRATION PROGRAM - A BRIEF DESCRIPTION}\par
\par
\par
{\b THE WHITE LIGHTNING SCREEN}\par
\par
The green text at the top of the screen, sprites 59 and 60, is scrolled right in\par
background.\par
\par
The lightning bolt, sprite 32, is put to the screen using PUTBLS.  It is then\par
mirrored and then mirrored again using MIRV. It is removed from the screen using\par
PUTXRS.\par
\par
Two windows are defined over the 'WHITE LIGHTNING', sprites 30 and 31.  The left\par
window is scrolled left and the right window scrolled right using SCL8V and SCR8V\par
respectively.\par
\par
\par
{\b THE TRAIN}\par
\par
The steam engine is comprised of sprites 9, with sprites 18, 19, 20, and 21 for\par
the wheels in their four positions.  The coaches are comprised of sprites 14 with\par
sprites 23 and 24 for the wheels.\par
\par
The track, sprite 10, is scrolled left using WRL1V.  By means of an increasing and\par
decreasing delay loop, acceleration and deceleration effects are achieved.\par
\par
\par
{\b THE SPIDERS}\par
\par
Five spiders, sprite 7, are placed on the screen.  From the left, spider 1 is\par
scrolled down by 1 pixel, spider 3 is scrolled up 8 pixels and spider 5 is\par
scrolled up 4 pixels all - in background.\par
\par
Spiders 2 and 4 are animated up and down using sprites 7 and 8.\par
\par
\par
{\b THE SIDEWAYS SCROLLING CIRCLE OF INVADERS}\par
\par
Twelve Invaders, sprite 24, are placed in a circle on the screen, using either\par
WRR1M, WRR4M or WRR8M they are scrolled in memory and then placed on the screen\par
using PUTBLS.\par
\par
The Invader in the centre of the screen is scrolled left by 1 pixel in\par
background.\par
\par
\par
{\b THE ARRAY OF CLOCKWORK TOYS}\par
\par
The green clockwork toys are animated using sprites 49 and 50.  Each sprite in the\par
array is individually placed on the screen using PUTBLS.  The movement is\par
controlled by simple 'DO LOOPS'.\par
\par
\par
{\b THE VERTICAL ATTRIBUTE SCROLL}\par
\par
Using ATTUPV and decreasing and increasing delay loops the attributes placed on\par
the screen are scrolled up, whilst a random border colour change is executed.\par
\par
\par
\par
\par
\par
\par
\par
                                                                               126\page
{\b THE THREE VEHICLE SCROLLING DEMO}\par
\par
This demonstrates the 3 precisions of scrolls available - 1, 4 and 8 pixels.\par
\par
Sprite 1, the vintage car, demonstrates the fine 1 pixel scroll using SCL1V.\par
\par
Sprite 2, the van, demonstrates the faster 4 pixel scroll using SCL4V.\par
\par
Sprite 3, the dragster, demonstrates, the very fast 8 pixel, or 1 character\par
scroll, using SCL8V.\par
\par
\par
{\b THE TELEVISION}\par
\par
The television, sprite 13, is placed on the screen, a window is defined inside the\par
screen.\par
\par
Sprite 5, the dancer is used to demonstrate the 1 pixel scroll with wrap, WRR1V.\par
\par
Sprite 4, the duck, is used to demonstrate the 4 pixel scroll with wrap, WRR4V.\par
\par
Sprite 6, the rocket, is used to demonstrate the 8 pixel scroll with wrap, WRR8V.\par
\par
\par
{\b THE THREE SPACESHIPS}\par
\par
In this demonstration the 3 spaceships, sprite 15, are placed on the screen along\par
with their shadows, sprite 16.\par
\par
They are scrolled to the right by 1 pixel, with alternate 1 pixel up and down\par
scrolls, to give a sense of motion.\par
\par
The attributes of the foreground, sprite 17, and the background, sprite 11, are\par
scrolled to the left.  The background being scrolled at one character per\par
execution with the foreground being scrolled two characters per execution to give\par
a sense of perspective.\par
\par
\par
{\b THE BOUNCING MAN WITH HAT}\par
\par
The bouncing man is animated using sprites 28 and 29.  The sprites are placed on\par
the screen using PUTXRS, and removed again using PUTXRS, such that the character\par
appears to move behind the 'WHITE LIGHTNING' text without destroying it.\par
\par
Simple DO LOOPS control his path.\par
\par
Disabling interrupts, using DI, during the animation appeared to reduce the slight\par
flicker of the character, the interrupts where enabled again using EI.\par
\par
\par
{\b THE CIRCLE OF ROTATING INVADERS}\par
\par
From the original invader, sprite 24, sprites 25, 26 and 27 were created using the\par
'ROTATE' facility of the sprite development package.\par
\par
This demo shows how the centre invader, scrolling left by 1 pixel in background,\par
moves at a constant smooth rate, independent from that of the increasing and then\par
decreasing rate of the rotating invaders in the outer circle.\par
\par
\par
\par
\par
\par
\par
127\page
{\b THE PLAGUE OF CRABS}\par
\par
The crabs, sprite 33, are placed on the screen using PUTBLS.\par
\par
The ROW and COL variables for the PUTBLS are loaded up each time by a random number\par
produced by using the Forth word RND.\par
\par
\par
{\b THE BOUNCING BALL}\par
\par
This is a sprite or to be more precise, 4 sprites, moving in background.  The ball\par
is defined in four orientations to give half character resolution.  The movement\par
is obtained by doing a PUTXRS, calculating the next co-ordinates, blotting out the\par
old sprite with a second PUTXRS and then repeating the cycle. The listing for this\par
screen is given in section 3 under the heading - Programmable Sprites.\par
\par
\par
{\b THE LUNAR SPACE SHIP}\par
\par
The radar dish on top of the space ship, sprite 34, is animated by sequentially\par
placing sprites 35 to 42, giving the effect of constant rotation.\par
\par
Just before the spaceship takes off, an explosion, sprite 43, is XORed over the\par
spaceship using PUTXRS.  It is removed again by a second PUTXRS.\par
\par
The spaceship is then scrolled up in a vertical window by 1 pixel.  The Lunar\par
surface, sprite 44, is also scrolled by 1 pixel, to the right using WRR1V.\par
\par
\par
{\b THE ROTATING BALLS}\par
\par
Four sprites were used to give the impression of rotation, these being sprites 45,\par
46, 47, and 48.\par
\par
Once the sprites were created, animation was a simple process of sequentially\par
placing the sprites to the screen with an increasing and decreasing time delay\par
between each PUTBLS.\par
\par
\par
{\b THE CREDITS}\par
\par
To achieve the text scrolling up from the bottom of the screen, the bottom line\par
was set with 0 INK and 0 PAPER colours, while the rest of the screen had 7 INK and\par
0 PAPER colours.\par
\par
Each line of text was printed into that line and then the whole screen scrolled up\par
8 * 1 pixel, such that the text data scrolls into the screen that has 7 INK\par
attributes and thus appears to smoothly scroll onto the screen.\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
                                                                               128\page
{\b SOME SIMPLE PROGRAMMING EXAMPLES}\par
\par
{\b Example 1}\par
\par
To scroll a window at row 8, column 9, 5 characters high by 10 characters long, 1\par
pixel to the left with wrap - type:\par
\par
: DEM1 5 HGT ! 10 LEN ! 8 ROW ! 9 COL ! WRL1V ; <CR>\par
\par
To put some data on the screen: VLIST <CR>\par
\par
To scroll the window 100 times type:\par
\par
: DEM2 100 0 DO DEM1 LOOP ; <CR>\par
DEM2 <CR>\par
\par
To execute DEM1 in background type: ' DEM1 INT-ON <CR>\par
\par
To halt the background execution of DEM1 type: INT-OFF <CR>\par
\par
\par
{\b Example 2}\par
\par
To scroll a window at column 12, row 3, 10 characters high and 5 characters wide,\par
downward by 3 pixels with wrap - type:\par
\par
: DEM3 10 HGT ! 5 LEN ! -3 NPX ! 2 ROW ! 12 COL ! WCRV ; <CR>\par
\par
to define the word, then: DEM3 <CR> to execute it.\par
\par
To run DEM3 in background type:\par
\par
' DEM3 INT-ON <CR>\par
\par
To halt the background execution type: INT-OFF <CR>\par
\par
\par
{\b Example 3}\par
\par
To invert a window at column 10, row 5, 4 characters high and 4 characters wide -\par
type:\par
\par
: DEM4 4 HGT ! 4 LEN ! 5 ROW ! 10 COL ! INVV ; <CR>\par
\par
and then DEM4 <CR> to execute.\par
\par
\par
{\b Example 4}\par
\par
It is not always necessary to use colon definitions to achieve a particular\par
result.  To PUT sprite 34 (If you've got the Demo sprites loaded or have already\par
defined your own sprite 34) at row 5, column 6, and replace any data currently at\par
that position - type:\par
\par
34 SPN ! 5 ROW ! 6 COL ! PUTBLS <CR>\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
129\page
{\b Example 5}\par
\par
Often it is useful to define a word which carries out an operation that is used\par
frequently and which saves typing - for instance:\par
\par
: DEM5 COL ! ROW ! SPN ! PUTBLS ;\par
\par
If we wanted to carry out the simple PUT command in example 4 all we'd need to\par
type would be:\par
\par
34 5 6 DEM5\par
\par
\par
{\b Example 6}\par
\par
To scroll sprite 29 in memory by 1 pixel to the right with wrap and PUT it on the\par
screen at row 10, column 11 - use:\par
\par
: DEM6 29 SPN ! 10 ROW ! 11 COL ! WRR1M PUTBLS ;\par
\par
To run DEM6 in background use: ' DEM6 INT-ON\par
\par
\par
{\b Example 7}\par
\par
To fill a screen window, at column 17, row 5, 5 characters long and 10 characters\par
high, with the attributes - 6 INK, 2 PAPER and 1 FLASH - use the following:\par
\par
: DEM7 1 FLASH 6 INK 2 PAPER 10 HGT ! 5 LEN ! 13 ROW ! 17 COL ! SETAV 0 FLASH 7\par
INK 1 PAPER ;\par
\par
\par
{\b Example 8}\par
\par
To change the green face of sprite 28 into a red one use:\par
\par
: DEM8 28 SPN ! 2 INK ! 1 BRIGHT 0 PAPER SETAM PUTBLS ;\par
\par
\par
{\b Example 9}\par
\par
To pick a random number between 0 and 100 use:\par
\par
: DEM9 100 RND . ;\par
\par
\par
{\b Example 10}\par
\par
To pick a random INK colour and change sprite 34's INK colour to this colour, and\par
then put it at column 10, row 10, use:\par
\par
: DEM10 7 RND INK 34 SPN ! SETAM 10 ROW ! 10 COL ! PUTBLS ;\par
\par
To run DEM10 in background use: ' DEM10 INT-ON and to halt DEM10 use INT-OFF.\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
\par
                                                                               130\page
{\b Example 11}\par
\par
To place sprite 24 into the screen of sprite 13 use:\par
\par
: DEM11 24 SP1 ! 13 SP2 ! 7 SCOL ! 6 SROW ! GWBLM 10 ROW ! 10 COL ! ATTON PUTBLS\par
;\par
\par
\par
{\b Example 12}\par
\par
To XOR sprite 43, the explosion, with sprite 27, the 270 degree rotated Invader,\par
in memory, use:\par
\par
: DEM12 43 SP1 ! 27 SP2 ! COPXRM 10 ROW ! 10 COL ! 27 SPN ! ATTON PUTBLS ;\par
\par
\par
{\b Example 13}\par
\par
To invert sprite 7, the spider, in memory use:\par
\par
: DEM13 7 SPN ! INVM 10 ROW ! 10 COL ! PUTBLS ;\par
\par
\par
{\b Example 14}\par
\par
To enlarge sprite 24 into sprite 45 using the DSPM command use:\par
\par
: DEM14 45 SP1 ! 24 SP2 ! DSPM 45 SPN ! 10 COL ! 10 ROW ! PUTBLS ;\par
\par
\par
{\b Example 15}\par
\par
To search through sprite space, locate any existing sprites, print out the start\par
of data, length and height, use:\par
\par
: DEM15 255 1 DO I SPN ! TEST 1 = IF I. SPACE DPTR @ U. SPACE LEN ? SPACE HGT ?\par
SPACE CR THEN LOOP ;\par
\par
\par
{\b Example 16}\par
\par
To scroll a landscape sprite numbered 128, 2 characters high and 64 characters\par
wide, left by 1 pixel under interrupt, use the following:\par
\par
SCR # 6\par
  0 0 VARIABLE CL 8 VARIABLE PH : OPEN EXX 0 COL ! 12 ROW ! 2 HGT !\par
  1 0 SROW ! 0 SCOL ! 128 SPN ! 0 PAPER 6 INK 32 LEN ! CLSV 0 INK\par
  2 1 LEN ! CLSV 32 LEN ! PWBLS EXX ;\par
  3 : NXB CL @ 1+ DUP 64 = IF DROP 0 ENDIF DUP CL ! 31 + 64 MOD SCOL\par
  4 ! 1 LEN ! PWBLS 32 LEN ! ;\par
  5 : SL WRL1V PH @ 1- DUP 0= IF NXB DROP 8 ENDIF PH ! ;\par
  6 : GO 6 INK 0 PAPER 0 BORDER 1 BRIGHT CLS 14 ROW ! 1 COL !\par
  7 6 PAPER 31 LEN ! 4 HGT ! SETAV OPEN 6 INK ' SL INT-ON ;\par
\par
To speed this up to faster 4 or 8 pixel scrolls change lines 0 and 5 to read:\par
\par
  0 0 VARIABLE CL 2 VARIABLE PH : OPEN EXX 0 COL ! 12 ROW ! 2 HGT !\par
  5 : SL WRL4V PH @ 1- DUP 0= IF NXB DROP 2 ENDIF PH ! ;\par
\par
  0 0 VARIABLE CL 1 VARIABLE PH : OPEN EXX 0 COL ! 12 ROW ! 2 HGT !\par
  5 : SL WRL8V PH @ 1- DUP 0= IF NXB DROP 1 ENDIF PH ! ;\par
\par
Type: 6 LOAD <CR> to compile and GO <CR> to run.\par
\par
131\page
\par
{\b TRANSCRIBER'S NOTE}\par
\par
While OCRing and proofreading the scans of the White Lightning manuals, I have\par
tried to preserve, as best as I was able, the original pagination, layout,\par
spacing and formatting of the originals - while still incorporating all errata\par
noted and published in previous versions, and with a few (small) edits and\par
corrections of my own.\par
\par
This transcription is still a work in progress. If you discover any further\par
mistakes, please create a pull request (or otherwise report the errors) against\par
the manuals' source repository at:\par
\par
                            https://github.com/richmilne/white-lightning-manuals\page
}