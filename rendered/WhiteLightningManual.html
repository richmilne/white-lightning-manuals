<html>
    <head>
        <meta http-equiv="Content-Style-Type" content="text/css">
        <meta name="author" description="Richard Milne (RichMilne AT users DOT noreply DOT github DOT com">
        <meta name="version" description="134">
        <meta name="creation" description="2023-02-01 22:19:28">
        <meta name="host" description="http://www.worldofspectrum.org/infoseekid.cgi?id=0008967">
        <title>White Lightning Documentation - Manual</title>
        <style type="text/css">
        <!--
        * {font-family: "Consolas", monospace;
           font-size: 11}
        -->
        </style>
   </head>
   <body>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>WHITE LIGHTNING</b><br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>by OASIS SOFTWARE</b><br/>
<br/>
<br/>
<br/>
<b>Copyright Notice</b><br/>
<br/>
Copyright &#169; 1984 by Oasis Software. &nbsp;No part of this manual may be<br/>
reproduced on any media without prior written permission from Oasis<br/>
Software.<br/>
<br/>
<br/>
<br/>
<b>This Manual</b><br/>
<br/>
Piracy has reached epidemic proportions and it is with regret that we are<br/>
forced to reproduce this manual in a form which cannot be photocopied. &nbsp;Our<br/>
apologies for the inconvenience this may cause to our genuine customers. &nbsp;A<br/>
reward will be paid for information leading to the successful prosecution<br/>
of parties infringing this Copyright Notice.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>Copyright &#169; by Oasis Software</b>
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>CONTENTS</b><br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>Page</b><br/>
<br/>
<b>INTRODUCTION</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>1</b><br/>
<br/>
<b>OPERATING INSTRUCTIONS</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>3</b><br/>
<br/>
<b>SPRITE GENERATOR PROGRAM</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>4</b><br/>
&nbsp; &nbsp; Introduction &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>4</b><br/>
&nbsp; &nbsp; Operating Instructions &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>6</b><br/>
&nbsp; &nbsp; Getting Familiar with the Function Keys &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>6</b><br/>
<br/>
<b>SPECTRA FORTH</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>18</b><br/>
&nbsp; &nbsp; Introduction &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>19</b><br/>
&nbsp; &nbsp; Input/Output Operators &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>19</b><br/>
&nbsp; &nbsp; Mathematical Operators &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>21</b><br/>
&nbsp; &nbsp; Stack Operations &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>24</b><br/>
&nbsp; &nbsp; Other Operations &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>25</b><br/>
&nbsp; &nbsp; Colon Definitions &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>26</b><br/>
&nbsp; &nbsp; Control Structures &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>27</b><br/>
&nbsp; &nbsp; Conditional Branching &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>28</b><br/>
&nbsp; &nbsp; Constants and Variables &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>32</b><br/>
&nbsp; &nbsp; Other Commonly Used Forth Words &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>32</b><br/>
&nbsp; &nbsp; Using the Editor &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>33</b><br/>
&nbsp; &nbsp; Forth Error Messages &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>35</b><br/>
<br/>
<b>IDEAL</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>38</b><br/>
&nbsp; &nbsp; Introduction &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>38</b><br/>
&nbsp; &nbsp; IDEAL Variables &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>40</b><br/>
&nbsp; &nbsp; Errors &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>42</b><br/>
&nbsp; &nbsp; Sprite Buffer Organisation &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>42</b><br/>
&nbsp; &nbsp; Loading Sprites from Tape &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>43</b><br/>
&nbsp; &nbsp; The Buffer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>43</b><br/>
&nbsp; &nbsp; Background Scrolling &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>43</b><br/>
&nbsp; &nbsp; IDEAL Mnemonics &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>44</b><br/>
&nbsp; &nbsp; General Points &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>45</b><br/>
&nbsp; &nbsp; Sprite Utilities &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>48</b><br/>
&nbsp; &nbsp; Scrolling &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>52</b><br/>
&nbsp; &nbsp; GETs and PUTs &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>55</b><br/>
&nbsp; &nbsp; Sprite Transformations &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>59</b><br/>
&nbsp; &nbsp; Interrupt Related Words &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>61</b><br/>
&nbsp; &nbsp; BASIC Interface Words &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>62</b><br/>
&nbsp; &nbsp; Miscellaneous Words &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>62</b><br/>
&nbsp; &nbsp; Forth/BASIC Words &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>66</b><br/>
&nbsp; &nbsp; Foreground/Background &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>67</b><br/>
&nbsp; &nbsp; Logical Operations &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>71</b><br/>
&nbsp; &nbsp; Collision Detection and Sprite Recognition &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>73</b><br/>
&nbsp; &nbsp; The BASIC Interface &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>76</b><br/>
&nbsp; &nbsp; Program Development &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>79</b><br/>
&nbsp; &nbsp; Table of Screen Addresses &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>82</b><br/>
&nbsp; &nbsp; Function Key Summary &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>83</b><br/>
&nbsp; &nbsp; Arcade Graphics Library &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>89</b><br/>
&nbsp; &nbsp; Demo Sprite Library &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>89</b>
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>Page</b><br/>
<br/>
<b>FIG-FORTH GLOSSARY</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>91</b><br/>
<br/>
<b>IDEAL GLOSSARY</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>119</b><br/>
<br/>
<b>FORTH/BASIC GLOSSARY</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>124</b><br/>
<br/>
<b>USR CALLS</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>125</b><br/>
<br/>
<b>EXTENDED SPECTRA FORTH GLOSSARY</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>125</b><br/>
<br/>
<b>THE DEMO - A BRIEF DESCRIPTION</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>126</b><br/>
<br/>
<b>SOME SIMPLE PROGRAMMING EXAMPLES</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>129</b>
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>WHITE LIGHTNING</b><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>by Oasis Software</b><br/>
<br/>
<br/>
<b>INTRODUCTION</b><br/>
<br/>
White Lightning is a high level graphics development system for the Spectrum 48k.<br/>
It is aimed primarily at the user who has commercial games writing in mind and has<br/>
the patience to learn a sizeable new language. &nbsp;It is not a games designer and<br/>
stunning results probably won't be produced overnight, but it does have the power<br/>
and flexibility to produce software of a commercial standard (with a little<br/>
perseverance!). &nbsp;Software produced using White Lightning can be marketed without<br/>
restriction, although, we would be very grateful if you felt you could pop a small<br/>
credit on the sleeve. &nbsp;If you're looking for a publisher - don't forget us!<br/>
<br/>
Assembly language has three advantages over high level languages: &nbsp;speed,<br/>
flexibility and compactness. &nbsp;During the running of an arcade game, the processor<br/>
spends most of its time manipulating screen data, and if the appropriate commands<br/>
are implemented in the language, the execution "overhead" is very small. &nbsp;Add to<br/>
this the fact that considerable time has been spent on the routines themselves to<br/>
optimise execution speed, and we feel most machine code programmers would be hard<br/>
pressed to better White Lightning for speed. &nbsp;As far as flexibility is concerned,<br/>
White Lightning has almost 300 commands as well as access to BASIC and machine<br/>
language if required. &nbsp;A lot of the tricky routines like rotations and<br/>
enlargements are already implemented for you. &nbsp;As far as compactness goes, Forth<br/>
itself produces very compact code, but there is, of course, the overhead of the<br/>
language itself. &nbsp;Assembly language has four major drawbacks. &nbsp;Firstly, you've got<br/>
to learn it. &nbsp;Having mastered machine code, program development is very slow<br/>
compared with a typical high level language, there is no "crash protection"<br/>
whatsoever, and to produce effective results, you need a fairly intimate knowledge<br/>
of the machine you're working with.<br/>
<br/>
BASIC has several points in its favour, these are: excellent crash protection,<br/>
extremely readable source code and a relatively short learning curve. &nbsp;These<br/>
features make BASIC a very good introduction to programming for the hobbyist, but<br/>
for the serious games writer, the language is insufficient in terms of both its<br/>
speed and flexibility.<br/>
<br/>
Because White Lightning is Forth based it has virtually the speed of machine code,<br/>
no knowledge of the machine is required, the source code is relatively readable,<br/>
and it is fairly well protected from crashing.<br/>
<br/>
If you do have any queries concerning White Lightning, then we can be contacted by<br/>
phone on (0934) 419921. &nbsp;If possible, please restrict calls to the periods 9 am to<br/>
11 am or 6 pm to 6.30 pm. &nbsp;If this is not convenient we are here all day. &nbsp;If your<br/>
query is a detailed one then it's probably better to write in. &nbsp;We are also<br/>
interested to hear of any extensions or routines you may develop, and if<br/>
sufficient interest is shown we will start a News Letter, and possibly, even a<br/>
User Group.<br/>
<br/>
<br/>
<b>SPRITE DEVELOPMENT</b><br/>
<br/>
Included with White Lightning is a sprite generator. This comes complete with a<br/>
pre-defined character set which, when suitably combined, makes up to 167 full<br/>
characters. The predefined characters cover Asteroids, Pac-Man, Scramble,<br/>
Defender, Space Invaders, City Bomber, Lunar Lander, Frogger, Centipede, Donkey<br/>
Kong and many more. You can use them as they are, customise them, or design up to<br/>
255 of your own sprites. The development software allows you to reflect, spin or<br/>
invert. When you have finished work, or between sessions the whole lot can be<br/>
simply saved to tape.<br/>
<br/>
<br/>
<br/>
1
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>IDEAL</b><br/>
<br/>
The main part of the package is the White Lightning language itself. The language<br/>
can be thought of as being divided into two parts: firstly, there is a super fast<br/>
integer Forth, which conforms to a standard Fig-Forth, but secondly, and of most<br/>
importance to games designers, there is the IDEAL sub-language. IDEAL stands for<br/>
"Interrupt Driven Extendable Animation Language". &nbsp;IDEAL has a dictionary of over<br/>
100 words, which can be freely mixed with Forth, or, as we shall see, can be<br/>
accessed from BASIC.<br/>
<br/>
<br/>
<b>Interrupt Driven</b><br/>
<br/>
Forth/IDEAL words can be executed under interrupt; this means that programs can be<br/>
run in foreground and background at the same time. Suppose, for instance, the<br/>
program you are writing involves a scrolling backdrop, which has been defined in a<br/>
sprite 6 screens wide. A program can be run in background to handle the scrolling<br/>
backdrop, and a separate program written in foreground to control all of the<br/>
characters which move within the backdrop. This will free the user from complex<br/>
timing calculations to get a smooth scroll and is one of the most powerful<br/>
features of the entire package. &nbsp;Background words can be executed up to 50 times a<br/>
second.<br/>
<br/>
<br/>
<b>Extendable</b><br/>
<br/>
Forth is extendable and was chosen as the most suitable host language for IDEAL<br/>
because of this extremely useful feature. New words can be defined in terms of any<br/>
of the Forth/IDEAL words, or your own previously defined words. This means you can<br/>
create diagonal scrolls for instance, by combining individual scrolls.<br/>
<br/>
<br/>
<b>Animation Language</b><br/>
<br/>
Very careful planning went into the designing of the IDEAL animation language, to<br/>
make it as portable as possible between micros. If you've written a very<br/>
successful program for one micro, you can move the same code across without too<br/>
much difficulty. The only major changes necessary, are changes to accommodate the<br/>
different screen formats, ie the number of columns and rows. &nbsp;You don't need to<br/>
worry about the complexities of various memory mappings, IDEAL does that for you.<br/>
Some implementations will not allow attributes to be moved separately from pixel<br/>
data, so to be certain of higher portability, move attributes and data together.<br/>
<br/>
<br/>
<b>ACCESS FROM BASIC</b><br/>
<br/>
If you are not familiar with Forth and want to get reasonable software quickly,<br/>
you can access the IDEAL language from BASIC. Programs will no longer be portable<br/>
and you won't get quite the same speed and polish, but perfectly good programs<br/>
can, and have, been written this way. More memory will be used for BASIC source,<br/>
so bear all this in mind before deciding to put off learning Forth! &nbsp;Most of the<br/>
useful BASIC commands that handle sound and graphics, such as DRAW, CIRCLE, BEEP<br/>
and so on, have been implemented in Spectra Forth. Whenever possible, call them<br/>
from Forth and not BASIC. The interpretation and initial floating point<br/>
manipulation of BASIC commands are avoided, and commands will therefore execute<br/>
more rapidly from Forth.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>OPERATING INSTRUCTIONS</b><br/>
<br/>
1) &nbsp;Rewind the tape marked "White Lightning". &nbsp;Disconnect Interface<br/>
&nbsp; &nbsp; 1 if fitted.<br/>
<br/>
2) &nbsp;Load using LOAD"" then stop the tape. &nbsp;White Lightning will auto-run.<br/>
<br/>
3) &nbsp;Once loaded, you will get the prompt LOAD SPRITES Y/N.<br/>
<br/>
4) &nbsp;If it's the first time you've used the package, type Y to load the<br/>
&nbsp; &nbsp; demonstration sprites, which will follow directly after White Lightning on<br/>
&nbsp; &nbsp; the same tape. &nbsp;There is a section of data before the sprites which doesn't<br/>
&nbsp; &nbsp; load, but don't worry about this, this is information used by the sprite<br/>
&nbsp; &nbsp; development package. &nbsp;Once loaded, the LOAD SOURCE Y/N prompt will appear.<br/>
&nbsp; &nbsp; Press N to enter White Lightning or, if you wish to load some source code<br/>
&nbsp; &nbsp; place the appropriate cassette in the recorder, press PLAY and then type Y.<br/>
<br/>
5) &nbsp;To RUN the demonstrations, just LOAD using LOAD"" and the program will<br/>
&nbsp; &nbsp; auto-run.<br/>
<br/>
6) &nbsp;To RUN the Sprite Development Software just type LOAD"" and again the<br/>
&nbsp; &nbsp; program will auto-run.<br/>
<br/>
<br/>
<b>TO THE NEWCOMER</b><br/>
<br/>
When you have run the demonstration tape and have seen what can be done, this may<br/>
give you the incentive to learn all you can to produce full specification games<br/>
for yourself. &nbsp;The author of this manual knew nothing of White Lightning before<br/>
starting this project, but can promise you that after only a few hours of<br/>
experimentation, became fairly adept and had the confidence to want to go further.<br/>
It may all look a little complicated at first, but please be assured, that after a<br/>
short time, and only a little effort, the fog really does clear!<br/>
<br/>
Mike Butler.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
3
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>SECTION 1</b><br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>THE SPRITE GENERATOR PROGRAM</b><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>by Paul Newnham</b><br/>
<br/>
<br/>
<b>INTRODUCTION</b><br/>
<br/>
The Sprite Generator Program was developed to complement the White Lightning<br/>
language. &nbsp;The language is comprised of commands for manipulating sprites and<br/>
screen data but does not have the facility to directly design graphics characters.<br/>
This means there are two phases to games creation. &nbsp;The first involves designing<br/>
and editing your graphics characters with the sprite generator program, and the<br/>
second involves the writing of the game itself using the White Lightning language.<br/>
In practice the two areas of work will probably be carried out simultaneously.<br/>
For those of you who are not artistically inclined, there are two sets of<br/>
previously defined graphics characters ready to use.<br/>
<br/>
<b>The Arcade Character Set</b><br/>
<br/>
The arcade character set is an integral part of the sprite generator program - 167<br/>
characters are provided in all. &nbsp;To see these, LOAD and run DEMO B using LOAD "".<br/>
The demo will auto-run. &nbsp;This will tell you which characters can be called up by<br/>
which number, using Function Key Z. &nbsp;These characters are summarised as the<br/>
penultimate part of this section.<br/>
<br/>
<b>The Demonstration Sprites</b><br/>
<br/>
Directly after White Lightning on side A you will find the demonstration sprites.<br/>
By running the tape past White Lightning and using the LOAD SPRITES FROM TAPE<br/>
facility, these can be loaded and edited for your own use. &nbsp;The various sprites<br/>
are tabulated at the end of this section.<br/>
<br/>
<br/>
<b>USING SPRITES WITH WHITE LIGHTNING</b><br/>
<br/>
Once you have completed an editing session, the sprites generated should be saved<br/>
to tape for further editing sessions, or for use with the White Lightning language<br/>
itself. &nbsp;To load your sprites into White Lightning:<br/>
<br/>
1. &nbsp; Load White Lightning using LOAD ""<br/>
<br/>
2. &nbsp; Insert the tape containing your sprites into the tape recorder and press Y in<br/>
response to the "LOAD SPRITES Y/N" prompt. The sprites will be loaded at the<br/>
address from which they were saved using the sprite generator program.<br/>
<br/>
<br/>
<b>COLD START</b><br/>
<br/>
If you enter the sprite generator program via a COLD start, then all sprites<br/>
previously stored will be cleared and all system variables reset. &nbsp;If, for<br/>
instance, you wish to use the demonstration sprites, you would enter via a COLD<br/>
start. &nbsp;The program must always be initially entered via a COLD start.<br/>
<br/>
<br/>
<b>WARM START</b><br/>
<br/>
If you enter the program via a WARM start then all sprites will be conserved and<br/>
all system variables left unchanged. &nbsp;It is provided principally for re-entering<br/>
the program after an accidental BREAK or ERROR. &nbsp;If you do accidentally BREAK;<br/>
type: GOTO 3 and then enter via the WARM start.<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>BUFFER SIZE</b><br/>
<br/>
When White Lightning runs programs in Background mode (see Section 3) the top end<br/>
of memory is used as a scratch pad. &nbsp;The size of this area depends on the<br/>
operation of the program and calculating the amount you need to reserve is covered<br/>
in Section 3. &nbsp;When the sprite generator program is entered the buffer has a<br/>
default size of 256 bytes. &nbsp;This is probably much larger than required, but until<br/>
you are familiar with the package or need to save a few extra bytes, just leave<br/>
the buffer at 256 bytes.<br/>
<br/>
<br/>
<b>THE CHR$ SQR</b><br/>
<br/>
CHR$ SQR is the abbreviation used throughout this text for character square, and<br/>
refers to the 8 by 8 grid to the left of the sprite screen. &nbsp;This is the area used<br/>
to create and edit sprites one character at a time.<br/>
<br/>
<br/>
<b>THE SPRITE SCREEN</b><br/>
<br/>
This is the area of screen 15 characters by 15 characters on which sprites are<br/>
created, developed, transformed and generally worked on.<br/>
<br/>
<br/>
<b>THE CHR$ SQR CURSOR</b><br/>
<br/>
This is the non-destructive flashing cursor which is used to design and edit the<br/>
character currently held in the CHR$ SQR.<br/>
<br/>
<br/>
<b>THE SPRITE SCREEN CURSORS</b><br/>
<br/>
These are the two flashing cursors displayed in the row beneath the sprite screen<br/>
and the column to the right of the sprite screen. &nbsp;They are used to indicate the<br/>
position of the top left hand corner of the screen window currently being operated<br/>
upon. &nbsp;The actual cursor positions are measured from the top left hand corner of<br/>
the sprite screen and are displayed in real time on the screen as X POS (column)<br/>
and Y POS (row). &nbsp;Top left is X POS 1 Y POS 1. Bottom right is X POS F Y POS F.<br/>
<br/>
<br/>
<b>SCREEN WINDOWS</b><br/>
<br/>
The area of the screen currently being worked on is referred to as the screen<br/>
window. &nbsp;Its position is defined by X POS and Y POS, which correspond to the<br/>
positions of the sprite screen cursors, and its dimensions are defined by SPRITE<br/>
HEIGHT and SPRITE LENGTH. &nbsp;To see the screen window you are currently working on<br/>
just press F. &nbsp;The window will flash.<br/>
<br/>
<br/>
<b>SPRITE LIBRARY</b><br/>
<br/>
This refers to the set of sprites you are currently working with and can contain<br/>
up to 255 sprites or use 12500 bytes. &nbsp;If your sprite library needs more than<br/>
12500 bytes you can use the merging procedure detailed in section 3 to load and<br/>
merge more than one sprite library into White Lightning.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
5
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>OPERATING INSTRUCTIONS</b><br/>
<br/>
Insert the Sprite Generator Program Tape, type LOAD"" and load into the computer<br/>
as normal.<br/>
<br/>
Once loaded, the program will auto-run and the screen message "COLD OR WARM<br/>
START" will appear. &nbsp;If this is the first execution of the program or if you wish<br/>
to clear the sprite memory, press C for a COLD START.<br/>
<br/>
A further screen message will now appear asking if you wish to change the buffer<br/>
size - this has a default value of 256 bytes. &nbsp;For now, press N. &nbsp;This function<br/>
will become more apparent later.<br/>
<br/>
<b>NOTES:</b><br/>
<br/>
1. A WARM START will not destroy any sprites already in memory and if ever the<br/>
program is accidentally caused to BREAK, type GOTO 3 and in response to the screen<br/>
prompt, execute a WARM START.<br/>
<br/>
2. A COLD START will destroy any and all sprites defined in memory.<br/>
<br/>
3. WARM STARTs can only be executed after an initial COLD START.<br/>
<br/>
<br/>
<b>GETTING FAMILIAR WITH THE FUNCTION KEYS</b><br/>
<br/>
Now let's get familiar with some of the Function Keys - a full list will be found<br/>
at the end of this section.<br/>
<br/>
<br/>
<b>THE CHR$ SQR</b><br/>
<br/>
This is the grid square on which you create and edit characters for your own<br/>
sprite library. &nbsp;To move the cursor:<br/>
<br/>
1. &nbsp;Press the 5 key for each movement to the left.<br/>
<br/>
2. &nbsp;Press the 6 key for each movement downward.<br/>
<br/>
3. &nbsp;Press the 7 key for each movement upward.<br/>
<br/>
4. &nbsp;Press the 8 key for each movement to the right.<br/>
<br/>
Now that you know how to move the cursor, let's fill in a few squares:<br/>
<br/>
1. &nbsp;Move the cursor to any square that you like and release the keys.<br/>
<br/>
2. &nbsp;Press the 9 key to set the square.<br/>
<br/>
3. &nbsp;Now move the direction keys and fill in a few more squares.<br/>
<br/>
Now that we have set some squares, what about deleting a few of then? &nbsp;This is<br/>
simple:<br/>
<br/>
1. &nbsp;Move the cursor to a square that you have set and release the keys.<br/>
<br/>
2. &nbsp;Press the 0 key to clear the square.<br/>
<br/>
Now have a go at setting and clearing some squares, just to get used to it.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>The Sprite Screen Cursors</b><br/>
<br/>
Now that you're used to moving the CHR$ SQR cursor around, moving the sprite<br/>
screen cursors is a piece of cake:<br/>
<br/>
1. &nbsp;Move the X cursor by pressing SYMBOL SHIFT and the 5 or 8 key to move left or<br/>
right respectively.<br/>
<br/>
NOTE: &nbsp;If you've never been able to remember which is the X or which is<br/>
&nbsp; &nbsp; &nbsp; &nbsp;the Y movement, remember this little saying:<br/>
&nbsp; &nbsp; &nbsp; &nbsp;X is a cross - if you say it quickly it sounds like, X is across -<br/>
&nbsp; &nbsp; &nbsp; &nbsp;which it is!<br/>
<br/>
2. &nbsp;Move the Y cursor by pressing SYMBOL SHIFT and the 7 or 6 key to move up or<br/>
down respectively.<br/>
<br/>
<br/>
<b>Character Building</b><br/>
<br/>
No, not yours - building up characters to make up sprites! &nbsp;You've probably got<br/>
quite a mess in the CHR$ SQR, so let's clear it:<br/>
<br/>
1. &nbsp;Press the Q key and respond to the prompt in the text line by pressing Y and<br/>
the CHR$ SQR will clear.<br/>
<br/>
Just to get you used to a similar function, let's clear the Sprite Screen as well,<br/>
even though it's clear:<br/>
<br/>
1. &nbsp;As you can see, to clear the CHR$ SQR press Q, to clear the sprite screen<br/>
press SYMBOL SHIFT Q - cunning, eh?<br/>
<br/>
Now that we have clear screens we can start to go places. &nbsp;Have a go at this:<br/>
<br/>
1. &nbsp;Move the X and Y cursors to 1 and 1 respectively.<br/>
<br/>
2. &nbsp;Press the Z key (to call up a character from the Arcade Library) and enter the<br/>
number 63 followed by ENTER. &nbsp;A space invader type character will appear on the<br/>
sprite screen.<br/>
<br/>
3. &nbsp;Press the K key and answer Y to the prompt and hey presto - the character has<br/>
been placed in the CHR$ SQR.<br/>
<br/>
This will illustrate quite nicely how a character is built up.<br/>
<br/>
Have a go at changing this character using the 5, 6, 7 or 8 keys to move the CHR$<br/>
SQR cursor and the 9 and 0 keys to set or clear a square. &nbsp;You won't be able to<br/>
see the CHR$ SQR cursor at the moment - just press one of the cursor keys and it<br/>
will flash for you.<br/>
<br/>
<br/>
Let's GET your 'new character' into memory:<br/>
<br/>
1. &nbsp;Move the sprite screen cursors to X POS 4 and Y POS 4 (SYMBOL SHIFT 5, 6, 7,<br/>
and 8)<br/>
<br/>
2. &nbsp;Press the J key and answer Y to the question.<br/>
<br/>
3. &nbsp;Your new character was placed on the sprite screen from the CHR$ SQR by using<br/>
the J key. Your original character is still there at X POS 1 Y POS 1.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
7
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
4. &nbsp;Now press the S key to give your character a sprite number. &nbsp;For now, just<br/>
enter the number 1 and press ENTER.<br/>
<br/>
5. &nbsp;Press the G key to GET the character into memory as a sprite and answer Y to<br/>
the prompt - your character will flash to confirm.<br/>
<br/>
Now, let's prove that your character is in memory:<br/>
<br/>
1. &nbsp;Press the SYMBOL SHIFT Q to clear the sprite screen.<br/>
<br/>
2. &nbsp;Press S to tell the computer which sprite you are calling up (there is only<br/>
one at the moment of course). &nbsp;Enter 1 followed by ENTER.<br/>
<br/>
3. &nbsp;Now press P to PUT the sprite to the sprite screen and answer Y to the<br/>
question.<br/>
<br/>
4. &nbsp;Now you will be given four more options. &nbsp;Don't worry about 2, 3 and 4 for now<br/>
- we just want to place our sprite on the sprite screen. &nbsp;Press 1, and there it<br/>
is!<br/>
<br/>
You will notice that although you correctly got your own sprite PUT back to the<br/>
sprite screen, the original character from the Arcade Library wasn't. &nbsp;This<br/>
example was to show you that any actions that you call for, will only happen to<br/>
the character that the sprite screen cursors are pointing to, as we pointed out in<br/>
the Introduction.<br/>
<br/>
You will also notice that the CHR$ SQR still contains your new character - have a<br/>
look to compare.<br/>
<br/>
<br/>
We have seen how to call up a character from the Arcade Library and how, in<br/>
essence, to build up a character in the CHR$ SQR. &nbsp;There is another way to build<br/>
up a character:<br/>
<br/>
1. &nbsp;Press SYMBOL SHIFT Q to clear the sprite screen.<br/>
<br/>
2. &nbsp;Press the D key, answer Y to the question, and enter the following, very<br/>
carefully, pressing ENTER after each entry:<br/>
<br/>
&nbsp; &nbsp; a) H24 126 H9D 255 HFF 153 129 102<br/>
<br/>
3. &nbsp;Guess who's back! (You should have a space invader type character).<br/>
<br/>
This is the DIRECT DATA INPUT. &nbsp;Direct Data characters are built up from 8 bytes<br/>
of data, one byte at a time.<br/>
<br/>
NOTE: &nbsp;Data can only be entered using values in the range 0 to 255 Decimal or<br/>
&nbsp; &nbsp; &nbsp; &nbsp;H00 to HFF HEX. &nbsp;The character H must precede a HEX entry.<br/>
<br/>
<br/>
Let's do a quick review of the functions that we have used:<br/>
<br/>
1. &nbsp;CHR$ SQR - cursors, 5, 6, 7 and 8 keys to move and the 9 and 0 keys to set and<br/>
clear squares. &nbsp;The Q key clears the CHR$ SQR.<br/>
<br/>
2. &nbsp;SPRITE SCREEN - 5 and 8 to move the X cursor (X is across remember) and 6 and<br/>
7 to move the Y cursor. &nbsp;The SYMBOL SHIFT and Q keys clear the sprite screen.<br/>
<br/>
3. &nbsp;The Z key calls up the ARCADE CHARACTER LIBRARY - 1 to 167.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
4. &nbsp;The K key transfers a character from the SPRITE SCREEN to the CHR$ SQR.<br/>
<br/>
5. &nbsp;The J key transfers a character from the CHR$ SQR to the SPRITE SCREEN.<br/>
<br/>
6. &nbsp;The S key defines and subsequently calls up a particular SPRITE.<br/>
<br/>
7. &nbsp;The G key GETs your sprite into memory.<br/>
<br/>
8. &nbsp;The P key PUTs your sprite from memory onto the SPRITE SCREEN.<br/>
<br/>
9. &nbsp;The D key enables you to enter a character by DIRECT DATA to the SPRITE<br/>
SCREEN.<br/>
<br/>
You've used quite a few functions! &nbsp;Have a go at calling up some more Arcade<br/>
Characters, change them if you wish, then GET them into memory and PUT them onto<br/>
the SPRITE SCREEN.<br/>
<br/>
<br/>
<b>The Information Rectangle</b><br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>MEMORY LEFT 12486 &nbsp;X POS 4 &nbsp;Y POS 4</b><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>SPRITE 65266 &nbsp; SPRITE HEIGHT-1</b><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>SPST.. 65266 &nbsp; SPRITE LENGTH-1</b><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>SPND.. 65280 &nbsp; SPRITE NUMBER-1</b><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>The text line</b><br/>
<br/>
This is a most useful facility which can be of great service to you. &nbsp;Most of the<br/>
information is fairly obvious, but we'll run through it all:<br/>
<br/>
1. &nbsp;MEMORY LEFT, as it says, is the amount of memory available for sprites; these<br/>
are the sprites that you define and do not include the Arcade Characters - to use<br/>
these, of course, you must define them as sprites by GETting them into memory.<br/>
<br/>
2. &nbsp;X POS Y POS, these are the current positions of your SPRITE SCREEN X and Y<br/>
cursors with reference to the figures on top and to the left of the SPRITE SCREEN.<br/>
<br/>
3. &nbsp;SPRITE, this indicates the position, in memory, where your defined sprite is.<br/>
<br/>
4. &nbsp;SPST, indicates the SPrite space STart point, in memory. &nbsp;(Before any sprites<br/>
are defined this has an initial value of 65280).<br/>
<br/>
5. &nbsp;SPND, indicates the SPrite space eND point, in memory.<br/>
<br/>
6. &nbsp;SPRITE HEIGHT, indicates the height of your defined sprite, in character<br/>
squares, as indicated by the figures at the top and to the left of the SPRITE<br/>
SCREEN. &nbsp;(This has an initial value of 1).<br/>
<br/>
7. &nbsp;SPRITE LENGTH, indicates the length of your defined sprite, in character<br/>
squares, as indicated by the figures at the top and to the left of the SPRITE<br/>
SCREEN. &nbsp;(This has an initial value of 1).<br/>
<br/>
8. &nbsp;SPRITE NUMBER, indicates the sprite currently defined. &nbsp;(This has an initial<br/>
value of 1).<br/>
<br/>
9. &nbsp;The Text Line, to show the Function called up, and the available options.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
9
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>More Function Keys</b><br/>
<br/>
Let's move on. &nbsp;BREAK the program - CAPS SHIFT/BREAK keys, type GOTO 3 and press<br/>
ENTER. &nbsp;Execute a COLD (C) START and answer N to BUFFER SIZE CHANGE. &nbsp;Nothing of<br/>
what you have previously done is in memory. &nbsp;(We could have cleared all your<br/>
sprites by defining them (S key) and pressing W (WIPE SPRITE), but depending on<br/>
how many you defined whilst experimenting, it could have been a lengthy process!)<br/>
<br/>
Now have a go at this:<br/>
<br/>
1. &nbsp;Clear the sprite screen (SYMBOL SHIFT Q)<br/>
<br/>
2. &nbsp;Press X to activate the INK variable and then set it to 2.<br/>
<br/>
3. &nbsp;Press C to activate the PAPER variable and then set it to 7.<br/>
<br/>
4. &nbsp;Press B to activate the BRIGHT switch and then press 1 to switch it ON.<br/>
<br/>
5. &nbsp;Press V to activate the FLASH variable and then press 0 to switch it OFF.<br/>
<br/>
6. &nbsp;Press A to activate the ATTRIBUTE switch and then press 1 to switch it ON.<br/>
<br/>
You will have noticed, that both PAPER and FLASH were already set to 7 and 0<br/>
respectively from the COLD start; we only run through them all for completeness<br/>
and to get used to using them.<br/>
<br/>
<br/>
What you have done, is to set the attributes for the character we are about to<br/>
define, so lets do that:<br/>
<br/>
1. &nbsp;Press Z to call up the arcade characters, answer Y to the prompt, and enter<br/>
150 followed by ENTER - there you have it - a red Dalek.<br/>
<br/>
Now in order to define this character as a sprite, we reed to GET it into memory.<br/>
<br/>
1. &nbsp;Press S to set up a sprite and type 10, followed by ENTER.<br/>
<br/>
Now we'll need to set up the screen window:<br/>
<br/>
1. &nbsp;Press L to activate the sprite length variable and then press 2 followed by<br/>
ENTER. &nbsp;You will see the window flash red across the top half of the character.<br/>
<br/>
2. &nbsp;Press H to activate the SPRITE HEIGHT variable and then press 2 followed by<br/>
ENTER. &nbsp;Now you will see the new window flash.<br/>
<br/>
<br/>
Now convert this character into a sprite by GETting it into memory:<br/>
<br/>
1. &nbsp;Press G to activate the GET function and answer Y to the prompt. &nbsp;Again the<br/>
screen window will flash, confirming that the character has been GOT into memory.<br/>
<br/>
Move the sprite screen X cursor +2 (SYMBOL SHIFT 8 twice). &nbsp;Activate the PUT<br/>
function (P), respond with a Y to the prompt and press 1 to PUT your new sprite to<br/>
the screen.<br/>
<br/>
<br/>
Now we're going to mirror this second character and GET it into memory as another<br/>
sprite but with different attributes:<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 10
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
1. &nbsp;Press E (Screen Functions), answer Y and press 2 (Mirror) - the character is<br/>
reflected!<br/>
<br/>
2. &nbsp;Now press S (Sprite Number) and enter 11.<br/>
<br/>
3. &nbsp;Press G (GET) and then Y - again it flashes to confirm.<br/>
<br/>
<br/>
We now have two sprites, one facing left and one facing right. &nbsp;Let's set some new<br/>
attributes.<br/>
<br/>
1. &nbsp;Press X (INK) and enter 4 (green).<br/>
<br/>
2. &nbsp;Press I to activate the Attribute Dump facility.<br/>
<br/>
3. &nbsp;Move the sprite screen X cursor 1 place to the right and press I again - the<br/>
top half is done!<br/>
<br/>
4. &nbsp;Move the sprite screen Y cursor 1 place down and press I.<br/>
<br/>
5. &nbsp;Finally, move the sprite screen cursor one place to the left and press I again<br/>
- there you have it, a red character to the left and a green one to the right.<br/>
<br/>
<br/>
If you want to swap the colours the other way around - yes you're right this can<br/>
be done:<br/>
<br/>
1. &nbsp;Position the sprite screen cursors to X POS 1 Y POS 1.<br/>
<br/>
2. &nbsp;We will have to set up the screen window for the exchange:<br/>
<br/>
Press L (Length Variable) and enter 4 - the window will flash.<br/>
<br/>
3. &nbsp;Press E (Screen Functions), answer Y to the prompt and press 3 to MIRROR<br/>
ATIRIBUTES - watch the screen as you press 3, it happens very quickly! &nbsp;The red<br/>
Dalek becomes green and the green Dalek becomes red.<br/>
<br/>
<br/>
Right then - we'll move on a little. &nbsp;We'll consider some sprite operations.<br/>
These are operations which take place in memory on the stored sprites. &nbsp;We'll<br/>
begin by setting up a new sprite comprising two arcade characters and then go on<br/>
to change their positions in the sprite in memory. Have a go at this:<br/>
<br/>
1. &nbsp;Clear the sprite screen (SYMBOL SHIFT Q). &nbsp;Don't worry about your previous<br/>
characters - you'll probably remember that they are still in memory as sprites 10<br/>
and ll.<br/>
<br/>
2. &nbsp;Make sure that the sprite screen cursors are set to X POS 1 Y POS 1.<br/>
<br/>
3. &nbsp;Set INK (X) to 6 (yellow).<br/>
<br/>
4. &nbsp;Set PAPER (C) to 0.<br/>
<br/>
5. &nbsp;Set FLASH (V) to 0.<br/>
<br/>
6. &nbsp;Set BRIGHT (B) to 1.<br/>
<br/>
7. &nbsp;Set ATTR (A) to 1.<br/>
<br/>
8. &nbsp;Press Z (Arcade Character) and enter 149 (a Robot).<br/>
<br/>
<br/>
<br/>
<br/>
11
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
9. &nbsp;Move the sprite screen X cursor by +2.<br/>
<br/>
10. Change the INK (X) to 4 (green).<br/>
<br/>
ll. Press Z (Arcade Character) and enter 151 (another Robot).<br/>
<br/>
<br/>
OK, you should have two robots on the sprite screen - let's define them as a<br/>
combined sprite:<br/>
<br/>
1. &nbsp;Move the cursors to X POS 1 Y POS 1.<br/>
<br/>
2. &nbsp;Press L (Length Variable) and set to 4.<br/>
<br/>
3. &nbsp;Press H (Height Variable) and set to 2.<br/>
<br/>
4. &nbsp;Press S (Sprite Number) and enter 12.<br/>
<br/>
5. &nbsp;Press G (GET Function) and respond to the prompt with Y.<br/>
<br/>
<br/>
We have now set up a 4 by 2 sprite containing both characters. Now let's change<br/>
them over in memory:<br/>
<br/>
1. &nbsp;Press M (Sprite Memory Functions), respond to the prompt with Y, and press 2<br/>
(MIRROR) - nothing happens on the sprite screen - this is a memory function.<br/>
<br/>
Let's prove that the sprite has been altered:<br/>
<br/>
1. &nbsp;Move the sprite screen Y cursor by +3.<br/>
<br/>
2. &nbsp;Press P (PUT) respond to the prompt with Y and press 1 - the sprite has been<br/>
reflected.<br/>
<br/>
<br/>
We can return the attributes to their former Robots quite easily:<br/>
<br/>
1. &nbsp;Press M (Sprite Memory Functions), respond to the prompt with Y, and press 3<br/>
(Mirror Attributes).<br/>
<br/>
2. &nbsp;Move the Y cursor by +3 and press P (PUT), respond to the prompt with Y and<br/>
press 1 - now the attributes have mirrored.<br/>
<br/>
<br/>
Let's move on a little further now. &nbsp;We now look at a second sprite transformation<br/>
- rotation. &nbsp;Try the following:<br/>
<br/>
1. &nbsp;Clear the sprite screen and set the X and Y cursors to X POS 1 Y POS 1.<br/>
<br/>
2. &nbsp;Set INK (X) to 1 (blue).<br/>
<br/>
3. &nbsp;Set PAPER (C) to 7 (white).<br/>
<br/>
4. &nbsp;Set FLASH (V) to 0.<br/>
<br/>
5. &nbsp;Set BRIGHT (B) to 1.<br/>
<br/>
6. &nbsp;Set ATTR (A) to 1.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 12
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
7. &nbsp;Press Z (Arcade Character) and enter 151 (a Robot).<br/>
<br/>
8. &nbsp;Set HEIGHT (H) to 2 and LENGTH (L) to 2.<br/>
<br/>
9. &nbsp;Set the Sprite Number (S) to 13, then press G to GET the character as a<br/>
sprite.<br/>
<br/>
10. Move the X cursor by +2.<br/>
<br/>
11. Press R (ROTATE), and enter the new sprite number, 14.<br/>
<br/>
12. Press P (PUT) and press 1 - a Robot rotated by 90 degrees!<br/>
<br/>
Now that we have sprite 14 as a 90 degree rotation of sprite 13, why not go a<br/>
little further ? Try this:<br/>
<br/>
<br/>
1. &nbsp;Move the X cursor by +2.<br/>
<br/>
2. &nbsp;Press R (ROTATE) and enter the new sprite number, 15.<br/>
<br/>
3. &nbsp;Press P (PUT) and press 1 - this new robot has been rotated by 180 degrees<br/>
from its original orientation.<br/>
<br/>
To produce the final (270 degree) orientation:<br/>
<br/>
1. &nbsp;Move the X cursor by +2.<br/>
<br/>
2. &nbsp;Press R (ROTATE) and enter the new sprite number, 16.<br/>
<br/>
3. &nbsp;Press P (PUT) and press 1 - this has produced the final orientation.<br/>
<br/>
<br/>
Now let's look at attribute handling in more detail - clear the sprite screen and<br/>
position the X and Y cursors to X POS 1 Y POS 1. &nbsp;The following two examples will<br/>
show how to download and pick-up attributes between the attribute variables and<br/>
the sprite screen:<br/>
<br/>
1. &nbsp;Press X (INK) and set to 3 (magenta).<br/>
<br/>
2. &nbsp;Press C (PAPER) and set to 2 (red).<br/>
<br/>
3. &nbsp;Press V (FLASH) and set to 1 (ON).<br/>
<br/>
4. &nbsp;Press B (BRIGHT) and set to 0 (OFF).<br/>
<br/>
5. &nbsp;Press A (ATTR) and set to 0.<br/>
<br/>
6. &nbsp;Press I (ATTRIBUTE DUMP) - the attributes will appear on the sprite screen.<br/>
<br/>
7. &nbsp;Now set all the attributes, X, C, V, B, and A to 0.<br/>
<br/>
8. &nbsp;Press U (PICK UP ATTRIBUTES) and the attributes on the screen will be loaded<br/>
into the attribute variables.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
13
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
This next example illustrates one of the more complicated functions of the<br/>
generator - GETting a sprite into a larger sprite:<br/>
<br/>
1. &nbsp;Clear the sprite screen and position the cursors to X POS 1 Y POS 1.<br/>
<br/>
2. &nbsp;Press L (Length) and enter 4, then press H (Height) and enter 4.<br/>
<br/>
3. &nbsp;Press E (Screen Functions) and press 1 (INVERT).<br/>
<br/>
4. &nbsp;Press S (Sprite Number) and enter 17, then press G (GET).<br/>
<br/>
5. &nbsp;Move the X cursor by +4.<br/>
<br/>
6. &nbsp;Press X (INK) and set to 0.<br/>
<br/>
7. &nbsp;Press C (PAPER) and set to 6 (yellow).<br/>
<br/>
8. &nbsp;Press V (FLASH) and set to 0 (OFF).<br/>
<br/>
9. &nbsp;Press B (BRIGHT) and set to 1 (ON).<br/>
<br/>
10. Press A (ATTR) and set to 1.<br/>
<br/>
11. Press Z (Arcade Character) and then enter 149.<br/>
<br/>
12. Press L (Length) and enter 2, then press H (Height) and enter 2.<br/>
<br/>
13. Press S (Sprite Number) and enter 18.<br/>
<br/>
14. Press G (GET).<br/>
<br/>
15. Press SPACE key (Place small sprite into large sprite) - enter small sprite as<br/>
18, larger sprite as 17, Row as 1, Column as 1 and BLS (1), as you get each<br/>
prompt.<br/>
<br/>
16. Move the X cursor by +2.<br/>
<br/>
17. Press P (PUT), answer the prompt with Y and then press 1 - there you have it,<br/>
your Robot inside the square.<br/>
<br/>
<br/>
Let's move on to look at some of the utility functions - Test and Wipe.<br/>
<br/>
1. &nbsp;Clear the sprite screen and position the cursors to X POS 1 Y POS 1.<br/>
<br/>
2. &nbsp;Press Z (Arcade Character) and enter 135.<br/>
<br/>
3. &nbsp;Press L (Length) and enter 2, then press H (Height) and enter 2.<br/>
<br/>
4. &nbsp;Press S (Sprite Number) and enter 19.<br/>
<br/>
5. &nbsp;Press G (GET).<br/>
<br/>
6. &nbsp;Press L (Length) and enter 10, then press H (Height) and enter 10.<br/>
<br/>
7. &nbsp;Clear the sprite screen.<br/>
<br/>
8. &nbsp;Press T (Test Sprite) and note that the information rectangle contains the<br/>
following:<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 14
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
&nbsp; &nbsp; A) &nbsp;SPRITE HEIGHT = 2<br/>
&nbsp; &nbsp; B) &nbsp;SPRITE LENGTH = 2<br/>
&nbsp; &nbsp; C) &nbsp;SPRITE NUMBER = 19<br/>
&nbsp; &nbsp; D) &nbsp;MEMORY LEFT &nbsp; = The remaining memory for sprites.<br/>
&nbsp; &nbsp; E) &nbsp;SPRITE &nbsp; &nbsp; &nbsp; &nbsp;= Start address of sprite being tested.<br/>
<br/>
<br/>
A function is provided to Wipe a sprite from memory and adjust pointers. &nbsp;Leave<br/>
everything as it is and try:<br/>
<br/>
1. &nbsp;Press W (Wipe sprite) - remember sprite 19 has already been defined. &nbsp;Respond<br/>
to the prompt with Y.<br/>
<br/>
2. &nbsp;Press T (Test sprite) and an error message will appear on the text line -<br/>
SPRITE NO LONGER EXISTS<br/>
<br/>
<br/>
While we are considering error messages, have a go at this:<br/>
<br/>
1. &nbsp;Press Z (Arcade Character) and then press 63.<br/>
<br/>
2. &nbsp;Press S (Sprite Number) and press 12 - an error message will appear, SPRITE<br/>
ALREADY DEFINED. &nbsp;Sprite number 12 is not corrupted in any way, nor is the one you<br/>
have put to the screen. &nbsp;All that you need to do is choose a different sprite<br/>
number which has not already been allocated.<br/>
<br/>
<br/>
There's one area we've been avoiding all the way through - the Logic Functions.<br/>
We don't want to wade into the depths of Boolean algebra here, but instead,<br/>
provide a few examples which hopefully show the application of the XOR, OR and<br/>
AND operations to this part of the package. &nbsp;They are provided for advanced<br/>
applications only and their results are summarised on the sprite generator panel.<br/>
Let's see what they do:<br/>
<br/>
1. &nbsp;Clear the sprite screen and position the cursors to X POS 1 Y POS 1.<br/>
<br/>
2. &nbsp;Press X (INK) and set to 3 (magenta).<br/>
<br/>
3. &nbsp;Press C (PAPPR) and set to 0 (black).<br/>
<br/>
4. &nbsp;Press V (FLASH) and set to 0.<br/>
<br/>
5. &nbsp;Press B (BRIGHT) and set to 1.<br/>
<br/>
6. &nbsp;Press A (ATTR) and set to 1.<br/>
<br/>
7. &nbsp;Press Z (Arcade Character) and enter 149 (Robot).<br/>
<br/>
8. &nbsp;Press L (Length) and enter 2, then press H (Height) and enter 2.<br/>
<br/>
9. &nbsp;Press S (Sprite Number) and enter 21, then G (GET) to Get the sprite.<br/>
<br/>
10. Move the X cursor by +2.<br/>
<br/>
ll. Press P (PUT) and respond to the prompt with 1.<br/>
<br/>
12. Press Z (Arcade Character) and enter 151 (Robot).<br/>
<br/>
13. Press O (Logical Sprite Functions) and press 1.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
15
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
14. Move the X cursor by +2.<br/>
<br/>
15. Press P (PUT) and respond with 1 - the characters have been "ORed" (merged).<br/>
<br/>
<br/>
Let's take this a little further and OR with the screen:<br/>
<br/>
1. &nbsp;Clear the sprite screen and position the cursors to X POS 1 Y POS 1.<br/>
<br/>
2. &nbsp;Press X (INK) and set to 1 (blue).<br/>
<br/>
3. &nbsp;Press C (PAPER) and set to 7 (white).<br/>
<br/>
4. &nbsp;Press V (FLASH) and set to 0.<br/>
<br/>
5. &nbsp;Press B (BRIGHT) and set to 1.<br/>
<br/>
6. &nbsp;Press A (ATTR) and set to 1.<br/>
<br/>
7. &nbsp;Press Z (Arcade Character) and enter 141 (Explosion) - you probably think<br/>
we're going to blow up the Robot!<br/>
<br/>
8. &nbsp;Press L (Length) and enter 2, then press H (Height) and enter 2.<br/>
<br/>
9. &nbsp;Press S (Sprite Number) and enter 22, then G (GET) sprite 22.<br/>
<br/>
10. Move the X cursor by +2.<br/>
<br/>
11. Press Z (Arcade Character) and enter 149 (Robot).<br/>
<br/>
12. Press P (PUT) and enter 2 - sprite number 22 has been "ORed" with whatever was<br/>
on the screen.<br/>
<br/>
13. Move the X cursor by +2.<br/>
<br/>
14. Press P (PUT) and enter 1 - the explosion was unaffected!<br/>
<br/>
<br/>
Now let's take a look at a second logical operation - the AND function:<br/>
<br/>
1. &nbsp;Clear the sprite screen and position the cursors to X POS 1 Y POS 1.<br/>
<br/>
2. &nbsp;Press P (PUT) and enter 4, sprite 22 has been "ANDed" with the screen - as the<br/>
screen was empty, nothing happened.<br/>
<br/>
3. &nbsp;Press P (PUT) and enter 1 - the sprite is still there!<br/>
<br/>
<br/>
Now, lastly, let's look at the XOR function:<br/>
<br/>
1. &nbsp;Clear the sprite screen and move the cursors to X POS 1 Y POS 1.<br/>
<br/>
2. &nbsp;Press Z (Arcade Character) and enter 151 (Robot).<br/>
<br/>
3. &nbsp;Press P (PUT) and enter 3 - the Robot has blown up! ("At last!", I hear you<br/>
say!)<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 16
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
Now one of the interesting properties of the logical XOR, is that if the operation<br/>
is repeated, the original character is restored - to mend the Robot:<br/>
<br/>
1. &nbsp;Press P (PUT) and enter 3 - a fully restored Robot!<br/>
<br/>
<br/>
Well, there you have it. &nbsp;In fact, the only functions remaining that have not been<br/>
covered by an example are:<br/>
<br/>
1. &nbsp;Relocate Sprites &nbsp;( &lt; (SYMBOL SHIFT R) ).<br/>
<br/>
2. &nbsp;Save sprites to Tape ( NOT (SYMBOL SHIFT S) ).<br/>
<br/>
3. &nbsp;Load Sprites from Tape ( - (SYMBOL SHIFT J) ).<br/>
<br/>
The "Relocate Sprites" does simply that, it relocates sprites in memory. &nbsp;Just<br/>
enter a relocation length - positive to move sprites to higher memory and negative<br/>
to move sprites to lower memory. &nbsp;This function is not often used in fact and<br/>
should be used with great care!<br/>
<br/>
The "Save Sprites" function is very straight forward - just follow the screen<br/>
instructions. &nbsp;After the sprites have been saved you will be asked to rewind the<br/>
tape to verify the saved data.<br/>
<br/>
The "Load Sprites" function is similar to the above - just follow the screen<br/>
instructions.<br/>
<br/>
It should be noted that whenever sprites are saved or loaded, there are 3 distinct<br/>
sets of data which the generator stores and retrieves.<br/>
<br/>
<br/>
<b>CONCLUSIONS</b><br/>
<br/>
Well, there's nothing to stop you now! &nbsp;Going through the examples will help you<br/>
to familiarise yourself with all of the Function Keys. &nbsp;It won't be long before<br/>
you'll be happy to press on by yourself - happy sprite generating!<br/>
<br/>
The thing to do now, is to press on with Spectra Forth and IDEAL, these really are<br/>
not as frightening as they may first appear - after seeing the demo program, what<br/>
more incentive do you need!<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
17
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>SECTION 2</b><br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>SPECTRA FORTH</b><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>by Stuart Smith</b><br/>
<br/>
<br/>
Forth is an extraordinary computer language developed originally for the control<br/>
of radio telescopes, by an American named Charles Moore.<br/>
<br/>
Forth is neither an interpreter nor a compiler, but combines the best features of<br/>
both to produce a super-fast, high level language, incorporating the facilities<br/>
offered by an interactive interpreter and the speed of execution close to that of<br/>
machine-code. &nbsp;In order to achieve these fantastic speeds, Forth employs the use<br/>
of a data, or computation stack, on which to hold the data or the operations to be<br/>
performed, coupled with the use of Reverse Polish Notation (RPN). &nbsp;This may be<br/>
quite a mouthful, but RPN is very easy to use and understand with only a little<br/>
practice - in fact, Hewlett Packard use RPN on many of their calculators.<br/>
<br/>
All standard Forths use integer arithmetic for their operations and can handle up<br/>
to 32 bit precision if required - floating point mathematics routines could be<br/>
incorporated, but with a reduction in the execution speeds of a program.<br/>
<br/>
White Lightning consists of a standard Fig-Forth model, but with over 100<br/>
extensions to the standard vocabulary of Forth words. &nbsp;There are two important<br/>
extensions to White Lightning: the first is the ability to access almost ALL of<br/>
the Spectrum's own BASIC commands, just as you would when writing a BASIC program,<br/>
and with the addition of many of the high resolution graphics commands (CIRCLE,<br/>
DRAW, etc.). &nbsp;Coupled with the incredible execution speeds of White Lightning, the<br/>
possibilities are limitless! &nbsp;The second, and possibly most important, addition is<br/>
the IDEAL sub-language.<br/>
<br/>
In addition to the basic vocabulary of White Lightning words, the user can very<br/>
easily ADD his own NEW WORDS using previously defined words, thus extending the<br/>
vocabulary and building up as complex a word as is necessary to do the task in<br/>
hand.<br/>
<br/>
Fully structured programming methods are also employed as a fundamental feature of<br/>
Forth through the use of the structured control sequences included, such as:<br/>
<br/>
IF.....ELSE.....ENDIF<br/>
DO.....UNTIL<br/>
<br/>
The standard Spectrum editor can be used to create lines of White Lightning source<br/>
code for later compilation. &nbsp;Do not allow lines to exceed 64 characters - any<br/>
characters after this are ignored. &nbsp;The standard Forth line editor is included for<br/>
compatibility with existing text. The source code is stored in memory from $CC00<br/>
onwards, and can be LOADed or SAVEd to tape as and when required. &nbsp;Once the source<br/>
code is complete, it may then be compiled into the White Lightning dictionary for<br/>
later execution.<br/>
<br/>
Included in this documentation is a glossary of Fig-Forth terms (courtesy of the<br/>
FORTH INTEREST GROUP, P.O. BOX 1105, SAN CARLOS, CA 94070).<br/>
<br/>
Spectra Forth was written by Stuart Smith, the author of the extremely successful<br/>
DRAGONFORTH, and is an enhancement of a program written by the Forth Interest<br/>
Group - to whom we offer our thanks.<br/>
<br/>
At the time of writing, floppy discs are not readily available for the Spectrum<br/>
and instructions referring to discs should be interpreted as accessing RAM.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 18
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>AN INTRODUCTION TO SPECTRA FORTH</b><br/>
<br/>
This introduction does not set out to teach Forth programming, but rather to serve<br/>
as a supplement to available texts on the subject; references include:<br/>
<br/>
'Starting Forth' by Brodie, published by Prentice Hall.<br/>
'Introduction to Forth' by Knecht, published by Prentice Hall<br/>
'Discover Forth' by Hogan, published by McGraw Hill.<br/>
<br/>
<br/>
White Lightning syntax consists of Forth words or literals, separated by spaces<br/>
and terminated by a carriage return. &nbsp;A valid name must not contain any embedded<br/>
spaces since this will be interpreted as two distinct words, and most be less than<br/>
31 characters in length. &nbsp;If a word is entered which does not exist or has been<br/>
spelt wrongly, or the number entered is not valid in the current base, then an<br/>
error message will be displayed. &nbsp;To compile and execute programs created using<br/>
the Editor type LOAD &lt;CR&gt;. &nbsp;Throughout these examples &lt;CR&gt; means 'PRESS ENTER'.<br/>
<br/>
e.g. &nbsp;-FINE &nbsp; &nbsp; will generate an error message 0 since the word does<br/>
&nbsp; &nbsp; &nbsp; not exist.<br/>
<br/>
&nbsp; &nbsp; &nbsp; HEX 17FZ &nbsp;will generate an error message 0 since Z is not valid<br/>
&nbsp; &nbsp; &nbsp; in hexadecimal base.<br/>
<br/>
Other error messages include:<br/>
<br/>
&nbsp; &nbsp; &nbsp; STACK EMPTY<br/>
&nbsp; &nbsp; &nbsp; STACK FULL<br/>
&nbsp; &nbsp; &nbsp; DICTIONARY FULL<br/>
<br/>
In order to program in white Lightning, it is necessary to define new words based<br/>
on the words already in the vocabulary. &nbsp;Values to be passed to these words are<br/>
pushed onto the stack and if required, the word will pull these values from the<br/>
stack, operate on them, and push the result onto the stack for use by another<br/>
Lightning word. &nbsp;As mentioned previously, Spectra Forth (as with all Forths) uses<br/>
Reverse Polish Notation and integer numbers, therefore no precedence of operators<br/>
is available, thus all operations are performed in the sequence in which they are<br/>
found on the stack.<br/>
<br/>
e.g. &nbsp; &nbsp;1 2 + 3 * is equivalent to 3*(1+2)<br/>
<br/>
As can be seen, in RPN, the operators are input after the numbers on which they<br/>
have to operate have been input.<br/>
<br/>
We will now discuss some of the words in greater depth.<br/>
<br/>
<br/>
<b>1. INPUT/OUTPUT Operators.</b><br/>
<br/>
<br/>
<b>EMIT</b> &nbsp; &nbsp;: &nbsp;This will take the number held on the top of the stack and display it<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;on the terminal, as its original ASCII character.<br/>
<br/>
e.g. &nbsp; &nbsp;HEX &nbsp;41 &nbsp;EMIT &nbsp;CR &nbsp;&lt;CR&gt;<br/>
<br/>
will instruct the Forth to move into hexadecimal mode, push 41H onto the stack,<br/>
and then take that number and display it on the terminal - in this example the<br/>
character displayed will be an "A". &nbsp;The actual character displayed my be any of<br/>
the recognisable ASCII characters, a graphic character, or a control code depending<br/>
on the value of the number on the stack.<br/>
<br/>
<br/>
<br/>
<br/>
19
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>EMITC</b> &nbsp; : &nbsp;As EMIT but Control characters are also dealt with.<br/>
<br/>
<br/>
<b>KEY</b> &nbsp; &nbsp; : &nbsp;This will poll the keyboard, wait for a key to be pressed and push<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the ASCII code for that key onto the stack, without displaying it on<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the terminal.<br/>
<br/>
e.g. KEY &nbsp; &nbsp; &nbsp;Press "A" on the keyboard<br/>
<br/>
will instruct the computer to wait for a key to be pressed (press the "A") and<br/>
then push the ASCII value of this key, in this case 41H (where the 'H' implies<br/>
Hexadecimal 41 ie 65 decimal) onto the top of the stack. &nbsp;In order to display this<br/>
character, try the following example:<br/>
<br/>
Type:<br/>
<br/>
KEY EMIT &lt;CR&gt;<br/>
<br/>
but be sure to hit the &lt;CR&gt; very quickly.<br/>
<br/>
Now hit any key and its ASCII value will be printed followed by OK. &nbsp;So if you<br/>
type "A" it would print "AOK". &nbsp;If you were too slow you've now got two cursors!<br/>
Ignore the top one and try again. &nbsp;This problem only occurs because when you press<br/>
&lt;CR&gt; to enter the example, it immediately executes and you've possibly still got<br/>
&lt;CR&gt; held down. &nbsp;In a normal Forth definition you won't have this problem.<br/>
<br/>
<br/>
<b>CR</b> &nbsp; &nbsp; &nbsp;: &nbsp;This will transmit a carriage return and line feed to the display.<br/>
<br/>
<br/>
<b>.</b> &nbsp; &nbsp; &nbsp; : &nbsp;Convert the number held on the stack using the current BASE and<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;print it on the screen with a trailing space.<br/>
<br/>
e.g &nbsp; Suppose the stack contains 16H and BASE is decimal (10), then . will print<br/>
22 (this is 16 + 6); if BASE were hexadecimal (16), then . would print 16.<br/>
<br/>
In order to see this Working we will alter the BASE and push numbers onto the<br/>
stack - remember, that just by typing in a valid number will result in it being<br/>
pushed onto the stack. &nbsp;There are two words to alter the BASE:<br/>
<br/>
<b>HEX</b> &nbsp; &nbsp; : &nbsp;Use hexadecimal base<br/>
<b>DECIMAL</b> : &nbsp;Use decimal base<br/>
<br/>
Try:<br/>
<br/>
(i) &nbsp; HEX 1F7 . &lt;CR&gt; (Where &lt;CR&gt; means press ENTER).<br/>
&nbsp; &nbsp; &nbsp; This will print 1F7<br/>
<br/>
(ii) &nbsp;DECIMAL 2048 . &lt;CR&gt;<br/>
&nbsp; &nbsp; &nbsp; This will print 2048<br/>
<br/>
(iii) DECIMAL 2048 HEX . &lt;CR&gt;<br/>
&nbsp; &nbsp; &nbsp; This will print 800, since this is the HEX equivalent, of 2048.<br/>
&nbsp; &nbsp; &nbsp; Remember that . will remove the number from the stack that it is printing.<br/>
<br/>
<br/>
<b>U.</b> &nbsp; &nbsp; &nbsp;: &nbsp;Prints the number held on the top of the stack as an unsigned number.<br/>
<br/>
e.g. &nbsp;HEX C000 U. &lt;CR&gt;<br/>
<br/>
will push C000 onto the stack and then print it.<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 20
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
If we use just . we will get a negative result.<br/>
<br/>
&nbsp; &nbsp; &nbsp; HEX C000 . &lt;CR&gt;<br/>
<br/>
will print -4000<br/>
<br/>
<br/>
<b>?</b> &nbsp; &nbsp; &nbsp; : &nbsp;Print the value contained at the address on top of the stack using the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;current base.<br/>
<br/>
Suppose the top of the stack contains FF40H, location FF40/41H contains 0014H, and<br/>
current BASE is 10 (DECIMAL), then ? will print 20 which is the decimal equivalent<br/>
of 14 Hex.<br/>
<br/>
<br/>
<b>TYPE</b> &nbsp; &nbsp;: &nbsp;This uses the top TWO numbers held on the stack and will print a<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;selected number of characters starting at a specific<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;address onto the screen. &nbsp;The top number on the stack is the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;character count and the second number is the address to<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;start at.<br/>
<br/>
e.g. &nbsp; &nbsp;HEX 6100 20 TYPE &lt;CR&gt;<br/>
(Note that 6100H is pushed onto the stack and 20H is pushed on top of it 20H =<br/>
TOP; 6100H = second). &nbsp;This will print 20H (32) ASCII characters corresponding to<br/>
the data starting at address 6100H . (Note that much of the output will be<br/>
unrecognisable unless the data contains correct ASCII codes, such as for numbers<br/>
and letters).<br/>
<br/>
<br/>
<b>DUMP</b> &nbsp; &nbsp;: &nbsp;This takes the top number on the stack and prints out 80H bytes<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;starting at this address.<br/>
<br/>
<br/>
<b>"</b> &nbsp; &nbsp; &nbsp; : &nbsp;This is used in the form ." character string " and will display<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the string contained within " " on the screen.<br/>
<br/>
e.g. &nbsp; ." THIS IS A CHARACTER STRING " &lt;CR&gt;<br/>
will put THIS IS A CHARACTER STRING on the screen. &nbsp;Note the spaces between the<br/>
string and the quotes.<br/>
<br/>
<br/>
<b>SPACE</b> &nbsp; : &nbsp;This will display a single blank/space on the screen.<br/>
<br/>
<br/>
<b>SPACES</b> &nbsp;: &nbsp;This will display n spaces on the screen, where n is the number on the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;top of the stack.<br/>
<br/>
e.g. &nbsp; &nbsp;DECIMAL 10 SPACES &lt;CR&gt;<br/>
will print 10 spaces on the screen.<br/>
<br/>
<br/>
<b>2. MATHEMATICAL OPERATORS</b><br/>
<br/>
<b>+</b> &nbsp; &nbsp; &nbsp; : &nbsp;This will add the top two numbers on the stack and leave the result<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;as a single number.<br/>
<br/>
e.g. &nbsp; &nbsp;1 2 + . &lt;CR&gt;<br/>
will print the value of 1 + 2 = 3 on the screen. &nbsp;Note that the two top numbers<br/>
are removed from the stack, being replaced by a single number - this is true of<br/>
most Forth commands, in that they remove the values which they require to use from<br/>
the stack and push the result onto the stack.<br/>
<br/>
<br/>
<br/>
21
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
For the purposes of the following examples, let us refer to the numbers on the<br/>
stack as follows:<br/>
<br/>
&nbsp;N1 &nbsp;= &nbsp;top &nbsp; &nbsp;number on stack (i.e. first to be removed)<br/>
&nbsp;N2 &nbsp;= &nbsp;second number on stack (i.e. second to be removed)<br/>
&nbsp;N3 &nbsp;= &nbsp;third &nbsp;number on stack (i.e. third to be removed)<br/>
<br/>
To demonstrate this, let us push three numbers onto the stack by typing:<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; HEX 01FA 0019 1F47 &lt;CR&gt;<br/>
<br/>
The stack will look like this:<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 1F47 &nbsp; &nbsp;Top of stack<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 0019<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 01FA<br/>
<br/>
Note that this illustrates the property of the stack, that it is, Last In First<br/>
Out or LIFO; therefore we have:<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; N1 &nbsp;= &nbsp;1F47<br/>
&nbsp; &nbsp; &nbsp; &nbsp; N2 &nbsp;= &nbsp;0019<br/>
&nbsp; &nbsp; &nbsp; &nbsp; N3 &nbsp;= &nbsp;01FA<br/>
<br/>
So if we type:<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; CR . CR . CR . CR &lt;CR&gt;<br/>
<br/>
We get &nbsp;1F47<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 19<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1FA<br/>
<br/>
We will now resume our explanation of the mathematical operators.<br/>
<br/>
<br/>
<b>-</b> &nbsp; &nbsp; &nbsp; : &nbsp;This will subtract the top number on the stack from the second number<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;on the stack and leave the result as the top number.<br/>
i.e. &nbsp; &nbsp;N1 = N2 - N1<br/>
<br/>
e.g. &nbsp; &nbsp;Decimal 7 11 - . &lt;CR&gt;<br/>
will print -4, since the stack would contain<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; N1 &nbsp; &nbsp; ll &nbsp; &nbsp;TOS (Top of stack)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; N2 &nbsp; &nbsp; &nbsp;7<br/>
<br/>
before the subtraction, and<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; N1 &nbsp; &nbsp; -4 &nbsp; &nbsp;TOS<br/>
<br/>
after the subtraction.<br/>
<br/>
<br/>
<b>* </b>&nbsp; &nbsp; &nbsp; &nbsp;: This will multiply the top two numbers on the stack and leave the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result on the top of the stack.<br/>
i.e. &nbsp; &nbsp;N1 = N1 x N2<br/>
<br/>
e.g. &nbsp; &nbsp;DECIMAL 140 20 * . &lt;CR&gt;<br/>
would print 2800<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 22
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>/</b> &nbsp; &nbsp; &nbsp; : &nbsp;This will divide the second number on the stack by the first number,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and leave the result on the top of the stack.<br/>
i.e. &nbsp; &nbsp;N1 = N2 / N1<br/>
<br/>
e.g. &nbsp; &nbsp;DECIMAL 1000 500 / . &lt;CR&gt;<br/>
will print 2<br/>
<br/>
<br/>
<b>MAX</b> &nbsp; &nbsp; : &nbsp;This will leave the greater of the top two numbers on the stack.<br/>
<br/>
e.g. &nbsp; &nbsp;371 309 MAX . &lt;CR&gt;<br/>
will print 371<br/>
<br/>
<br/>
<b>MIN</b> &nbsp; &nbsp; : &nbsp;This will leave the smaller of the two numbers on the stack.<br/>
<br/>
e.g. &nbsp; &nbsp;371 309 MIN . &lt;CR&gt;<br/>
will print 309<br/>
<br/>
<br/>
<b>ABS</b> &nbsp; &nbsp; : &nbsp;This will leave the absolute value of the top number on the stack as<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;an unsigned number.<br/>
i.e. &nbsp; &nbsp;N1 = ABS(N1)<br/>
<br/>
e.g. &nbsp; &nbsp;47 ABS . &lt;CR&gt;<br/>
will print 47<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; -47 ABS . &lt;CR&gt;<br/>
will print 47<br/>
<br/>
<br/>
<b>MINUS</b> &nbsp; : &nbsp;This will negate the top number on the stack.<br/>
i.e. &nbsp; &nbsp;N1 = -N1<br/>
<br/>
e.g. &nbsp; &nbsp;418 MINUS . &lt;CR&gt;<br/>
will print -418<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; -418 MINUS . &lt;CR&gt;<br/>
will print 418<br/>
<br/>
<br/>
<b>1+</b> &nbsp; &nbsp; &nbsp;: &nbsp;add 1 to the top number on the stack<br/>
&nbsp; &nbsp; &nbsp; &nbsp; N1 = N1 + 1<br/>
<br/>
<br/>
<b>2+</b> &nbsp; &nbsp; &nbsp;: &nbsp;add 2 to the top number an the stack<br/>
&nbsp; &nbsp; &nbsp; &nbsp; N1 = N1 + 2<br/>
<br/>
<br/>
<b>1-</b> &nbsp; &nbsp; &nbsp;: &nbsp;subtract 1 from the top number on the stack<br/>
&nbsp; &nbsp; &nbsp; &nbsp; N1 = N1 - 1<br/>
<br/>
<br/>
<b>2-</b> &nbsp; &nbsp; &nbsp;: &nbsp;subtract 2 from the top number on the stack<br/>
&nbsp; &nbsp; &nbsp; &nbsp; N1 = N1 - 2<br/>
<br/>
e.g. &nbsp; &nbsp;196 2- . &lt;CR&gt;<br/>
will print 194<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
23
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>MOD</b> &nbsp; &nbsp; : &nbsp;This will leave the remainder of N2/N1 on the top of the stack with<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the same sign as N2<br/>
<br/>
e.g. &nbsp; &nbsp;17 3 MOD . &lt;CR&gt;<br/>
will print 2 &nbsp;(17/3 = 5 remainder 2)<br/>
<br/>
<br/>
<b>/MOD</b> &nbsp; &nbsp;: &nbsp;This will leave the remainder and the quotient on the stack of N2/N1<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;such that the quotient becomes the top number on the stack and the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;remainder becomes the second.<br/>
<br/>
e.g. &nbsp; &nbsp;17 3 /MOD . CR . &lt;CR&gt;<br/>
will print 5 (quotient)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 (remainder)<br/>
<br/>
<br/>
<b>3. STACK OPERATORS</b><br/>
<br/>
<br/>
<b>DUP</b> &nbsp; &nbsp; : &nbsp;This will duplicate the top number on the stack.<br/>
<br/>
e.g. &nbsp; &nbsp;719 DUP . . &lt;CR&gt;<br/>
will print &nbsp;719 719<br/>
<br/>
<br/>
<b>DROP</b> &nbsp; &nbsp;: &nbsp;This will drop the number from the top of the stack.<br/>
<br/>
e.g. &nbsp; &nbsp;111 222 DROP . &lt;CR&gt;<br/>
will print &nbsp;111<br/>
<br/>
<br/>
<b>SWAP</b> &nbsp; &nbsp;: &nbsp;This will swap the top two numbers on the stack.<br/>
<br/>
e.g. &nbsp; &nbsp;111 222 SWAP . . &lt;CR&gt;<br/>
will print &nbsp;111 222<br/>
<br/>
<br/>
<b>OVER</b> &nbsp; &nbsp;: &nbsp;This will copy the second number on the stack, making it a new number<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;at the top of the stack without destroying the other numbers.<br/>
<br/>
e.g. &nbsp; &nbsp;111 222 OVER . CR . CR . &lt;CR&gt;<br/>
will print &nbsp;111<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 222<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 111<br/>
<br/>
since the stack before OVER was:<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 222 &nbsp; &nbsp; &nbsp;TOS<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 111<br/>
<br/>
and after OVER is:<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 111 &nbsp; &nbsp; &nbsp;TOS<br/>
&nbsp; &nbsp; &nbsp;copy &nbsp; 222<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 111<br/>
<br/>
<br/>
<b>ROT</b> &nbsp; &nbsp; : &nbsp;This will rotate the top three numbers on the stack, bringing the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;third number to the top of the stack.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 24
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
e.g. &nbsp; &nbsp;1 2 3 ROT . CR . CR . &lt;CR&gt;<br/>
will print &nbsp;1<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2<br/>
<br/>
since the stack before ROT was:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3 &nbsp; &nbsp; &nbsp; &nbsp;TOS<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1<br/>
<br/>
and after ROT is:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp;TOS<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2<br/>
<br/>
<br/>
<b>4. OTHER OPERATIONS</b><br/>
<br/>
<br/>
<b>!</b> &nbsp; &nbsp; &nbsp; : &nbsp;This will store the second number on the stack at the address held on<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the top of the stack. (pronounced "store").<br/>
<br/>
e.g. &nbsp; &nbsp;Suppose the stack is as follows:<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; HEX C000 &nbsp; &nbsp; TOS<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FFEE<br/>
<br/>
This will store FFEE at address C000/C001<br/>
i.e. &nbsp; &nbsp;EE at C000<br/>
&nbsp; &nbsp; &nbsp; &nbsp; FF at C001<br/>
<br/>
If we key in HEX FF00 C000 ! &lt;CR&gt;<br/>
this will store FF00 at C000/C001<br/>
i.e &nbsp; &nbsp; C000 contains low byte 00<br/>
&nbsp; &nbsp; &nbsp; &nbsp; C001 contains high byte FF<br/>
<br/>
Remember that each 16 bit number takes up 2 bytes.<br/>
<br/>
<br/>
<b>@</b> &nbsp; &nbsp; &nbsp; : &nbsp;This will replace the address held on the top of the stack, with the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;16 bit contents of that address. (Pronounced "at")<br/>
<br/>
Suppose the memory contents are as follows:<br/>
<br/>
Address: &nbsp;6100 6101 6102 6103 6104 6105<br/>
Contents: 00 &nbsp; C3 &nbsp; 8F &nbsp; 70 &nbsp; 00 &nbsp; C3<br/>
<br/>
then 6100 @ . &lt;CR&gt;<br/>
will print C300<br/>
<br/>
If you wish to deal with single bytes, then a variation of the above will be<br/>
used.<br/>
<br/>
<br/>
<b>C!</b> &nbsp; &nbsp; &nbsp;: &nbsp;Will store a single byte held in the second number on the stack at the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;address held on the top of the stack.<br/>
<br/>
e.g. &nbsp; &nbsp;FF C000 C! &lt;CR&gt;<br/>
will store a single byte FF at address C000.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
25
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>C@</b> &nbsp; &nbsp; &nbsp;: &nbsp;This will fetch the single byte held at the address at the top of the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stack - this single byte will be pushed on the stack as a 16<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bit number, but with the high byte set to zero.<br/>
<br/>
with reference to the memory contents shown previously,<br/>
if we key in C000 C@ . &lt;CR&gt;<br/>
<br/>
this will print FF (and not FF00 as with @)<br/>
<br/>
<br/>
<b>+!</b> &nbsp; &nbsp; &nbsp;: &nbsp;This will add the number held in the second number of the stack, to<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the value held at the address on the top of the stack (Pronounced<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"Plus-store").<br/>
<br/>
e.g. &nbsp; &nbsp;4 HEX C000 +! &lt;CR&gt;<br/>
will add 4 to the value at C000/C001<br/>
As will be shown later, this is of use when using variables in White Lightning.<br/>
<br/>
<br/>
<b>5. COLON DEFINITIONS</b><br/>
<br/>
These are the most powerful and most used forms of data structures in White<br/>
Lightning, and are so called because they begin with a colon ":"<br/>
<br/>
Colon definitions allow the creation of new Forth words based on previously<br/>
defined words. &nbsp;They can be of any length, although carriage return must be<br/>
pressed before a particular section exceeds 80 characters.<br/>
<br/>
The general format is:<br/>
<br/>
: &nbsp;new-word &nbsp;word1 &nbsp;word2..... &nbsp;wordn &nbsp;;<br/>
<br/>
All colon definitions end with a semi-colon &nbsp;";"<br/>
<br/>
If a word used in a colon definition has not been previously defined, then an<br/>
error will result.<br/>
<br/>
The new-word is executed simply by typing its name and pressing ENTER.<br/>
<br/>
e.g. &nbsp; &nbsp;Suppose we wish to define a new word to calculate the square of a given<br/>
number.<br/>
<br/>
We could do this by:<br/>
<br/>
: SQUARE DECIMAL CR ." THE SQUARE OF " DUP . ." IS " DUP * . ; &lt;CR&gt;<br/>
<br/>
Here we have defined a new word called SQUARE which will be called by<br/>
<br/>
number SQUARE &lt;CR&gt;<br/>
<br/>
e.g. &nbsp; &nbsp;9 SQUARE &lt;CR&gt;<br/>
<br/>
will result in:<br/>
<br/>
THE SQUARE OF 9 IS 81<br/>
<br/>
If we follow the operation of the word, we will see the changes in the stack:<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 26
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
&nbsp; &nbsp; &nbsp;TOS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OPERATION &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RESULT<br/>
&nbsp; empty<br/>
&nbsp; &nbsp; &nbsp; 9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 9 SQUARE<br/>
&nbsp; &nbsp; &nbsp; 9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;carriage return<br/>
&nbsp; &nbsp; &nbsp; 9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ." &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;THE SQUARE OF<br/>
&nbsp; 9 &nbsp; 9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DUP<br/>
&nbsp; &nbsp; &nbsp; 9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; . &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 9<br/>
&nbsp; &nbsp; &nbsp; 9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ." &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IS<br/>
&nbsp; 9 &nbsp; 9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DUP<br/>
&nbsp; &nbsp; &nbsp;81 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *<br/>
&nbsp; empty 81 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 81<br/>
<br/>
and execution of SQUARE ends at the semi-colon.<br/>
<br/>
If we now wished, we could define a new word using our word SQUARE.<br/>
<br/>
We are now going to discuss control structures. &nbsp;It must be remembered, that the<br/>
control structures can only be incorporated in colon definitions, or an error will<br/>
result.<br/>
<br/>
<br/>
<b>6. CONTROL STRUCTURES</b><br/>
<br/>
LOOPS<br/>
<br/>
There are essentially two forms of loop operation:<br/>
<br/>
&nbsp;(i) &nbsp;<b>DO... &nbsp;LOOP</b><br/>
<br/>
(ii) &nbsp;<b>DO... +LOOP</b><br/>
<br/>
The first loop structure is used as follows:<br/>
<br/>
limit start DO ... 'Forth words' ... LOOP<br/>
<br/>
The Forth words within the loop are executed until start = limit, incrementing the<br/>
start (or index) by one each time. Type:<br/>
<br/>
: TEST1 5 0 DO ." Forth " CR LOOP ; &lt;CR&gt;<br/>
Typing in TEST1 &lt;CR&gt;<br/>
will print Forth<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Forth<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Forth<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Forth<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Forth<br/>
<br/>
The second loop structure is used as follows:<br/>
<br/>
limit start DO ...'Forth words' increment +LOOP<br/>
<br/>
The Forth words within the loop are executed from start to limit, with the index<br/>
being incremented or decremented by the value increment. Try:<br/>
<br/>
: TEST2 5 0 CO ." HELLO " 2 +LOOP ; &lt;CR&gt;<br/>
Executing TEST2 will print HELLO HELLO HELLO<br/>
<br/>
Since the limit and the index are held on the return stack, it would be useful if<br/>
we could examine the index. &nbsp;Well, there are words to do this:<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
27
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>I</b> &nbsp; &nbsp; &nbsp; : This will copy the loop index from the return stack onto the data<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack.<br/>
<br/>
<b>J</b> &nbsp; &nbsp; &nbsp; : This will push the value of the nested LOOP index to the stack.<br/>
<br/>
<b>K</b> &nbsp; &nbsp; &nbsp; : This will push the value of the double nested LOOP index to the stack.<br/>
<br/>
<br/>
<br/>
Type:<br/>
<br/>
: TEST3 4 0 DO 4 0 DO 4 0 DO K J I . . . CR LOOP LOOP LOOP ; &lt;CR&gt;<br/>
<br/>
Executing TEST3 &nbsp; &nbsp; &nbsp;1 &nbsp;1 &nbsp;1<br/>
will print: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp;1 &nbsp;2<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp;1 &nbsp;3<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;. &nbsp;. &nbsp;.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;. &nbsp;. &nbsp;.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;. &nbsp;. &nbsp;.<br/>
<br/>
and so on.<br/>
<br/>
<br/>
<b>7. CONDITIONAL BRANCHING</b><br/>
<br/>
Conditional branching must again be used only within a colon definition and uses<br/>
the form:<br/>
<br/>
<b>IF</b> (true part) ... (Forth WORDS) ... <b>ENDIF</b><br/>
<br/>
<b>IF</b> (true part) ... (Forth WORDS) ... <b>ELSE</b> (false part) ... (Forth WORDS) ...<br/>
<b>ENDIF</b><br/>
<br/>
These conditional statements rely on testing the top number on the stack to decide<br/>
whether to execute the TRUE part, or the FALSE part of the condition.<br/>
<br/>
If the top item on the stack is true (non-zero) then the true part will be<br/>
executed. &nbsp;If the top item is false (zero) then the true part will be skipped and<br/>
execution of the false part will take place. &nbsp;If the ELSE part is missing, then<br/>
execution skips to just after the ENDIF statement.<br/>
<br/>
There are several mathematical operators which will leave either a true (non-zero)<br/>
flag, or a false (zero) flag on the stack to be tested for by IF.<br/>
<br/>
These are:<br/>
<br/>
<b>0&lt;</b> &nbsp; &nbsp; &nbsp;: &nbsp;This will leave a true flag on the stack if the number on the top<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;of the stack is less than zero, otherwise it leaves a false flag.<br/>
<br/>
e.g. &nbsp; &nbsp;-4 0&lt; &lt;CR&gt;<br/>
will leave a true flag (non-zero).<br/>
<br/>
To see this, type:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; . &lt;CR&gt;<br/>
to print the top number on the stack, which is the flag. &nbsp;This will print<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 1<br/>
to show a true flag.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 914 0&lt; . &lt;CR&gt;<br/>
will print a 0 (false flag).<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 28
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>0=</b> &nbsp; &nbsp; &nbsp;: &nbsp;This will leave a true flag on the top of the stack if the number on<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the top of the stack is equal to zero, otherwise it will leave a<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;false flag.<br/>
<br/>
<br/>
<b>&lt;</b> &nbsp; &nbsp; &nbsp; : &nbsp;This will leave a true flag if the second number on the stack is less<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;than the top number, otherwise it will leave a false flag.<br/>
<br/>
e.g. &nbsp; &nbsp;40 25 &lt; . &lt;CR&gt;<br/>
will print 0 (false flag).<br/>
<br/>
If we look at the stack during this operation we will see:<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Operation &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TOS<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;40 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 40<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;25 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;40 25<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; . &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;empty<br/>
<br/>
<br/>
<b>&gt;</b> &nbsp; &nbsp; &nbsp; : &nbsp;This will leave a true flag if the second number on the stack is<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;greater than the top number, else a false flag will be left.<br/>
<br/>
e.g. &nbsp; &nbsp;40 25 &gt; . &lt;CR&gt;<br/>
will print 1 (true flag).<br/>
<br/>
<br/>
<b>=</b> &nbsp; &nbsp; &nbsp; : &nbsp;This will leave a true flag if the two top numbers are equal,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;otherwise it will leave a false flag.<br/>
<br/>
Now for some examples using the conditional branching structures, type:<br/>
<br/>
: TEST= = IF ." BOTH ARE EQUAL " ENDIF ." FINISHED " ; &lt;CR&gt;<br/>
<br/>
Now key in two numbers followed by TEST= and a carriage return.<br/>
<br/>
e.g. &nbsp; &nbsp;11 119 TEST= &lt;CR&gt;<br/>
This will print FINISHED<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 119 119 TEST= &lt;CR&gt;<br/>
will print BOTH ARE EQUAL FINISHED<br/>
<br/>
Now key in:<br/>
: TEST1= = IF ." EQUAL " ELSE ." UNEQUAL " ENDIF CR ." FINISHED " ; &lt;CR&gt;<br/>
<br/>
Now key in:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 249 249 TEST1= &lt;CR&gt;<br/>
this will print EQUAL<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FINISHED<br/>
<br/>
Try: &nbsp; &nbsp;249 248 TEST1= &lt;CR&gt;<br/>
this will print UNEQUAL<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FINISHED<br/>
<br/>
Notice how the part after ENDIF was executed in both cases.<br/>
<br/>
Two more loop structures will now be discussed:<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
29
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>BEGIN</b> &nbsp;.... &nbsp;(Forth WORDS) &nbsp;.... &nbsp;<b>UNTIL</b><br/>
<br/>
<b>BEGIN</b> &nbsp;.... &nbsp;(Forth WORDS) &nbsp;.... &nbsp;<b>WHILE</b> &nbsp;.... &nbsp;(Forth WORDS) &nbsp;.... &nbsp;<b>REPEAT</b><br/>
<br/>
Using the BEGIN .... UNTIL the value at the top of the stack is tested upon<br/>
reaching UNTIL. &nbsp;If the flag is false (0) then the loop starting from BEGIN is<br/>
repeated. &nbsp;If the value is true (non-zero) then an exit from the loop occurs.<br/>
<br/>
Try typing the following example:<br/>
<br/>
: COUNT-DOWN DECIMAL 100 BEGIN 1- DUP DUP . CR 0= UNTIL ." DONE " ; &lt;CR&gt;<br/>
<br/>
Now key in: COUNTDOWN &lt;CR&gt;<br/>
This will print:<br/>
&nbsp; 99<br/>
&nbsp; 98<br/>
&nbsp; &nbsp;.<br/>
&nbsp; &nbsp;.<br/>
&nbsp; &nbsp;.<br/>
&nbsp; &nbsp;3<br/>
&nbsp; &nbsp;2<br/>
&nbsp; &nbsp;1<br/>
&nbsp; &nbsp;0<br/>
DONE<br/>
<br/>
The BEGIN ... WHILE ... REPEAT structure uses the WHILE condition to abort a loop<br/>
in the middle of that loop. &nbsp;WHILE will test the flag left on top of the stack and<br/>
if that flag is true, will continue with the execution of words up to REPEAT,<br/>
which then branches always (unconditionally) back to BEGIN. &nbsp;If the flag is false,<br/>
then WHILE will cause execution to skip the words up to REPEAT and thus exit from<br/>
the loop.<br/>
<br/>
We will now construct a program to print out the cubes of numbers from 1 upwards,<br/>
until the cube is greater than 3000.<br/>
<br/>
The colon definition could be as follows:<br/>
<br/>
: CUBE DECIMAL 0 BEGIN 1+ &lt;CR&gt;<br/>
DUP DUP DUP DUP * * DUP &lt;CR&gt;<br/>
3000 &lt; WHILE ." THE CUBE OF " &lt;CR&gt;<br/>
SWAP . ." IS " . CR REPEAT &lt;CR&gt;<br/>
DROP DROP DROP ." ALL DONE " CR ; &lt;CR&gt;<br/>
<br/>
You may get an error message "MSG#4" appearing on the screen; this means that the<br/>
word you have just created already exists. &nbsp;This is not a problem since the new<br/>
word will be created, and all actions referencing the word CUBE will be directed<br/>
to the latest definition using that name.<br/>
<br/>
Now run this by keying in:<br/>
<br/>
CUBE &lt;CR&gt;<br/>
<br/>
and watch the results.<br/>
<br/>
Try to follow what is happening by writing down the values on the stack at each<br/>
operation. &nbsp;If you are having any difficulty in doing this, the stack values are<br/>
shown below.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 30
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
&nbsp; &nbsp; &nbsp; &nbsp;<b>STACK</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>OPERATION</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>OUTPUT (if any)</b><br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; empty &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DECIMAL<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BEGIN<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1+<br/>
<br/>
(let us now refer to the number on the stack as N)<br/>
<br/>
&nbsp; &nbsp; &nbsp; N N &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DUP<br/>
&nbsp; &nbsp; N N N &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DUP<br/>
&nbsp; N N N N &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DUP<br/>
N N N N N &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DUP<br/>
&nbsp; N N N N&#178; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *<br/>
&nbsp; &nbsp; N N N&#179; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *<br/>
&nbsp; N N N&#179;N&#179; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DUP<br/>
N N N&#179;N&#179;3000 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3000<br/>
&nbsp; N N N&#179;flag (1 or 0) &nbsp; &nbsp;&lt;<br/>
<br/>
If TRUE:<br/>
<br/>
&nbsp; &nbsp; N N N&#179; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WHILE<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;." THE CUBE OF " &nbsp; THE CUBE OF<br/>
&nbsp; &nbsp; N N&#179;N &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SWAP<br/>
&nbsp; &nbsp; &nbsp; N N&#179; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; . &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;." IS " &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IS<br/>
&nbsp; &nbsp; &nbsp; &nbsp; N &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N&#179;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; N &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;carriage return<br/>
&nbsp; &nbsp; &nbsp; &nbsp; N &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;REPEAT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(branch back to BEGIN)<br/>
<br/>
If FALSE:<br/>
<br/>
&nbsp; &nbsp; &nbsp; N N &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DROP<br/>
&nbsp; &nbsp; &nbsp; &nbsp; N &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DROP<br/>
&nbsp; &nbsp; empty &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DROP<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;." ALL DONE " &nbsp; &nbsp; &nbsp; ALL DONE<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CR<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;<br/>
<br/>
In fact, it is a good idea to check the stack contents during the execution of any<br/>
new Forth word to make sure that it is working correctly. &nbsp;(Note that DROP merely<br/>
clears the top number from the stack).<br/>
<br/>
Finally, one extra construct has been added to circumvent the problem of deeply<br/>
nested IF...THEN...ELSE structures. &nbsp;This is the CASE OF structure. It takes the<br/>
general form :<br/>
<br/>
CASE n1 OF (Forth Word) ENDOF n2 OF (Forth Word) ENDOF ... END CASE<br/>
<br/>
For example type:<br/>
<br/>
: TEST4 CASE 1 OF ." FIRST CASE " ENDOF 2 OF ." SECOND CASE " ENDOF 3 OF ." THIRD<br/>
CASE " ENDOF END CASE ; &lt;CR&gt;<br/>
<br/>
Now type :<br/>
<br/>
1 TEST4 CR 2 TEST4 CR 3 TEST4 CR &lt;CR&gt;<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
31
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>8. CONSTANTS AND VARIABLES</b><br/>
<br/>
White Lightning also allows you to define your own constants and variables using<br/>
the Fourth words:<br/>
<br/>
CONSTANT<br/>
VARIABLE<br/>
<br/>
When a constant is called up, this causes its VALUE to be pushed onto the stack,<br/>
however, when a variable is called up, this causes its address to be pushed onto<br/>
the stack. &nbsp;The Forth words ! and @ are used to modify the contents of the<br/>
variable.<br/>
<br/>
A constant is defined by using the form:<br/>
<br/>
value CONSTANT name<br/>
<br/>
and any references to the name will cause the value n to be put on the stack.<br/>
<br/>
A variable is defined using the form:<br/>
<br/>
value VARIABLE name<br/>
<br/>
and any reference to the name will result in the address of that variable to be<br/>
put on the stack for further manipulation using ! and @. &nbsp;It is essential that you<br/>
realise the difference between the contents and the address of a variable.<br/>
<br/>
Now for some examples:<br/>
<br/>
&nbsp; 64 CONSTANT R 1000 CONSTANT Q<br/>
&nbsp;256 VARIABLE X<br/>
&nbsp; &nbsp;0 VARIABLE Y<br/>
<br/>
R Q + . &nbsp;will print the value of R + Q i.e. 1064<br/>
&nbsp; &nbsp; X . &nbsp;will print the address of X, not its value<br/>
&nbsp; X @ . &nbsp;will print the value of X, i.e. 256<br/>
&nbsp; R Y ! &nbsp;will store the value of R in the variable Y<br/>
&nbsp; Y X ! &nbsp;will store the address of Y in the variable X<br/>
&nbsp; 4 X ! &nbsp;will store the value 4 in variable X<br/>
<br/>
<b>BASIC statement</b> &nbsp; &nbsp; &nbsp; <b>Forth Equivalent</b><br/>
<br/>
LET X = Y &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Y @ X !<br/>
LET X = R &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; R X !<br/>
LET X = 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 X !<br/>
LET X = X + 5 &nbsp; &nbsp; &nbsp; &nbsp; 5 X +!<br/>
<br/>
<br/>
<b>OTHER COMMONLY USED FORTH WORDS</b><br/>
<br/>
<br/>
<b>LIST</b> &nbsp; &nbsp;: This will list the contents of the screen number held on the top of<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the stack.<br/>
<br/>
e.g. &nbsp;6 LIST will list screen 6 to the screen. &nbsp;Note that if source has not been<br/>
typed into any of the screens, they will probably contain garbage.<br/>
<br/>
<br/>
<b>FORGET</b> &nbsp;: This is used to delete part of the Lightning dictionary. &nbsp;Please note<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; that not only will the word following FORGET be erased, but so will<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; every word defined after it!<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 32
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
e.g. &nbsp;FORGET EXAMPLE will delete the word EXAMPLE (if it exists) along with any<br/>
other words defined after it.<br/>
<br/>
<br/>
<b>VLIST</b> &nbsp; : This is just typed in as a single word with no parameters. &nbsp;It will<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cause a list of all the words defined so far; pressing BREAK<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (CAPS SHIFT & SPACE as in BASIC) will stop the listing.<br/>
<br/>
<br/>
<b>LOAD</b> &nbsp; &nbsp;: This will compile the source code that you have created using the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; editor into the White Lightning dictionary, to become new Lightning<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; words. &nbsp;Loading will terminate at the end of a screen or at the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Forth word ;S &nbsp;unless the "continue loading" word --&gt; is used at the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end of a screen. &nbsp;The idea of the screen will became obvious in the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next section on editing.<br/>
<br/>
<br/>
<b>USING THE EDITOR</b><br/>
<br/>
Generally speaking, most users will want to use the Spectrum editor to type and<br/>
edit the source, but a full Forth line editor is included for compatibility with<br/>
existing texts. &nbsp;The maximum length of any line is 64 characters. &nbsp;Any characters<br/>
after this will be ignored.<br/>
<br/>
<b>Line Editor</b><br/>
<br/>
Included in this version of White Lightning is a line editor to enable you to<br/>
create source or text files. &nbsp;To facilitate text editing, the text is organised<br/>
into blocks of 512 bytes, divided into 8 lines of 64 characters. &nbsp;Once the text<br/>
has been edited, it may then be compiled into the White Lightning dictionary and<br/>
the text, if required, can be saved to tape. &nbsp;The text is stored in memory in the<br/>
pages at C000 to F000, therefore, you can edit into screens 1 to 23. &nbsp;If the<br/>
background facility is utilised, text is stored from CC00 onwards in screens 6 to<br/>
23, and screens 0 to 5 cannot be used.<br/>
<br/>
Here is a list of the editor commands and their descriptions:<br/>
<br/>
<br/>
<b>H</b> &nbsp; &nbsp; &nbsp;: &nbsp;This will Hold the text pointed to by the top number on the stack of<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the current screen in a temporary area known as PAD.<br/>
<br/>
e.g. &nbsp;4 H will hold line 4 of the current screen in PAD.<br/>
<br/>
<br/>
<b>S</b> &nbsp; &nbsp; &nbsp;: &nbsp;Fill (Spread) the line number at the top of the stack with blanks, and<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shift down all subsequent lines by 1, with the last line being lost.<br/>
<br/>
e.g. &nbsp;6 S will fill line 6 with blanks and move all other lines down by one,<br/>
pushing the last line off the screen.<br/>
<br/>
<br/>
<b>D</b> &nbsp; &nbsp; &nbsp;: &nbsp;Delete the line number held on the stack. &nbsp;All other lines are moved<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; up by 1. &nbsp;The line is held in PAD in case it is still needed.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Line 7 cannot be deleted.<br/>
<br/>
<br/>
<b>E</b> &nbsp; &nbsp; &nbsp;: &nbsp;Erase the line number at the top of the stack by filling it with<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spaces.<br/>
<br/>
<br/>
<b>RE</b> &nbsp; &nbsp; : &nbsp;REplace the line number at the top of the stack with the line<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currently held in PAD.<br/>
<br/>
<br/>
33
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>P</b> &nbsp; &nbsp; &nbsp;: &nbsp;Put the following text on the line number held on the stack, by<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overwriting its present contents.<br/>
<br/>
<br/>
<b>INS</b> &nbsp; &nbsp;: &nbsp;INSert the text from PAD to the line number held on the stack.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The original and subsequent lines are moved down by 1 with the last<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; line being lost.<br/>
<br/>
<br/>
<b>EDIT</b> &nbsp; : &nbsp;Works just like the normal Sinclair line editor. &nbsp;Also, it does an<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; automatic list and an automatic flush. &nbsp;This is far and away the best<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; way to edit and the above are included only for compatibility<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; with existing Forths.<br/>
<br/>
<b>CLEAR</b> &nbsp;: &nbsp;Clear the screen number held on the stack and make it the current<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; screen.<br/>
<br/>
<br/>
<b>WHERE</b> &nbsp;: &nbsp;If an error occurs during the loading of White Lightning's text<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; screens, then keying in WHERE will result in the screen number and<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the offending line being displayed. &nbsp;You can now use the other editing<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commands to edit the screen, or you may move to another screen by<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; either LISTing or CLEARing it.<br/>
<br/>
e.g. &nbsp;15 LIST will now make screen 15 the current screen and will list the<br/>
contents.<br/>
<br/>
In order to compile this screen into the dictionary, it is necessary to use the<br/>
word LOAD.<br/>
<br/>
<br/>
LOAD<br/>
<br/>
This will start loading at the screen number held on the top of the stack and will<br/>
stop at the end of the screen.<br/>
<br/>
If you wish to continue and LOAD the next screen, the current screen must end with<br/>
--&gt;<br/>
<br/>
This means "continue loading and interpreting".<br/>
<br/>
If you wish to stop the LOADing anywhere in a screen then use: ;S<br/>
<br/>
This means "stop loading and interpreting".<br/>
<br/>
At the end of every editing session, and before saving your text, it is necessary<br/>
to FLUSH the memory buffers into the text area. &nbsp;To do this, just key in:<br/>
<br/>
FLUSH &lt;CR&gt;<br/>
<br/>
Note that the EDIT command does an automatic FLUSH.<br/>
<br/>
You can save your text to tape using the Spectrum 'SAVE' command. &nbsp;You must first<br/>
enter BASIC by typing PROG &nbsp;&lt;CR&gt; .<br/>
<br/>
Now for an example of how to edit a text file:<br/>
<br/>
The first step is to either LIST or CLEAR the screen about to be worked on:<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 34
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
9 CLEAR &lt;CR&gt;<br/>
<br/>
This sets the current screen to 9. &nbsp;To insert text use the EDIT command. Type 0<br/>
EDIT &lt;CR&gt; followed by the text below:<br/>
<br/>
THIS IS HOW TO PUT &lt;CR&gt;<br/>
<br/>
Then type 1 EDIT &lt;CR&gt;<br/>
<br/>
TEXT ON LINE 1 &lt;CR&gt;<br/>
<br/>
and so on, until you have entered:<br/>
<br/>
0 THIS IS HOW TO PUT &lt;CR&gt;<br/>
1 TEXT ON LINE 1 &lt;CR&gt;<br/>
2 LINE 2 &lt;CR&gt;<br/>
3 AND LINE 3 OF THIS SCREEN &lt;CR&gt;<br/>
<br/>
9 LIST will produce:<br/>
<br/>
SCR # 9<br/>
0 &nbsp;THIS IS HOW TO PUT<br/>
1 &nbsp;TEXT ON LINE 1<br/>
2 &nbsp;LINE 2<br/>
3 &nbsp;AND LINE 3 OF THIS SCREEN 4<br/>
5<br/>
6<br/>
7<br/>
<br/>
To change LINE 2, type 2 EDIT &lt;CR&gt; and then change it in the normal way to insert<br/>
'TEXT ON' before 'LINE 2'. &nbsp;Now type 9 LIST &lt;CR&gt; to see the result. &nbsp;The editor<br/>
ignores characters after the 64th character of the line being edited.<br/>
<br/>
If you have a Sinclair printer connected, then it is probably worth defining a<br/>
word to list screens to the printer:<br/>
<br/>
: SLIST PRT-ON 1+ SWAP DO I LIST CR LOOP PRT-OFF ;<br/>
<br/>
To use the above word, type the first screen number, last screen number, SLIST.<br/>
<br/>
e.g. &nbsp;6 9 SLIST &lt;CR&gt; will list screens 6-9 to the printer.<br/>
<br/>
<br/>
<b>FORTH ERROR MESSAGES</b><br/>
<br/>
The following error messages may occur, and will be printed out in the form FRED ?<br/>
MSG #0 &nbsp; standing for FRED ? ERROR MESSAGE NUMBER 0 .<br/>
<br/>
<br/>
&nbsp;# 0 &nbsp;- &nbsp;this means that a word could not be found, or that a numeric conversion<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;could not take place.<br/>
<br/>
e.g. &nbsp;109Z &lt;CR&gt;<br/>
<br/>
<br/>
&nbsp;# 1 &nbsp;- &nbsp;this indicates an empty stack and will be encountered when trying to<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;take more values from the stack than exist. Try:<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; : TEST1 &nbsp;1000 &nbsp;0 &nbsp;DO &nbsp;?STACK &nbsp;DROP LOOP &nbsp;; &lt;CR&gt;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TEST1 &lt;CR&gt;<br/>
<br/>
<br/>
<br/>
<br/>
35
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
?STACK is a word which tests the stack for out of bounds.<br/>
<br/>
<br/>
&nbsp;# 2 &nbsp;- &nbsp;this indicates that either the dictionary has grown up to meet the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stack (dictionary full) or that the stack has grown down to meet<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the dictionary.<br/>
<br/>
Try: &nbsp; &nbsp;: TEST2 &nbsp;1000 &nbsp;0 &nbsp;DO &nbsp;?STACK &nbsp;0 0 0 0 0 LOOP &nbsp;; &lt;CR&gt;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TEST2 &lt;CR&gt;<br/>
<br/>
<br/>
&nbsp;# 4 &nbsp;- &nbsp;this means that you have redefined an existing word using a new colon<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;definition<br/>
<br/>
Try: &nbsp; &nbsp;: ROT ." NEW DEFINITION " ; &lt;CR&gt;<br/>
<br/>
This is not really an error since the new word is still valid, but the old<br/>
definition cannot be accessed unless you FORGET the new one.<br/>
<br/>
<br/>
&nbsp;# 6 &nbsp;- &nbsp;this error my occur when editing, loading or listing screens of data.<br/>
<br/>
Try: &nbsp; &nbsp;25 LIST &lt;CR&gt;<br/>
This will produce MSG#6 and means you have tried to access a non-existent<br/>
screenful of memory.<br/>
<br/>
<br/>
&nbsp;# 9 &nbsp;- &nbsp;this indicates that an attempt was made to clear sprite space of<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;less than 2 bytes.<br/>
<br/>
<br/>
&nbsp;# 10 - &nbsp;this indicates that one of the IDEAL words made reference to a sprite<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;which did not exist, or that an attempt was mode to insert a sprite<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;using ISPRITE with a number previously allocated to an existing sprite.<br/>
<br/>
<br/>
&nbsp;# 17 - &nbsp;this will occur if you try to use a word in the 'immediate' mode which<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;should only be used during compilation, i.e. during colon definitions.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;For a list of such words, refer to the glossary (words with "C" in the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;top right hand corner of the description).<br/>
<br/>
Try: &nbsp; &nbsp;DO &lt;CR&gt;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; IF &lt;CR&gt;<br/>
<br/>
<br/>
&nbsp;# 18 - &nbsp;this occurs if a word meant for execution only, is put within a colon<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;definition (words with "E" in the top right hand corner of the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;description).<br/>
<br/>
<br/>
&nbsp;# 19 - &nbsp;this means that a colon definition contains conditionals that have<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;not been paired.<br/>
<br/>
e.g. &nbsp; &nbsp;a LOOP without a DO<br/>
&nbsp; &nbsp; &nbsp; &nbsp; an ENDIF without an IF<br/>
<br/>
Try: &nbsp; &nbsp;: TEST3 &nbsp;ELSE &nbsp;." WRONG " ; &lt;CR&gt;<br/>
<br/>
&nbsp;# 20 - &nbsp;this occurs if a colon definition has not been properly finished.<br/>
<br/>
Try: &nbsp; &nbsp;: TEST4 IF ." OK " ; &lt;CR&gt;<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 36
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
&nbsp;# &nbsp;21 - &nbsp;this means that you have tried to delete something in the protected<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; part of the Forth dictionary, e.g.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FORGET DO<br/>
<br/>
<br/>
&nbsp;# &nbsp;22 - &nbsp;this implies the illegal use of --&gt; when not loading text screens.<br/>
<br/>
<br/>
&nbsp;# &nbsp;23 - &nbsp;this happens when you try to edit a non-existent line of screen data.<br/>
<br/>
Try: &nbsp; &nbsp;12 D<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
37
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>SECTION 3</b><br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>IDEAL</b><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>by John Gross</b><br/>
<br/>
IDEAL has been designed to facilitate the manipulation of sprites and screen data,<br/>
and with its 100 or so instructions, provides a powerful and comprehensive<br/>
animation sub-language. &nbsp;Time should be taken to gain familiarity with the<br/>
available commands before undertaking the first big project. &nbsp;Remember, that by<br/>
using the colon definitions of Forth, new words can very easily be added to the<br/>
language, built from the existing Forth and graphics words. &nbsp;Mastering this<br/>
technique effectively will save a great deal of space and, in many cases,<br/>
execution time.<br/>
<br/>
<br/>
<b>SPRITE</b><br/>
<br/>
A sprite is a software controllable graphics character. &nbsp;White Lightning supports<br/>
up to 255 sprites with user selectable dimensions.<br/>
<br/>
<br/>
<b>SCREEN WINDOWS</b><br/>
<br/>
A screen window is a section of the screen defined by the four variables COL, ROW,<br/>
HGT and LEN. &nbsp;Columns are in the range 0 to 31, Rows are in the range 0 to 23,<br/>
Heights are in the range 1 to 24, and Lengths are in the range 1 to 32. The unit<br/>
for each is the character. &nbsp;COL and ROW specify the position of the top left hand<br/>
corner of the window, with ROW 0 at the top of the screen and COL 0 on the left<br/>
hand side of the screen. &nbsp;HGT and LEN define the size of the window. &nbsp;To see an<br/>
example type:<br/>
<br/>
5 ROW ! 6 COL ! 4 HGT ! 3 LEN ! INVV &lt;CR&gt;<br/>
<br/>
The window has been inverted to mark it out.<br/>
<br/>
<br/>
<b>SPRITE WINDOWS</b><br/>
<br/>
A sprite window is a section of the sprite defined by the Forth variables SCOL,<br/>
SROW, HGT and LEN. &nbsp;This time SCOL and SROW specify the position of the top left<br/>
hand corner of the sprite window. &nbsp;HGT and LEN are again used to specify the<br/>
dimensions of the window.<br/>
<br/>
<br/>
<b>SPRITE SPACE</b><br/>
<br/>
Sprite space is the area of memory containing the previously defined sprites. &nbsp;The<br/>
variable SPST holds the address of the start of sprite space, so SPST should never<br/>
be loaded with a new value unless a COLD# command is being executed, or you're<br/>
quite sure you know what you're doing!! &nbsp;SPND points to the first free byte after<br/>
sprite space. &nbsp;SPND should never be higher than FFF0 Hex if routines are being<br/>
executed in Background.<br/>
<br/>
<br/>
<b>PIXEL DATA</b><br/>
<br/>
For those not acquainted with the workings of the Spectrum screen display, each<br/>
character on the screen is produced as follows: &nbsp;each character cell is an array<br/>
of 64 (8 by 8) pixels. &nbsp;A pixel is a 'dot' which can be INK colour or PAPER<br/>
colour. &nbsp;The bytes which define a particular character or block of characters are<br/>
referred to as pixel data.<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 38
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>ATTRIBUTE DATA</b><br/>
<br/>
The colour of the INK and PAPER in each particular cell, together with the<br/>
BRIGHTNESS and FLASHING attributes of the character, are controlled by a separate<br/>
byte. &nbsp;The bytes which define the attributes of the block of characters are<br/>
referred to as Attribute data. &nbsp;Pixel data and Attribute data are frequently<br/>
treated as separate entities.<br/>
<br/>
<br/>
<b>SCREEN OPERATIONS</b><br/>
<br/>
Often, it is required to carry out an operation, such as a scroll or a reflection,<br/>
on one particular section of the screen. &nbsp;Four variables are used to define a<br/>
screen window, these are COL, ROW, HGT and LEN. &nbsp;The co-ordinates of the top left<br/>
hand corner are held in COL and ROW, where COL is measured from the left and ROW<br/>
from the top. &nbsp;Both values are in characters. &nbsp;HGT and LEN are the dimensions of<br/>
the window. &nbsp;COL + LEN must be in the range 1 to 32, and ROW + HGT must be in the<br/>
range 1 to 24. &nbsp;Commands in this group are postfixed with a "V", e.g. WRL1V, INVV,<br/>
MIRV.<br/>
<br/>
<br/>
<b>SCREEN/SPRITE OPERATIONS</b><br/>
<br/>
These are operations between the screen and a sprite. &nbsp;The dimensions of the<br/>
sprite are used as the dimensions of the screen window, and COL and ROW are used<br/>
to give the co-ordinates of the top left of the window. &nbsp;If the window overlaps<br/>
the edge of the screen, the command will not execute. Typical commands in this<br/>
group are the PUTs and GETs, which move sprites between the screen and memory.<br/>
Commands in this group are postfixed with an "S", e.g. PUTBLS, GETXRS.<br/>
<br/>
<br/>
<b>SPRITE OPERATIONS</b><br/>
<br/>
These cover more or less the same commands as the screen operations, but this time<br/>
a complete sprite is used instead of a screen window. &nbsp;The only parameter required<br/>
is the sprite number stored in SPN. &nbsp;Commands in this group are postfixed with an<br/>
"M", e.g. WRR4M, ATTUPM.<br/>
<br/>
<br/>
<b>SCREEN/SPRITE WINDOW OPERATIONS</b><br/>
<br/>
These are operations between a screen window and a sprite window. &nbsp;As before, ROW,<br/>
COL, HGT and LEN define the screen window, but this time, SCOL and SROW are used<br/>
to define the position of the window within the sprite. &nbsp;SCOL and SROW are<br/>
measured in characters, SROW from the top and SCOL from the left. &nbsp;If SROW + HGT<br/>
is greater than 24 or the sprite height, or if SCOL + LEN is greater than 32 or<br/>
the sprite width, the commands will not execute. &nbsp;These commands are postfixed<br/>
with an "S", e.g. GWATTS, PWORS.<br/>
<br/>
<br/>
<b>SPRITE/SPRITE WINDOW OPERATIONS</b><br/>
<br/>
These are operations between a whole sprite and a sprite window. &nbsp;The two sprite<br/>
numbers are held in SP1 (the whole sprite) and SP2 (the sprite which contains the<br/>
window). &nbsp;The dimensions of the window are the dimensions of the sprite whose<br/>
number is held in SP1. &nbsp;The position of the window in the sprite whose number is<br/>
held in SP2 is specified by SCOL and SROW. &nbsp;Commands in this group are postfixed<br/>
with an "M", e.g. GWATTM, PWNDM.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
39
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>SPRITE/SPRITE OPERATIONS</b><br/>
<br/>
These are operations between sprites which usually have the same dimensions, or,<br/>
as in the case of the SPIN command, transposed dimensions. &nbsp;SP1 and SP2 hold the<br/>
sprite numbers. &nbsp;Commands in this group are postfixed with a "M", e.g. COPORM,<br/>
SPINM.<br/>
<br/>
<br/>
<b>DUMMY SPRITE</b><br/>
<br/>
A dummy sprite is a sprite which does not contain data for display. &nbsp;It may be<br/>
used, for instance, to store a machine code subroutine, an array, or maybe a<br/>
collision detection sprite.<br/>
<br/>
<br/>
<b>IDEAL VARIABLES</b><br/>
<br/>
The IDEAL sublanguage uses 27 variables in all, these are:<br/>
<br/>
<b>VARIABLE</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>USE</b><br/>
<br/>
<b>ROW</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Used to hold the row (Y co-ord) in characters, measured<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;from the top of the screen (0-23).<br/>
<br/>
<b>LEN</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Used to hold the width of the current screen window<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(1-32), or the width of the sprite being defined (1-255).<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Units are characters.<br/>
<br/>
<b>COL</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Used to hold the column (X co-ord) in characters, measured<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;from the left of the screen (0-31).<br/>
<br/>
<b>HGT</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Used to hold the height of the current screen window<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(1-24), or the height of the sprite being defined (1-255).<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Units are characters.<br/>
<br/>
<b>SROW</b> &nbsp; &nbsp; &nbsp; &nbsp; Used to hold the row (Y co-ord) within the sprite whose<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;number is held in SP2, measured from the top (0-(HGT-1)).<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Units are characters.<br/>
<br/>
<b>SCOL</b> &nbsp; &nbsp; &nbsp; &nbsp; Used to hold the column (X co-ord) within the sprite<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;whose number is held in SP2, measured from the left<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(0-(LEN-1)). &nbsp;Units are characters.<br/>
<br/>
<b>NPX</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Used to hold the size and direction of the vertical scrolls.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Positive scrolls are upward and negative downward.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Units are pixels and not characters.<br/>
<br/>
<b>SPN</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Used to hold the sprite number for those words which<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;operate on only one sprite (1-255).<br/>
<br/>
<b>SP1</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Where operations involve a sprite and a sprite window,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SP1 holds the number of the sprite which does not contain<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the window (1-255). &nbsp;Where a sprite is to be spun into a<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;second sprite, SP1 holds the number of the first sprite<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(1-255).<br/>
<br/>
<b>SP2</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Where operations involve a sprite and a sprite window,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SP2 holds the number of the sprite which does contain<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the window (1-255). &nbsp;Where a sprite is to be spun into a second<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sprite, SP2 holds the number of the second sprite<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(1-255).<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 40
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>SPST</b> &nbsp; &nbsp; &nbsp; &nbsp; Used to hold the start address of sprite space.<br/>
<br/>
<b>SPND</b> &nbsp; &nbsp; &nbsp; &nbsp; Used to hold the end of sprite space, i.e. the first free byte<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;after the last sprite. &nbsp;This is the address of the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;foreground scrolling buffer.<br/>
<br/>
<b>SLEN</b> &nbsp; &nbsp; &nbsp; &nbsp; Used to hold the length of sprite space to be cleared<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;by the COLD# command.<br/>
<br/>
<b>MLEN</b> &nbsp; &nbsp; &nbsp; &nbsp; Used to hold the size and direction of the relocation.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;A positive value relocates sprites to higher memory and<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a negative value to lower memory.<br/>
<br/>
<b>SPTR</b> &nbsp; &nbsp; &nbsp; &nbsp; On return from the TEST command, SPTR points to the start<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;of the sprite.<br/>
<br/>
<b>DPTR</b> &nbsp; &nbsp; &nbsp; &nbsp; On return from the TEST command, DPTR points to the start<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;of the pixel data.<br/>
<br/>
<br/>
<b>Alternate Variables</b><br/>
<br/>
Eleven of the previously listed variables are replicated for use by the background<br/>
program (see Foreground/Background). &nbsp;These are ROW', COL', LEN', HGT', NPX',<br/>
SPN', SP1', SP2', SROW', SCOL' and SPND'.<br/>
<br/>
When a word is executed in background, the eleven alternate variables are<br/>
automatically switched with the eleven background variables; when execution is<br/>
complete, the variables are switched again to restore them to their former state.<br/>
<br/>
Suppose, for example, that the background program is to scroll left 1 pixel with<br/>
wrap (WRL1V), with an area of screen 6 characters wide and 4 characters high, with<br/>
top left co-ordinates row = 5, column = 7.<br/>
<br/>
Now type the following:<br/>
<br/>
CLS 6 LEN' ! 4 HGT' ! 5 ROW' ! 7 COL' ! ' WRL1V INT-ON &lt;CR&gt;<br/>
<br/>
The window is now scrolling but you can't see it, because there is no data in the<br/>
window.<br/>
<br/>
Type VLIST &lt;CR&gt; and watch the data as it scrolls through the window. &nbsp;The data in<br/>
the window will be slanting to the left, because the foreground program was<br/>
scrolling up at the same time as the background program scrolled left.<br/>
<br/>
Leaving the background program running, type:<br/>
<br/>
10 LEN' ! &lt;CR&gt;<br/>
<br/>
and the window will widen.<br/>
<br/>
Type:<br/>
<br/>
INT-OFF ' WRR8V INT-ON &lt;CR&gt;<br/>
<br/>
and the screen will scroll to the right, this time much more rapidly. &nbsp;Now type:<br/>
<br/>
INT-OFF &lt;CR&gt;<br/>
<br/>
to halt the background program.<br/>
<br/>
<br/>
<br/>
<br/>
41
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
In the above example we set background variables from foreground. &nbsp;If we were to<br/>
set the background variables actually in the background program, then foreground<br/>
and background variables would already have been switched before execution. &nbsp;To<br/>
set up the same windows, we would now have to use ROW, COL, HGT and LEN, and not<br/>
ROW', COL', HGT' and LEN'.<br/>
<br/>
To define a word to do this, type:<br/>
<br/>
: FRED 6 LEN ! 4 HGT ! 1 ROW ! 2 COL ! WRL1V ; &lt;CR&gt;<br/>
<br/>
To run "FRED" in background, type:<br/>
<br/>
' FRED INT-ON &lt;CR&gt;<br/>
<br/>
Since the variables were this time being assigned values in the background program<br/>
itself, the alternate variables set was being accessed with the normal names. &nbsp;Now<br/>
type:<br/>
<br/>
INT-OFF FORGET FRED &lt;CR&gt;<br/>
<br/>
to halt the background program and clear the definition.<br/>
<br/>
Operating in this way, a word will work in foreground or background without any<br/>
need to change variable names. &nbsp;The alternate variables are only used directly by<br/>
a foreground program that is required to change background variables, or a<br/>
background program that is required to change foreground variables. &nbsp;If the<br/>
previous example is a little confusing at first, carry out your own<br/>
experimentation until it becomes clear.<br/>
<br/>
<br/>
<b>ERRORS</b><br/>
<br/>
The graphics commands do not in many cases provide the user with error messages,<br/>
but instead, if an attempt is made to execute a command which is not possible, for<br/>
instance scrolling a screen window which lies partly off the screen, the command<br/>
will simply not execute. &nbsp;This does have the advantage that the user is freed<br/>
from testing edge conditions, but does mean that a little extra care needs to be<br/>
exercised. See the words ADJM and ADJV. &nbsp;Errors are generated if an attempt is<br/>
made to access a non-existent sprite, or to insert an already existing sprite<br/>
using ISPRITE.<br/>
<br/>
<br/>
<b>SPRITE AND BUFFER ORGANISATION</b><br/>
<br/>
Before discussing the sprite manipulation commands in detail, it is worth<br/>
describing the organisation of sprites in some detail. &nbsp;The user does not need<br/>
this information, but it is made available for interest and an overall<br/>
appreciation of the language structure.<br/>
<br/>
Sprites are stored as one contiguous block of data whose start address is held in<br/>
the variable SPST. &nbsp;The first free byte after the final sprite contains a zero and<br/>
this address is held in the variable SPND. &nbsp;The format of each sprite is as<br/>
follows:<br/>
<br/>
First byte &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Holds the sprite number which must be in the range<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 to 255.<br/>
<br/>
Second and &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Hold the address of the start of the next<br/>
third bytes &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprite.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 42
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
Fourth byte &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Holds the width of the sprite in characters (1 to 255).<br/>
<br/>
Fifth byte &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Holds the height of the sprite in characters (1 to 255).<br/>
<br/>
8*height*length bytes &nbsp; Pixel data.<br/>
<br/>
Height*length bytes &nbsp; &nbsp; Attribute data.<br/>
<br/>
This means that the total space allocated to each sprite is 9*height*length+5<br/>
bytes.<br/>
<br/>
Sprite numbers do not need to run sequentially, but the earlier a sprite is<br/>
defined, the more rapid its access.<br/>
<br/>
<br/>
<b>LOADING SPRITES FROM TAPE</b><br/>
<br/>
Sprites saved to tape using the development software can be loaded into the main<br/>
program at the start of the session when the "LOAD SPRITES Y/N" prompt appears.<br/>
If sprites are loaded in this manner, the sprite data, together with the necessary<br/>
pointers, will be loaded. &nbsp;SPST and SPND are automatically set and the sprites<br/>
will be ready for use.<br/>
<br/>
If sprites are saved and later loaded from White Lightning, SPST and SPND will<br/>
need to be set by hand.<br/>
<br/>
<br/>
<b>THE BUFFER</b><br/>
<br/>
When vertical scrolling takes place, be it for pixel data or attributes, with or<br/>
without wrap, data has to be temporarily stored for later retrieval. &nbsp;If a<br/>
vertical scroll is executed by the foreground program then the buffer is pointed<br/>
to by SPND, so the space immediately above sprites is used. &nbsp;When the sprite<br/>
development software is used, a prompt is issued at the start of the session,<br/>
which asks the user whether or not buffer size should be changed. &nbsp;If the buffer<br/>
size is not changed then it remains 256 bytes long. &nbsp;The user can enter a larger<br/>
or smaller value if preferred, though the default value of 256 will cover most<br/>
eventualities.<br/>
<br/>
Scrolling attributes uses one byte for each column of the width, scrolling pixel<br/>
data uses one byte for each column of the width, multiplied by the number of<br/>
pixels being scrolled (the value held in NPX, see vertical scrolls). &nbsp;The buffer<br/>
space need only be large enough to accommodate the largest scroll, as foreground<br/>
scrolls will not take place simultaneously. &nbsp;Suppose a sprite or screen window 8<br/>
characters high by 4 characters wide is to be scrolled by 10 pixels. &nbsp;(The<br/>
direction, i.e. the sign of NPX does not matter). &nbsp;The space required is 4 * 10 =<br/>
40 bytes. &nbsp;If you find at some later stage that you have not allowed enough buffer<br/>
space, you can always relocate sprite space downward and likewise, if you have<br/>
more than you need, you can relocate upwards.<br/>
<br/>
<br/>
<b>BACKGROUND SCROLLING</b><br/>
<br/>
When programs are executed in background (see Foreground/Background) it is risky<br/>
to share a common scrolling buffer, since the background program could execute<br/>
while the foreground program is using the buffer. &nbsp;For this reason, a second<br/>
buffer pointer is used for background scrolling. &nbsp;The variable holding the address<br/>
of the background buffer is SPND'. &nbsp;When White Lightning is first entered, SPND'<br/>
points to the 256 free bytes in the printer buffer at decimal 23296. &nbsp;The user can<br/>
move this buffer by changing the value held in SPND'. &nbsp;It is not a bad idea to<br/>
allocate enough buffer space, for both foreground and background scrolling above<br/>
<br/>
<br/>
<br/>
43
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
sprite space and assign SPND' to point to the space after the foreground buffer.<br/>
Suppose, for example, the foreground program requires 200 bytes and the background<br/>
300 bytes, with the buffer currently set to 256 bytes. &nbsp;500 bytes are needed in<br/>
all, so sprites need to be relocated down by 500 - 256 = 244 bytes. &nbsp;Type:<br/>
<br/>
-244 MLEN ! RELOCATE &lt;CR&gt;<br/>
<br/>
Note that MLEN is now negative since relocation is downward. &nbsp;SPND' should be set<br/>
200 bytes into the buffer to leave space for the foreground data. &nbsp;To do this<br/>
type:<br/>
<br/>
SPND @ 200 + SPND' ! &lt;CR&gt;<br/>
<br/>
If memory is really tight and the buffer has to be shared, then the background<br/>
program can be temporarily disabled using DI but as soon as the vertical scroll is<br/>
executed, an EI must be executed to re-enable the background program. &nbsp;If, for<br/>
example, a screen window 12 characters wide and 4 characters high is to be<br/>
scrolled vertically by 8 pixels with wrap, and the background program is to be<br/>
inhibited, type:<br/>
<br/>
0 0 AT 8 NPX ! 12 LEN ! 4 HGT ! 4 COL ! 4 ROW ! DI WCRV EI &lt;CR&gt;<br/>
<br/>
It is best to re-enable the background program as soon as possible, preferably, as<br/>
above, the next word.<br/>
<br/>
Until you get used to the package leave the buffers as they are on entry to White<br/>
Lightning. &nbsp;Use ISPRITE and DSPRITE, and not SPRITE and WIPE, to define new<br/>
sprites. &nbsp;The only time you really need to worry about changing buffer sizes or<br/>
positions is when you have a dire need to save a few extra bytes.<br/>
<br/>
<br/>
<b>IDEAL MNEMONICS</b><br/>
<br/>
To get the best out of the White Lightning package, please read these next<br/>
sections carefully and note the parameters. &nbsp;The words have been selected so as to<br/>
be as mnemonic as possible. &nbsp;To help yourself become acquainted with the language,<br/>
it is worth noting the following:<br/>
<br/>
&nbsp;1. &nbsp;Words which involve only the screen are postfixed "V" for "Video<br/>
&nbsp; &nbsp; &nbsp;Operations".<br/>
<br/>
&nbsp;2. &nbsp;Words which involve only operations on or between sprites, are postfixed<br/>
&nbsp; &nbsp; &nbsp;with "M" for "Memory Operations".<br/>
<br/>
&nbsp;3. &nbsp;Words which involve operations between the screen and sprites are postfixed<br/>
&nbsp; &nbsp; &nbsp;with "S" for "Screen/Sprite" operations.<br/>
<br/>
&nbsp;4. &nbsp;BLS indicates that data is being "Block Shifted" to a destination and will<br/>
&nbsp; &nbsp; &nbsp;replace whatever was there.<br/>
<br/>
&nbsp;5. &nbsp;ORS indicates that data is being "Shifted and OR'ed" so the destination data<br/>
&nbsp; &nbsp; &nbsp;will be OR'ed with the source data.<br/>
<br/>
&nbsp;6. &nbsp;NDS indicates that data is to be "Shifted and AND'ed".<br/>
<br/>
&nbsp;7. &nbsp;XRS indicates that data is to be "Shifted and XOR'ed".<br/>
<br/>
&nbsp;8. &nbsp;ATT indicates that the operation is on attribute data.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 44
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
&nbsp;9. &nbsp;WR implies that the data will be scrolled with wrap.<br/>
<br/>
10. &nbsp;SC implies that data will be scrolled without wrap.<br/>
<br/>
11. &nbsp;GW "Get Window" implies that data is being moved from a window into a<br/>
&nbsp; &nbsp; &nbsp;sprite.<br/>
<br/>
12. &nbsp;PW "Put Window" implies that data is being put into a window from a sprite.<br/>
<br/>
13. &nbsp;COP implies an operation between two sprites with the same dimensions.<br/>
<br/>
The best way to become familiar with the language is to use it!<br/>
<br/>
There are also some general points worth noting.<br/>
<br/>
<br/>
<b>GENERAL POINTS</b><br/>
<br/>
&nbsp;1. &nbsp;Vertical scrolls will require some buffer space at the end of sprite space,<br/>
&nbsp; &nbsp; &nbsp;so make sure that either you have set up sprite space with the development<br/>
&nbsp; &nbsp; &nbsp;package (the default of 256 is usually adequate), or that at least one COLD#<br/>
&nbsp; &nbsp; &nbsp;has been executed to make space. &nbsp;The space required for a scroll is<br/>
&nbsp; &nbsp; &nbsp;obtained by multiplying the width of the sprite, by the number of pixels<br/>
&nbsp; &nbsp; &nbsp;to be scrolled. &nbsp;Horizontal scrolls do not require buffer space. &nbsp;When<br/>
&nbsp; &nbsp; &nbsp;White Lightning is first Loaded without sprites, a COLD# is automatically<br/>
&nbsp; &nbsp; &nbsp;executed and sets the buffer to 256 bytes.<br/>
<br/>
&nbsp;2. &nbsp;All attribute scrolls are "with wrap".<br/>
<br/>
&nbsp;3. &nbsp;Commands prefixed with GET or PUT are operations between a whole sprite<br/>
&nbsp; &nbsp; &nbsp;and a screen window. &nbsp;These are very fast and can be made even faster<br/>
&nbsp; &nbsp; &nbsp;by suppressing the movement of attribute data, if its transference is<br/>
&nbsp; &nbsp; &nbsp;not required. &nbsp;To suppress attribute data use the word ATTOFF. &nbsp;If you<br/>
&nbsp; &nbsp; &nbsp;wish to switch data flow back on at a later stage, use ATTON. &nbsp;The switch<br/>
&nbsp; &nbsp; &nbsp;remains in its state until changed by the execution of one of these<br/>
&nbsp; &nbsp; &nbsp;two words or the execution of a word beginning with GW or PW and ending<br/>
&nbsp; &nbsp; &nbsp;with S (group 2 GETS and PUTS). &nbsp;NEVER assume the state of the switch<br/>
&nbsp; &nbsp; &nbsp;at the start of the program: &nbsp;one of your first words at the beginning<br/>
&nbsp; &nbsp; &nbsp;of your program should be ATTON or ATTOFF.<br/>
<br/>
&nbsp;4. &nbsp;If a sprite is dynamically allocated space at runtime it will probably<br/>
&nbsp; &nbsp; &nbsp;contain garbage in its pixel and attribute data, so both will need to be<br/>
&nbsp; &nbsp; &nbsp;set up. &nbsp;It is all too easy to forget the attributes.<br/>
<br/>
&nbsp;5. &nbsp;Sometimes the dynamically created sprites will contain zeroes; if you set<br/>
&nbsp; &nbsp; &nbsp;up the pixel data and forget the attribute data then execute a PUT to<br/>
&nbsp; &nbsp; &nbsp;the screen with the attributes on - a black rectangle will appear. See<br/>
&nbsp; &nbsp; &nbsp;SETAM.<br/>
<br/>
&nbsp;6. &nbsp;If you want to wipe a sprite off the screen but not affect any other<br/>
&nbsp; &nbsp; &nbsp;pixel data within its screen window, use PUTXRS. &nbsp;Remember, though, that<br/>
&nbsp; &nbsp; &nbsp;if you have carried out any operations on the original sprite since<br/>
&nbsp; &nbsp; &nbsp;doing the original PUTBLS or PUTXRS it may not work.<br/>
<br/>
&nbsp;7. &nbsp;If you want to leave a sprite on the screen but clear all other pixel data<br/>
&nbsp; &nbsp; &nbsp;in its screen window use PUTNDS. &nbsp;Again, be sure that no intermediary<br/>
&nbsp; &nbsp; &nbsp;operations have taken place.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
45
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
&nbsp;8. &nbsp;If you wish to PUT a sprite onto the screen over the top of the existing<br/>
&nbsp; &nbsp; &nbsp;data in the window, then you should use PUTORS.<br/>
<br/>
&nbsp;9. &nbsp;Points 6-8 apply to operations in memory, although the words used are<br/>
&nbsp; &nbsp; &nbsp;of course different.<br/>
<br/>
10. &nbsp;The best way to get to knew the PUTs and GETs is to experiment with them;<br/>
&nbsp; &nbsp; &nbsp;you will soon realise how to move sprites. &nbsp;For those of you not yet<br/>
&nbsp; &nbsp; &nbsp;familiar with what "AND", "OR" and "XOR" mean, note the following:<br/>
<br/>
&nbsp; &nbsp; &nbsp;a) &nbsp;If two sprites are AND'ed, then only those pixels set in both will<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;remain set when the sprites are AND'ed together.<br/>
<br/>
&nbsp; &nbsp; &nbsp;b) &nbsp;If two sprites are OR'ed, then all those pixels set in either sprite<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;will be set in the result.<br/>
<br/>
&nbsp; &nbsp; &nbsp;c) &nbsp;If two sprites are XOR'ed, then all those pixels set in either<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sprite will be set in the result, but this time, all pixels where<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;both were set will now be reset.<br/>
<br/>
&nbsp; &nbsp; &nbsp;d) &nbsp;All "Block Shift" commands will destroy whatever was previously<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;in the window.<br/>
<br/>
11. &nbsp;It is possible to set up "masks" in dummy sprites and use the boolean<br/>
&nbsp; &nbsp; &nbsp;operations OR, XOR and AND to move windows around etc.<br/>
<br/>
12. &nbsp;If you wish to make something appear at lightning speed, leave the data<br/>
&nbsp; &nbsp; &nbsp;on the screen and fill the window with zero attributes or attributes with<br/>
&nbsp; &nbsp; &nbsp;the same INK and PAPER colour. &nbsp;To make the sprite appear you need only<br/>
&nbsp; &nbsp; &nbsp;download the attributes using PWATTS; to make it disappear use<br/>
&nbsp; &nbsp; &nbsp;PWATTS again, but this time, download stored attributes with the same ink<br/>
&nbsp; &nbsp; &nbsp;and paper colour, or use SETAV.<br/>
<br/>
13. &nbsp;It is possible to use the TEST command to gain direct access<br/>
&nbsp; &nbsp; &nbsp;to the attributes in the sprite memory. &nbsp;They are located at DPTR+ 8*LEN*HGT<br/>
&nbsp; &nbsp; &nbsp;and can be easily block filled.<br/>
<br/>
14. &nbsp;Most animation routines use only the variables:<br/>
<br/>
&nbsp; &nbsp; &nbsp;HGT &nbsp; Height of window<br/>
&nbsp; &nbsp; &nbsp;LEN &nbsp; Width of window<br/>
&nbsp; &nbsp; &nbsp;COL &nbsp; Screen column of top left character<br/>
&nbsp; &nbsp; &nbsp;ROW &nbsp; Screen row of top left character<br/>
&nbsp; &nbsp; &nbsp;SCOL &nbsp;Sprite column of top left character<br/>
&nbsp; &nbsp; &nbsp;SROW &nbsp;Sprite row of top left character<br/>
&nbsp; &nbsp; &nbsp;SPN &nbsp; Sprite number<br/>
&nbsp; &nbsp; &nbsp;SP1 &nbsp; Number of first sprite in a double sprite operation<br/>
&nbsp; &nbsp; &nbsp;SP2 &nbsp; Number of second sprite in a double sprite operation<br/>
<br/>
&nbsp; &nbsp; &nbsp;Columns are measured in characters (8 pixels by 8 pixels) and are counted<br/>
&nbsp; &nbsp; &nbsp;from the left, 0 to 31.<br/>
<br/>
&nbsp; &nbsp; &nbsp;Rows are measured in characters and are counted from the top 0 to 23.<br/>
<br/>
&nbsp; &nbsp; &nbsp;Remember, never change a variable unless you need to, they are not<br/>
&nbsp; &nbsp; &nbsp;reset between instructions (with the exception of ADJM and ADJV, and<br/>
&nbsp; &nbsp; &nbsp;you can always write your code to order the operations in such a way as<br/>
&nbsp; &nbsp; &nbsp;to minimise the resetting of variables.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 46
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
15. &nbsp;If a word ending in V (screen operation) does not execute, it is almost<br/>
&nbsp; &nbsp; &nbsp;always because the window you have defined does not lie wholly on the<br/>
&nbsp; &nbsp; &nbsp;screen. &nbsp;That is to say, that COL + LEN is not in the range 1 to 32, or<br/>
&nbsp; &nbsp; &nbsp;ROW + HGT is not in the range 1 to 24. &nbsp;See ADJV.<br/>
<br/>
16. &nbsp;If a word ending in S (screen/sprite operation) does not execute, then<br/>
&nbsp; &nbsp; &nbsp;again, it is almost always because the sprite width + COL is not in the<br/>
&nbsp; &nbsp; &nbsp;range 1 to 32 or the sprite height + ROW is not in the range 1 to 24.<br/>
&nbsp; &nbsp; &nbsp;See ADJM.<br/>
<br/>
17. &nbsp;If a word ending in S that is also a window command (second letter W)<br/>
&nbsp; &nbsp; &nbsp;does not execute, it may be for the reasons outlined in 16, or it may be<br/>
&nbsp; &nbsp; &nbsp;that SCOL + LEN or SROW + HGT do not lie within the width and height of<br/>
&nbsp; &nbsp; &nbsp;the sprite containing the window.<br/>
<br/>
18. &nbsp;If a word ending in M that is not a window command does not execute,<br/>
&nbsp; &nbsp; &nbsp;the sprite probably does not exist; if it is a window command, then it<br/>
&nbsp; &nbsp; &nbsp;is likely that the width of the first sprite + ROW or the height of the<br/>
&nbsp; &nbsp; &nbsp;first sprite + SCOL do not lie within the width and height of the<br/>
&nbsp; &nbsp; &nbsp;sprite containing the window.<br/>
<br/>
19. &nbsp;Remember that the SPIN command needs a second sprite to rotate into,<br/>
&nbsp; &nbsp; &nbsp;and that its dimensions should be the reverse of the sprite to be<br/>
&nbsp; &nbsp; &nbsp;spun. &nbsp;For real speed, it is best to store the sprite in each of its<br/>
&nbsp; &nbsp; &nbsp;4 orientations.<br/>
<br/>
20. &nbsp;If you wish to do a vertical mirror, just SPIN, do a horizontal<br/>
&nbsp; &nbsp; &nbsp;mirror, and SPIN back.<br/>
<br/>
21. &nbsp;It is good policy always to make the sprite one character higher and<br/>
&nbsp; &nbsp; &nbsp;wider than the graphic character itself; this will enable you to scroll<br/>
&nbsp; &nbsp; &nbsp;the character within the sprite and give pixel resolution when using<br/>
&nbsp; &nbsp; &nbsp;the PUT commands.<br/>
<br/>
22. &nbsp;If memory permits, it is a good idea to keep a "back-up" of each sprite<br/>
&nbsp; &nbsp; &nbsp;held under a different number, so that if an error is made and a sprite<br/>
&nbsp; &nbsp; &nbsp;corrupted, it can be copied back from the copy. &nbsp;They can always be deleted<br/>
&nbsp; &nbsp; &nbsp;from the final program.<br/>
<br/>
23. &nbsp;Never execute the NEW or CLEAR commands when in BASIC.<br/>
<br/>
24. &nbsp;If a sprite driven under interrupt disappears from the screen or<br/>
&nbsp; &nbsp; &nbsp;flickers, it is probably a timing related problem and re-ordering<br/>
&nbsp; &nbsp; &nbsp;the code will almost certainly solve the problem.<br/>
<br/>
25. &nbsp;Screens can be moved up and down memory using the CMOVE word. Each screen<br/>
&nbsp; &nbsp; &nbsp;occupies 512 bytes and the addresses are listed in Table 1, the Table<br/>
&nbsp; &nbsp; &nbsp;of Screen Addresses.<br/>
<br/>
26. &nbsp;If you are using the Background facility, the top 16 bytes of RAM will be<br/>
&nbsp; &nbsp; &nbsp;used, so any data stored there will be corrupted. &nbsp;To avoid this, make<br/>
&nbsp; &nbsp; &nbsp;sure you have enough scrolling buffer and keep the top of sprite space<br/>
&nbsp; &nbsp; &nbsp;below 65520.<br/>
<br/>
27. &nbsp;If you execute SETAM or SETAV in background, set the FLASH attribute<br/>
&nbsp; &nbsp; &nbsp;in the background program.<br/>
<br/>
28. &nbsp;If you wish sprite space to "grow" upward use SPRITE and WIPE, otherwise<br/>
&nbsp; &nbsp; &nbsp;always use ISPRITE and DSPRITE for sprite allocation.<br/>
<br/>
29. &nbsp;BAD RAMTOP error, usually means you have not RESERVED sufficient<br/>
&nbsp; &nbsp; &nbsp;space for your BASIC program.<br/>
<br/>
<br/>
47
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>SPRITE UTILITIES</b><br/>
<br/>
All the sprite utilities described in this section are available at run-time, but<br/>
we strongly recommend that all sprite allocation is undertaken at the sprite<br/>
development stage to save laboriously reloading sprite data if an error is made at<br/>
run-time. &nbsp;They are provided for advanced programming applications only and should<br/>
never be executed in background.<br/>
<br/>
<br/>
<b>COLD #</b><br/>
<br/>
This command sets the end of sprite space pointer SPND, to the value in SPST, the<br/>
start of sprite space pointer. &nbsp;It then clears memory above SPST. &nbsp;The size of the<br/>
memory cleared is specified in SLEN. &nbsp;Each time a sprite is allocated space using<br/>
the SPRITE command, SPND is updated. &nbsp;Vertical scroll data (pixel and attribute)<br/>
uses the space immediately above SPND so a COLD# is necessary at some stage before<br/>
executing the commands. &nbsp;The amount of data required is given by the product of<br/>
the scroll width and the number of pixels scrolled. &nbsp;sprites are stored in the<br/>
following format:<br/>
<br/>
First byte is the sprite number &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(1 to 255)<br/>
Second and third bytes hold the address of the next sprite in memory.<br/>
Fourth byte is the sprite width &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(1 to 255)<br/>
Fifth byte is the sprite height &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(1 to 255)<br/>
The next 8*height*length bytes hold pixel data.<br/>
The final height*length bytes hold the attributes.<br/>
Therefore, each sprite requires 9*height*length+5 bytes.<br/>
<br/>
It should be noted that sprite numbers need not be allocated in any particular<br/>
order. &nbsp;The best position for sprite space is at the top of memory and it is not<br/>
difficult to calculate space required, although the development package does this<br/>
automatically.<br/>
<br/>
To calculate the total sprite space that will be used, use 9*length*height+5 for<br/>
each sprite and then add buffer space for vertical scrolls, 256 should be<br/>
sufficient for most applications. &nbsp;This total should be assigned to SLEN. &nbsp;SPST<br/>
should then be assigned with 65520-SLEN.<br/>
<br/>
<br/>
Example:<br/>
<br/>
Suppose you wished to allocate space for 10 4 by 4 sprites, 3 8 by 6 sprites and a<br/>
5 by 4 sprite. &nbsp;Suppose also that a 4 pixel scroll will be required for a 4<br/>
character wide sprite, and a screen window 9 characters wide will need to be<br/>
scrolled 3 pixels. &nbsp;The 8 by 6 sprite is also to be rotated. &nbsp;The following<br/>
procedure to calculate sprite space is required.<br/>
<br/>
10 &nbsp;4 by 4 sprites require &nbsp; &nbsp; &nbsp;10*(4*4*9+5) = 1490 bytes<br/>
&nbsp;3 &nbsp;8 by 6 sprites require &nbsp; &nbsp; &nbsp; 3*(8*6*9+5) = 1311 bytes<br/>
&nbsp;1 &nbsp;5 by 4 sprite requires &nbsp; &nbsp; &nbsp; 1*(i*4*9+5) = &nbsp;185 bytes<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TOTAL &nbsp;= 2986 bytes<br/>
<br/>
The 4 character wide sprite scrolling 4 pixels would require 16 bytes.<br/>
The 9 character wide screen window scrolling 3 pixels would require 27 bytes.<br/>
If we allow 27, then this will cover both eventualities and we can forget the 16<br/>
bytes for the first case.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TOTAL &nbsp;= 27 bytes<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 48
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
A dummy sprite 6 by 8 is also required for the rotation so:<br/>
<br/>
&nbsp;1 &nbsp;6 by 8 sprite requires &nbsp; &nbsp; &nbsp; 1*(6*8*9+5) = &nbsp;437 bytes<br/>
<br/>
So the overall total is &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2986+27+437 = 3450 bytes<br/>
<br/>
If this is to be located at the top of memory, then SPST will need to be set to<br/>
65520 - 3450 = 62070. &nbsp;Note that memory 65520 to 65536 is used for background<br/>
applications.<br/>
<br/>
In this case you would use the following:<br/>
<br/>
62070 SPST ! 3450 SLEN ! COLD#<br/>
<br/>
SPND will be automatically set to 62070.<br/>
<br/>
If all this seems a bit complicated, don't worry. &nbsp;A far simpler way of setting up<br/>
sprites is to use the ISPRITE and DSPRITE commands described later in this<br/>
section. &nbsp;You won't even need to execute a COLD# command.<br/>
<br/>
<br/>
<b>SPRITE</b><br/>
<br/>
Once the sprite space has been cleared, the sprites themselves can be set up.<br/>
<br/>
Parameters &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Use<br/>
<br/>
SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Number of the sprite to be set up<br/>
HGT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Height of the sprite in characters<br/>
LEN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Width of the sprite in characters<br/>
<br/>
<br/>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Action<br/>
<br/>
<b>SPRITE</b> &nbsp; &nbsp; &nbsp; &nbsp;The five byte leader is set up and SPND adjusted<br/>
<br/>
Note:<br/>
<br/>
If space is dynamically allocated to a sprite, the sprite will not necessarily be<br/>
initialised and may contain garbage. &nbsp;If a sprite is being set up at run-time, be<br/>
sure that sufficient memory is available. &nbsp;If a sprite number is given that has<br/>
been previously used, the old sprite is destroyed and recreated with the new<br/>
dimensions. &nbsp;If sufficient memory is not available, then either an old sprite can<br/>
be destroyed or the whole of sprite space can be relocated downwards if space is<br/>
available. &nbsp;Most users will probably not use the SPRITE command, but instead, will<br/>
use the far simpler ISPRITE command.<br/>
<br/>
<br/>
<b>WIPE</b><br/>
<br/>
This command will destroy the sprite whose number is held in SPN, relocate the<br/>
sprites above it downward, update the variable SPND (marking the end of sprite<br/>
space) and leave the particular sprite number free for reallocation.<br/>
<br/>
<br/>
Parameter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Use<br/>
<br/>
SPND &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;The number of the sprite to be wiped<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
49
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Action<br/>
<br/>
<b>WIPE</b> &nbsp; &nbsp; &nbsp; &nbsp; Destroy a sprite and adjust memory<br/>
<br/>
<br/>
<b>RELOCATE</b><br/>
<br/>
An alternative method for creating more space to define new sprites, is to<br/>
relocate sprite space downward. &nbsp;Only one parameter is required, MLEN. &nbsp;A positive<br/>
value in MLEN will relocate sprites to high memory and a negative value will<br/>
relocate them downward. &nbsp;All pointers are reset.<br/>
<br/>
<br/>
Parameter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Use<br/>
<br/>
MLEN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Size and direction of relocation<br/>
<br/>
<br/>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Action<br/>
<br/>
<b>RELOCATE</b> &nbsp; &nbsp; &nbsp;Relocate all sprite data and reset pointers<br/>
<br/>
Example:<br/>
<br/>
If space for a 4 by 4 sprite is to be made and the existing buffer space<br/>
maintained, the sprites would need to be relocated downward by 4*4*9+5 = 149. To<br/>
do this use the following:<br/>
<br/>
-149 MLEN ! RELOCATE<br/>
<br/>
<br/>
<b>TEST</b><br/>
<br/>
For advanced applications there is a command to interrogate sprite details. &nbsp;SPN<br/>
is loaded with the number of the sprite to be interrogated, and after execution,<br/>
the following parameters will be set:<br/>
<br/>
HGT &nbsp; will hold the height of the sprite<br/>
LEN &nbsp; will hold the width of the sprite<br/>
SPTR &nbsp;will hold the address of the first byte of the sprite header<br/>
DPTR &nbsp;will hold the address of the first byte of the pixel data<br/>
SIZE &nbsp;will hold the amount of memory occupied by the sprite<br/>
<br/>
In order to calculate the start of attribute data, use DPTR+8*HGT*LEN. &nbsp;Note that<br/>
HGT, LEN, SPTR and DPTR will all be zero if the sprite wasn't found.<br/>
<br/>
A true or false flag is also placed on the stack. &nbsp;True means the sprite exists<br/>
and false means it doesn't.<br/>
<br/>
<br/>
Examples:<br/>
<br/>
To see if sprite 34 exists, and print its dimensions if it does - use:<br/>
<br/>
34 SPN ! TEST IF HGT ? LEN ? CR ENDIF<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 50
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>ISPRITE AND DSPRITE</b><br/>
<br/>
If sprites are located at the top of memory, then ISPRITE and DSPRITE can be used<br/>
to create and destroy sprites without the need for any complex calculations.<br/>
ISPRITE will insert a sprite at the top of memory, maintain the buffer space and<br/>
automatically relocate the rest of sprite space downward. &nbsp;DSPRITE will destroy an<br/>
old sprite and relocate sprite space upward. &nbsp;The easiest way to use this package<br/>
is to leave the buffer space as it is, then just use ISPRITE and DSPRITE to CREATE<br/>
and DESTROY sprites. &nbsp;SPRITE, WIPE, COLD# and RELOCATE are for advanced<br/>
applications where sprites are created during program execution. &nbsp;If a "ZAPPED"<br/>
program were to execute ISPRITE the sprites would extend downwards and could<br/>
overwrite the object code of the main program which lies just beneath SPST. &nbsp;If a<br/>
program runs before being "ZAPPED", but the final run-time version crashes, this<br/>
is where to look!<br/>
<br/>
<br/>
Parameter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Use<br/>
<br/>
SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Number of the sprite to be inserted<br/>
HGT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Height of the sprite to be inserted<br/>
LEN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Length of the sprite be be inserted<br/>
<br/>
<br/>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Action<br/>
<br/>
<b>ISPRITE</b> &nbsp; &nbsp; &nbsp;Create new sprite and adjust memory<br/>
<br/>
<br/>
Parameter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Use<br/>
<br/>
SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Number of sprite to be inserted<br/>
<br/>
<br/>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Action<br/>
<br/>
<b>DSPRITE</b> &nbsp; &nbsp; &nbsp;Wipe old sprite and adjust memory<br/>
<br/>
<br/>
Note:<br/>
<br/>
Be sure sufficient memory is available before executing ISPRITE. &nbsp;SPST holds the<br/>
start; after execution, SPST will became SPST - 9*HGT*LEN-5.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
51
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>SCROLLING</b><br/>
<br/>
<b>SCREEN SCROLLS</b><br/>
<br/>
The horizontal screen scrolls are by 1, 4 or 8 pixels, left or right and with or<br/>
without wrap. &nbsp;The vertical scrolls are slightly more flexible. &nbsp;The variable NPX<br/>
is loaded with the number of pixels to be scrolled, positive for upward movement<br/>
and negative for downward movement. &nbsp;In each case, a screen window has to be<br/>
defined.<br/>
<br/>
<br/>
Horizontal Scrolls<br/>
<br/>
Parameter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Use<br/>
<br/>
COL &nbsp; &nbsp; &nbsp; &nbsp; Column of the left hand edge of the window (0-31)<br/>
ROW &nbsp; &nbsp; &nbsp; &nbsp; Row of the top edge of the window (0-23)<br/>
LEN &nbsp; &nbsp; &nbsp; &nbsp; Width of the window (1-32)<br/>
HGT &nbsp; &nbsp; &nbsp; &nbsp; Height of the window (1-24)<br/>
<br/>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Action<br/>
<br/>
<b>WRL1V</b> &nbsp; &nbsp; &nbsp; Scroll left &nbsp;1 pixel &nbsp;with wrap<br/>
<b>WRR1V</b> &nbsp; &nbsp; &nbsp; Scroll right 1 pixel &nbsp;with wrap<br/>
<b>SCL1V</b> &nbsp; &nbsp; &nbsp; Scroll left &nbsp;1 pixel, &nbsp; no wrap<br/>
<b>SCR1V</b> &nbsp; &nbsp; &nbsp; Scroll right 1 pixel, &nbsp; no wrap<br/>
<b>WRL4V</b> &nbsp; &nbsp; &nbsp; Scroll left &nbsp;4 pixels with wrap<br/>
<b>WRR4V</b> &nbsp; &nbsp; &nbsp; Scroll right 4 pixels with wrap<br/>
<b>SCL4V</b> &nbsp; &nbsp; &nbsp; Scroll left &nbsp;4 pixels, &nbsp;no wrap<br/>
<b>SCR4V</b> &nbsp; &nbsp; &nbsp; Scroll right 4 pixels, &nbsp;no wrap<br/>
<b>WRL8V</b> &nbsp; &nbsp; &nbsp; Scroll left &nbsp;8 pixels with wrap<br/>
<b>WRR8V</b> &nbsp; &nbsp; &nbsp; Scroll right 8 pixels with wrap<br/>
<b>SCL8V</b> &nbsp; &nbsp; &nbsp; Scroll left &nbsp;8 pixels, &nbsp;no wrap<br/>
<b>SCR8V</b> &nbsp; &nbsp; &nbsp; Scroll right 8 pixels, &nbsp;no wrap<br/>
<br/>
Note:<br/>
<br/>
Before executing any of these commands, the window needs to be set up using the<br/>
four parameters above. &nbsp;If the command does not execute, it is likely that part of<br/>
the window does not lie on the screen. &nbsp;COL + LEN should be in the range 1 to 32<br/>
and LEN + HGT should be in the range 1 to 24.<br/>
<br/>
Example:<br/>
<br/>
To see these commands work, it is a good idea to do a VLIST first so that there is<br/>
some data on the screen. &nbsp;The four parameters will need to be set, unless of<br/>
course they have previously been defined, but for this example let us assume that<br/>
they haven't. &nbsp;To scroll a window at COL 4, ROW 5 with height 4 characters and<br/>
width 3 characters, with wrap, 4 pixels left, type the following:<br/>
<br/>
4 COL ! 5 ROW ! 4 HGT ! 3 LEN ! WRL4V &lt;CR&gt;<br/>
<br/>
If there is no data on the screen, type:<br/>
<br/>
VLIST 4 COL ! 5 ROW ! 4 HGT ! 3 LEN ! WRL4V &lt;CR&gt;<br/>
<br/>
A window column 4 Row 5 has been scrolled left 4 pixels - if you didn't see it<br/>
happen type:<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 52
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
WRL4V WRL4V WRL4V<br/>
<br/>
and you should see it!<br/>
<br/>
Parameters do not reset after the execution of the commands, &nbsp;so to repeat the<br/>
above, this time at column 10 and without wrap, you could use the following:<br/>
<br/>
10 COL ! SCL4V &lt;CR&gt;<br/>
<br/>
<br/>
<b>Vertical scrolls</b><br/>
<br/>
These work in a similar way to the horizontal scrolls, but in addition to setting<br/>
up the window with the four window parameters COL, ROW, HGT and LEN, a further<br/>
variable NPX is used to give the size and direction of the scroll in pixels. A<br/>
positive value for NPX causes upward scrolling and a negative value causes<br/>
downward scrolling.<br/>
<br/>
<br/>
Parameter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Use<br/>
<br/>
COL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Column at left hand edge of window (0-31)<br/>
ROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Row of top left edge of the window (0-23)<br/>
LEN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Width of the window (1-32)<br/>
HGT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Height of the window (1-24)<br/>
<br/>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Action<br/>
<br/>
<b>WCRV</b> &nbsp; &nbsp; &nbsp; &nbsp; Vertical scroll with wrap<br/>
<b>SCRV</b> &nbsp; &nbsp; &nbsp; &nbsp; Vertical scroll, no wrap<br/>
<br/>
Note:<br/>
<br/>
All vertical scrolling of pixel data and/or attributes for screen or sprites,<br/>
requires buffer space. &nbsp;The space required is calculated by multiplying NPX by<br/>
LEN. &nbsp;The start of the buffer is taken as the next free byte after sprite space,<br/>
so be sure that either a COLD# has been executed, or that SPND has been set. &nbsp;It<br/>
is safe practice to develop sprites using the software provided, and to allow 256<br/>
bytes buffer at the top before linking with the main program. &nbsp;Be sure also that<br/>
the scroll length is not greater than the window's size. &nbsp;On entry to White<br/>
Lightning a COLD# is automatically executed and a scrolling buffer of 256 bytes<br/>
is set up. &nbsp;This is maintained so long as ISPRITE and DSPRITE are used in<br/>
preference to SPRITE and WIPE.<br/>
<br/>
<br/>
<b>Attribute Scrolls</b><br/>
<br/>
Attribute scrolls are similar to the pixel data scrolls but all scrolls are always<br/>
by one character, with wrap.<br/>
<br/>
<br/>
Parameter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Use<br/>
<br/>
COL &nbsp; &nbsp; &nbsp; &nbsp;Column of the left hand edge of the window (0-31)<br/>
ROW &nbsp; &nbsp; &nbsp; &nbsp;Row of the top edge of the window (0-23)<br/>
LEN &nbsp; &nbsp; &nbsp; &nbsp;Width of the window (1-32)<br/>
HGT &nbsp; &nbsp; &nbsp; &nbsp;Height of the window (1-24)<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
53
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Action<br/>
<br/>
<b>ATTLV</b> &nbsp; &nbsp; &nbsp;Scroll attributes left &nbsp;1 character with wrap<br/>
<b>ATTRV</b> &nbsp; &nbsp; &nbsp;Scroll attributes right 1 character with wrap<br/>
<b>ATTUPV</b> &nbsp; &nbsp; Scroll attributes up &nbsp; &nbsp;1 character with wrap<br/>
<b>ATTDNV</b> &nbsp; &nbsp; Scroll attributes down &nbsp;1 character with wrap<br/>
<br/>
<br/>
<b>SPRITE SCROLLS</b><br/>
<br/>
The format for these commands is similar to that for the screen scrolls, except<br/>
that these commands are postfixed with an M as opposed to a V.<br/>
<br/>
<br/>
<b>Horizontal Scrolls</b><br/>
<br/>
Parameters &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Use<br/>
<br/>
SPN &nbsp; &nbsp; &nbsp; &nbsp;The number of the sprite to be scrolled (1 to 255)<br/>
<br/>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Actions<br/>
<br/>
<b>WRL1M</b> &nbsp; &nbsp; &nbsp;Scroll left &nbsp;1 pixel &nbsp;with wrap<br/>
<b>WRR1M</b> &nbsp; &nbsp; &nbsp;Scroll right 1 pixel &nbsp;with wrap<br/>
<b>SCL1M</b> &nbsp; &nbsp; &nbsp;Scroll left &nbsp;1 pixel, &nbsp; no wrap<br/>
<b>SCR1M</b> &nbsp; &nbsp; &nbsp;Scroll right 1 pixel, &nbsp; no wrap<br/>
<b>WRL4M</b> &nbsp; &nbsp; &nbsp;Scroll left &nbsp;4 pixels with wrap<br/>
<b>WRR4M</b> &nbsp; &nbsp; &nbsp;Scroll right 4 pixels with wrap<br/>
<b>SCL4M</b> &nbsp; &nbsp; &nbsp;Scroll left &nbsp;4 pixels, &nbsp;no wrap<br/>
<b>SCR4M</b> &nbsp; &nbsp; &nbsp;Scroll right 4 pixels, &nbsp;no wrap<br/>
<b>WRL8M</b> &nbsp; &nbsp; &nbsp;Scroll left &nbsp;8 pixels with wrap<br/>
<b>WRR8M</b> &nbsp; &nbsp; &nbsp;Scroll right 8 pixels with wrap<br/>
<b>SCL8M</b> &nbsp; &nbsp; &nbsp;Scroll left &nbsp;8 pixels, &nbsp;no wrap<br/>
<b>SCR8M</b> &nbsp; &nbsp; &nbsp;Scroll right 8 pixels, &nbsp;no wrap<br/>
<br/>
Note:<br/>
<br/>
The chief purpose of these commands is to give pixel resolution to the PUT<br/>
command, and for this reason, a 1 character border along 2 edges of a sprite<br/>
character should always be allowed.<br/>
<br/>
Example:<br/>
<br/>
To scroll sprite number 7, 1 pixel right with wrap, use:<br/>
<br/>
7 SPN ! WRR1M<br/>
<br/>
<b>Vertical Scrolls</b><br/>
<br/>
These work in the same way as the vertical screen scrolls where the signed<br/>
variable NPX is used to determine the size and direction of the scroll.<br/>
<br/>
Parameters &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Use<br/>
<br/>
SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Number of the sprite to be scrolled<br/>
NPX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Number of pixels to be scrolled<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 54
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Action<br/>
<br/>
<b>WCRM</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Vertical scroll with wrap<br/>
<b>SCRM</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Vertical scroll, no wrap<br/>
<br/>
Example:<br/>
<br/>
To scroll sprite 5 downward by 11 pixels with wrap, use:<br/>
<br/>
5 SPN ! -11 NPX ! WCRM<br/>
<br/>
<br/>
<b>Attribute Scrolls</b><br/>
<br/>
There are four commands to scroll attributes in any of the four directions:<br/>
<br/>
Parameter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Use<br/>
<br/>
SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Number of the sprite to be scrolled<br/>
<br/>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Action<br/>
<br/>
<b>ATTLM</b> &nbsp; &nbsp; &nbsp; &nbsp;Scroll attributes left &nbsp;with wrap<br/>
<b>ATTRM</b> &nbsp; &nbsp; &nbsp; &nbsp;Scroll attributes right with wrap<br/>
<b>ATTUPM</b> &nbsp; &nbsp; &nbsp; Scroll attributes up &nbsp; &nbsp;with wrap<br/>
<b>ATTDNM</b> &nbsp; &nbsp; &nbsp; Scroll attributes down &nbsp;with wrap<br/>
<br/>
<br/>
<b>GETS AND PUTS</b><br/>
<br/>
There are three groups of GETs and PUTs. &nbsp;The first, and the fastest, carry out<br/>
operations between a full sprite and a previously defined window of the screen.<br/>
The second group carry out operations between sprite windows and screen windows.<br/>
The third, and probably most powerful group of commands in the sub-language, cover<br/>
operations between sprite windows and other sprites.<br/>
<br/>
Suppose you have designed a sprite 160 characters wide (5 screens) and you wish to<br/>
smoothly pixel scroll through this sprite via a screen window covering the bottom<br/>
five character rows of the screen. &nbsp;A second dummy sprite, 1 character wider than<br/>
the screen can be used to GET from the larger sprite, scroll, PUT, scroll, Put and<br/>
so on for 1 character, then a second block, 1 character further into the larger<br/>
sprite can be GOT and so on. &nbsp;Experimentation will soon show you how to do this.<br/>
These routines can be run in background to provide fast smooth scrolling<br/>
backdrops.<br/>
<br/>
<br/>
<b>Group 1</b><br/>
<br/>
This group provides block moves and logical operations between sprites and screen<br/>
windows - these are the fastest commands in the set. &nbsp;This particular group does<br/>
not include separate attribute commands but instead uses an attribute switch. &nbsp;If<br/>
the switch is on, pixel data and attribute data are moved; if you do not require<br/>
to move attributes you can increase the speed of operations by switching off the<br/>
attribute switch.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
55
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Action<br/>
<br/>
<b>ATTON</b> &nbsp; &nbsp;Enable the flow of attribute data between the sprite and the screen<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;window<br/>
<b>ATTOFF</b> &nbsp; Disable the flow of attributes between the sprite and the screen<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;window<br/>
<br/>
We now come to the group 1 commands themselves:<br/>
<br/>
<br/>
<b>GETS</b><br/>
<br/>
Parameter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Use<br/>
<br/>
SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Number of the sprite to be used (1 to 255)<br/>
COL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Left hand column of target screen window (0 to 31)<br/>
ROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Top row of target screen window (0 to 23)<br/>
<br/>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Action<br/>
<br/>
<b>GETBLS</b> &nbsp; &nbsp; &nbsp; Block move screen window into sprite<br/>
<b>GETORS</b> &nbsp; &nbsp; &nbsp; OR screen window into sprite<br/>
<b>GETXRS</b> &nbsp; &nbsp; &nbsp; XOR screen window into sprite<br/>
<b>GETNDS</b> &nbsp; &nbsp; &nbsp; AND screen window into sprite<br/>
<br/>
Note:<br/>
<br/>
The dimensions of the screen window are taken as the dimensions of the sprite. &nbsp;If<br/>
the command doesn't execute, it is almost certainly because the width of the<br/>
sprite + COL or the height of the sprite + ROW, exceed 32 or 24 respectively, so<br/>
that part of the window lies off the screen. &nbsp;Sprites must be previously set up<br/>
either by the development software, or the COLD# and SPRITE or ISPRITE commands<br/>
before these commands will execute.<br/>
<br/>
Example:<br/>
<br/>
To GET a screen sprite into sprite number 4 from column 5, row 4, with attributes<br/>
and "OR" it with the data currently held in sprite number 4, use the following:<br/>
<br/>
4 SPN ! 5 COL ! 4 ROW ! ATTON GETORS<br/>
<br/>
Note that if ATTON was the last switch command, it would not be needed in the<br/>
above.<br/>
<br/>
<br/>
<b>PUTS</b><br/>
<br/>
These commands are identical to the group 1 "GETS" except that data transfer is<br/>
from the sprite to the screen. &nbsp;The results of the various operations are<br/>
therefore displayed to the screen. &nbsp;The parameters are identical in operation to<br/>
those of the "GETS", and the ATTON and ATTOFF switch commands also apply.<br/>
<br/>
<br/>
Parameter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Use<br/>
<br/>
SPN &nbsp; &nbsp; &nbsp; &nbsp; Number of the sprite to be used (1 to 255)<br/>
COL &nbsp; &nbsp; &nbsp; &nbsp; Left hand column of target screen window (0 to 31)<br/>
ROW &nbsp; &nbsp; &nbsp; &nbsp; Top row of target screen window (0 to 23)<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 56
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Action<br/>
<br/>
<b>PUTBLS</b> &nbsp; &nbsp; &nbsp;Block move sprite window into screen<br/>
<b>PUTORS</b> &nbsp; &nbsp; &nbsp;OR sprite window into screen<br/>
<b>PUTXRS</b> &nbsp; &nbsp; &nbsp;XOR sprite window into screen<br/>
<b>PUTNDS</b> &nbsp; &nbsp; &nbsp;AND sprite window into screen<br/>
<br/>
<br/>
<b>Group 2</b><br/>
<br/>
<br/>
These commands allow operations between sprite windows and screen windows. &nbsp;Unlike<br/>
Group 1 commands, there are separate commands to move pixel data and attributes,<br/>
and the ATTON, ATTOFF commands have no effect on their operation. &nbsp;Two new<br/>
parameters are introduced to specify the COLUMN and ROW of the top left hand<br/>
character of the sprite window. &nbsp;In addition, HGT and LEN are required to specify<br/>
the dimensions of the window for the screen and sprite.<br/>
<br/>
<br/>
Parameters &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Use<br/>
<br/>
COL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Left hand column of target screen window (0 to 31)<br/>
ROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Top row of target screen window (0 to 23)<br/>
SCOL &nbsp; &nbsp; &nbsp; &nbsp; Left hand column of target sprite window (0 to sprite width -1)<br/>
SROR &nbsp; &nbsp; &nbsp; &nbsp; Top row of target sprite window (0 to sprite height -1)<br/>
HGT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Height of window<br/>
LEN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Length of window<br/>
SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Sprite number<br/>
<br/>
<br/>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Action<br/>
<br/>
<b>GWBLS</b> &nbsp; &nbsp; &nbsp; &nbsp;Get block of pixel data from screen window into sprite window<br/>
<b>GWORS</b> &nbsp; &nbsp; &nbsp; &nbsp;OR pixel data from screen window into sprite window<br/>
<b>GWXRS</b> &nbsp; &nbsp; &nbsp; &nbsp;XOR pixel data from screen window into sprite window<br/>
<b>GWNDS</b> &nbsp; &nbsp; &nbsp; &nbsp;AND pixel data from screen window into sprite window<br/>
<b>GWATTS</b> &nbsp; &nbsp; &nbsp; GET block of attribute data from screen window into sprite window<br/>
<b>PWBLS</b> &nbsp; &nbsp; &nbsp; &nbsp;PUT block of pixel data from screen window into sprite window<br/>
<b>PWORS</b> &nbsp; &nbsp; &nbsp; &nbsp;OR pixel data from sprite window into screen window<br/>
<b>PWXRS</b> &nbsp; &nbsp; &nbsp; &nbsp;XOR pixel data from sprite window into screen window<br/>
<b>PWNDS</b> &nbsp; &nbsp; &nbsp; &nbsp;AND pixel data from sprite window into screen window<br/>
<b>PWATTS</b> &nbsp; &nbsp; &nbsp; PUT block of attribute data from sprite window into screen window<br/>
<br/>
Note:<br/>
<br/>
If the command does not execute, check that the window is not partially off the<br/>
screen or sprite.<br/>
<br/>
Example:<br/>
<br/>
To block move a window 3 characters high and 4 characters wide from row 2, column<br/>
3 of the screen to row 4, column 6 of sprite number 7, use the following:<br/>
<br/>
7 SPN ! 3 HGT ! 4 LEN ! 2 ROW ! 3 COL ! 4 SROW ! 6 SCOL ! GWBLS<br/>
<br/>
Note that sprite 7 must be at least 8 characters wide and 7 characters high for<br/>
the command to execute.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
57
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>Group 3</b><br/>
<br/>
This group, possibly the most useful in the whole set, comprises commands which<br/>
support operations between sprites and sprite windows. &nbsp;The same set of commands<br/>
as those in Group 2 are available and the format for each word is the same as in<br/>
Group 2, except that the commands are postfixed with an "M" instead of an "S".<br/>
The chief difference to the user lies in the set of parameters. &nbsp;The size of the<br/>
data window is set to have the dimensions of the first sprite, and its position in<br/>
the second sprite is set using the SCOL and SROW parameters.<br/>
<br/>
<br/>
Parameter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Use<br/>
<br/>
SP1 &nbsp; &nbsp; &nbsp; &nbsp;Number of the first sprite<br/>
SP2 &nbsp; &nbsp; &nbsp; &nbsp;Number of the second sprite (containing the window)<br/>
SCOL &nbsp; &nbsp; &nbsp; Left hand column of target sprite window<br/>
SROW &nbsp; &nbsp; &nbsp; Top row of target sprite window<br/>
<br/>
<br/>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Action<br/>
<br/>
<b>GWBLM</b> &nbsp; &nbsp; &nbsp;Block move pixel data from first sprite into window in second sprite<br/>
<b>GWORM</b> &nbsp; &nbsp; &nbsp;OR pixel data from first sprite into window in second sprite<br/>
<b>GWXRM</b> &nbsp; &nbsp; &nbsp;XOR pixel data from first sprite into window in second sprite<br/>
<b>GWNDM</b> &nbsp; &nbsp; &nbsp;AND pixel data from first sprite into window in second sprite<br/>
<b>GWATTM</b> &nbsp; &nbsp; Block move attribute data from first sprite into window in second<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sprite<br/>
<b>PWBLM</b> &nbsp; &nbsp; &nbsp;Block move pixel data from window in second sprite into first sprite<br/>
<b>PWORM</b> &nbsp; &nbsp; &nbsp;OR pixel data from window in second sprite into first sprite<br/>
<b>PWXRM</b> &nbsp; &nbsp; &nbsp;XOR pixel data from window in second sprite into first sprite<br/>
<b>PWNDM</b> &nbsp; &nbsp; &nbsp;AND pixel data from window in second sprite into first sprite<br/>
<b>PWATTM</b> &nbsp; &nbsp; Block move attribute data from window in second sprite into first<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sprite<br/>
<br/>
Note:<br/>
<br/>
If the width of the first sprite added to SCOL, or the height of the first sprite<br/>
added to SROW exceeds either the width or height of the second sprite<br/>
respectively, then the command will not execute.<br/>
<br/>
<br/>
<b>COPY COMMANDS</b><br/>
<br/>
These five commands, are in fact a sub-group of the Group 3 commands and allow<br/>
operations between pairs of sprites with the same dimensions. &nbsp;It is necessary,<br/>
therefore, to provide only two parameters instead of four.<br/>
<br/>
<br/>
Parameter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Use<br/>
<br/>
SP1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Number of first sprite<br/>
SP2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Number of second sprite<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 58
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Action<br/>
<br/>
<b>COPYM</b> &nbsp; &nbsp; &nbsp; &nbsp;Copy first sprite pixel data into second sprite<br/>
<b>COPORM</b> &nbsp; &nbsp; &nbsp; OR first sprite pixel data into second sprite<br/>
<b>COPXRM</b> &nbsp; &nbsp; &nbsp; XOR first sprite pixel data into second sprite<br/>
<b>COPNDM</b> &nbsp; &nbsp; &nbsp; AND first sprite pixel data into second sprite<br/>
<b>COPATTM</b> &nbsp; &nbsp; &nbsp;Copy first sprite attribute data into second sprite<br/>
<br/>
Note:<br/>
If the dimensions of the two sprites are not identical, then the command will not<br/>
execute.<br/>
<br/>
Example:<br/>
<br/>
To make a complete copy of sprite 10 into sprite 8, use the following:<br/>
<br/>
8 SP1 ! 10 SP2 ! COPYM COPATTM<br/>
<br/>
<br/>
<b>SPRITE TRANSFORMATIONS</b><br/>
<br/>
To increase the utility of the package, four extra words have been added to<br/>
invert, spin, reflect and enlarge sprites. &nbsp;The inversion and reflection routines<br/>
work for screen and sprite data but the rotation and enlargement commands work<br/>
only on sprites and a dummy sprite is required to rotate or enlarge into.<br/>
<br/>
<br/>
<b>Inversions</b><br/>
<br/>
The sprite is "1's complemented"; in other words, all the pixels which are set<br/>
"on", became set "off" and vice-versa. &nbsp;The attributes, however, remain<br/>
unchanged.<br/>
<br/>
<br/>
Parameter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Use<br/>
<br/>
SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;The number of the sprite to be inverted<br/>
<br/>
<br/>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Action<br/>
<br/>
<b>INVM</b> &nbsp; &nbsp; &nbsp; &nbsp; The sprite is inverted (1's complemented)<br/>
<br/>
<br/>
Parameter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Use<br/>
<br/>
COL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Column of the left hand edge of the screen window (0 to 31)<br/>
ROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Row of the top edge of the window (0 to 23)<br/>
LEN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Width of the screen window (1 to 32)<br/>
HGT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Height of the screen window (1 to 24)<br/>
<br/>
<br/>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Action<br/>
<br/>
<b>INVV</b> &nbsp; &nbsp; &nbsp; &nbsp; Invert screen window<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
59
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>Reflections</b><br/>
<br/>
There are four commands in this group for reflecting screen and memory, pixel and<br/>
attribute data. &nbsp;A sprite is often required to point in two directions and the<br/>
command can either be used at the development stage or, if space is short, at<br/>
run-time. &nbsp;The command causes horizontal reflection but vertical reflection is<br/>
possible, by combining rotations and reflections.<br/>
<br/>
<br/>
Parameter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Use<br/>
<br/>
SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Number of sprite to be reflected (1 to 255)<br/>
<br/>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Action<br/>
<br/>
<b>MIRM</b> &nbsp; &nbsp; &nbsp; &nbsp; Reflect sprite pixel data about its centre<br/>
<b>MARM</b> &nbsp; &nbsp; &nbsp; &nbsp; Reflect sprite attribute data about its centre<br/>
<br/>
<br/>
Parameter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Use<br/>
<br/>
COL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Column of left hand edge of screen window (0 to 31)<br/>
ROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Row of top edge of the window (0 to 23)<br/>
LEN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Width of screen window (1 to 32)<br/>
HGT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Height of screen window (1 to 24)<br/>
<br/>
<br/>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Action<br/>
<b>MIRV</b> &nbsp; &nbsp; &nbsp; &nbsp; Reflect screen pixel data about window centre<br/>
<b>MARV</b> &nbsp; &nbsp; &nbsp; &nbsp; Reflect screen attribute data about window centre<br/>
<br/>
<br/>
<b>Spin</b><br/>
<br/>
This command involves an operation between two sprites with transposed dimensions.<br/>
If, for example, a sprite with dimensions 8 by 3 is to be spun into a second<br/>
sprite, this second sprite must have dimensions 3 by 8. &nbsp;Square sprites are, of<br/>
course, no problem. &nbsp;Pixel and attribute data are both rotated. &nbsp;If the command is<br/>
to be used, it is important to remember that a second sprite will be needed to be<br/>
rotated into and that it is necessary to set this up in advance. &nbsp;Rotation is 90<br/>
degrees clockwise.<br/>
<br/>
<br/>
Parameter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Use<br/>
<br/>
SP2 &nbsp; &nbsp; &nbsp; &nbsp; Number of sprite to be rotated<br/>
SP1 &nbsp; &nbsp; &nbsp; &nbsp; Number of sprite to be rotated into<br/>
<br/>
<br/>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Action<br/>
<br/>
<b>SPINM</b> &nbsp; &nbsp; &nbsp; Rotate 90 degrees clockwise sprite SP2 into sprite SP1.<br/>
<br/>
<br/>
Note:<br/>
<br/>
A sprite cannot be rotated into itself, i.e. if SP1 and SP2 are the same number,<br/>
the rotation will not work. &nbsp;The result is, however, well worth seeing! &nbsp;Data is<br/>
"OR"ed from SP2 into SP1 so it is usually necessary to execute a CLSM to clear<br/>
sprite SP1 before execution.<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 60
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>Enlargement</b><br/>
<br/>
One command is provided for enlarging a sprite and its attributes into a second<br/>
sprite which has dimensions exactly double those of the sprite being enlarged.<br/>
<br/>
<br/>
Parameter &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Use<br/>
<br/>
SP1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Number of the sprite into which the enlargement is carried<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;out.<br/>
SP2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Number of the sprite being enlarged.<br/>
<br/>
<br/>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Action<br/>
<br/>
<b>DSPM</b> &nbsp; &nbsp; &nbsp; &nbsp; Enlarge sprite SP2 into sprite SP1.<br/>
<br/>
Note:<br/>
<br/>
If the dimensions of sprite SP1 are not twice those of sprite SP2 the command will<br/>
not execute.<br/>
<br/>
<br/>
<b>INTERRUPT RELATED WORDS</b><br/>
<br/>
Six interrupt related words are provided which control the Foreground/Background<br/>
execution of White Lightning words. &nbsp;The first four have no parameters.<br/>
<br/>
<br/>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Action<br/>
<br/>
<b>HALT</b> &nbsp; &nbsp; &nbsp; &nbsp;Suspend CPU operation until the next interrupt. &nbsp;Executing<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HALT in background mode will freeze the system permanently.<br/>
<br/>
<b>EI</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Enable the interrupt.<br/>
<br/>
<b>DI</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Disable the interrupt.<br/>
<br/>
<b>EXX</b> &nbsp; &nbsp; &nbsp; &nbsp; Exchange IDEAL variables with the alternate IDEAL variables.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This command is executed automatically each time an<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interrupt occurs and at the end of the interrupt routine<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to restore foreground variables. &nbsp;If a background program<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is not being used EXX can be used to provide extra variables.<br/>
<br/>
<b>INT-ON</b> &nbsp; &nbsp; &nbsp;The specified word (see next example) is executed on the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; receipt of each interrupt.<br/>
<br/>
<b>INT-OFF</b> &nbsp; &nbsp; Following execution of INT-OFF the Z80 returns to interrupt<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mode 1 and polls the keyboard 50 times a second. &nbsp;The<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; background program ceases execution.<br/>
<br/>
Example:<br/>
<br/>
To set a word running in background type:<br/>
<br/>
' WORD INT-ON<br/>
<br/>
Where "WORD" is the word to be run in background.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
61
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>BASIC INTERFACE WORDS</b><br/>
<br/>
These words are provided to enable you to mix BASIC and Forth in your program.<br/>
The section covering the access of BASIC should be read carefully before an<br/>
attempt is made to use these commands.<br/>
<br/>
<br/>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Action<br/>
<br/>
<b>PROG</b> &nbsp; &nbsp; &nbsp; &nbsp; Enter BASIC at command level.<br/>
<br/>
<b>RESERVE</b> &nbsp; &nbsp; &nbsp;Reserve space in the dictionary for the insertion of BASIC<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;source. &nbsp;The size of the space to be reserved is taken from<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the stack.<br/>
<br/>
Example:<br/>
<br/>
1024 RESERVE<br/>
<br/>
will reserve 1k from the current value of HERE.<br/>
<br/>
<b>GOTO</b> &nbsp; &nbsp; &nbsp; &nbsp; The BASIC program is executed from the line number held<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;on the stack. &nbsp;Forth can be called from BASIC using<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;RANDOMISE USR 30000 and Forth can be re-entered using<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PRINT USR 30006.<br/>
<br/>
Example:<br/>
<br/>
100 GOTO<br/>
<br/>
will commence execution of the BASIC source from line 100.<br/>
<br/>
<b>RETUSR</b> &nbsp; &nbsp; &nbsp; Control is returned to the BASIC program from Forth.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Execution of the BASIC program proceeds with the first<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;instruction after the RANDOMISE USR 30000 with which Forth<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;was called. &nbsp;Do not execute a RETUSR in Forth if Forth has<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;not been called using a RANDOMISE USR 30000 call.<br/>
<br/>
<br/>
<b>MISCELLANEOUS WORDS</b><br/>
<br/>
There are 18 words provided which cover general aspects of games development.<br/>
<br/>
<br/>
Command &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Action<br/>
<br/>
<b>SETAV</b> &nbsp; &nbsp; &nbsp; &nbsp;Set the attributes to the current INK and PAPER colours in<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the screen window defined by HGT, LEN, COL, ROW.<br/>
<br/>
<b>SETAM</b> &nbsp; &nbsp; &nbsp; &nbsp;Set the attributes to the current INK and PAPER colours in<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the sprite whose number is held in SPN.<br/>
<br/>
<b>CLSV</b> &nbsp; &nbsp; &nbsp; &nbsp; Clear the screen window (defined by HGT, LEN, COL, ROW)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;of pixel data and set the attributes throughout to the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;current INK and PAPER colours.<br/>
<br/>
<b>CLSM</b> &nbsp; &nbsp; &nbsp; &nbsp; Clear the pixel data of the sprite whose number is held<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;in SPN. &nbsp;Attribute data is unaffected.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 62
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>ADJM</b> &nbsp; &nbsp; &nbsp; &nbsp; This command is used to ensure the execution of group2 GET<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and PUT instructions. &nbsp;The parameters are SPN, COL and ROW.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;First HGT and LEN are set to the dimensions of the sprite<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;whose number is held in SPN. &nbsp;If COL or ROW are "off<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;screen" or if COL + LEN, HGT + ROW are off screen, then<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the parameters COL, ROW, HGT, LEN, SCOL, SROW are set such<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;that the sprite will be partially PUT to the screen or<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;GOT from the screen. &nbsp;This is an extremely useful command<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and can be used in conjunction with any of the group 2 GETs<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and PUTS.<br/>
<br/>
Example:<br/>
<br/>
-1 COL ! -1 ROW ! 1 SPN ! ADJM PWBLS<br/>
<br/>
This will PUT part of sprite 1 in the top left hand corner. &nbsp;After execution, COL<br/>
and ROW will have been made 0 and SCOL and SROW will have the value 1.<br/>
<br/>
<b>ADJV</b> &nbsp; &nbsp; &nbsp; &nbsp; Essentially the same idea as ADJM but this time the screen<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;window defined by HGT, LEN, COL, ROW is adjusted to lie<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"on screen"<br/>
<br/>
<b>SCANM</b> &nbsp; &nbsp; &nbsp; &nbsp;The sprite whose number is held in SPN is scanned for<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pixel data. &nbsp;If data is found a true (non-zero) flag is<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;placed on the stack, otherwise a false (zero) flag is<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;placed on the stack. &nbsp;This command is used extensively for<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;collision detection.<br/>
<br/>
<b>SCANV</b> &nbsp; &nbsp; &nbsp; &nbsp;The character cell at screen positions defined by COL and<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW is scanned for screen data and a true or false flag<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stacked accordingly. &nbsp;This command executes more rapidly<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;than SCAM.<br/>
<br/>
<b>RND</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Replace the value at the top of the stack by a random<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;number between zero and the value at the top of the stack.<br/>
<br/>
Example:<br/>
<br/>
10 RND<br/>
<br/>
will leave a number between 0 and 10 on the stack.<br/>
<br/>
<b>OUT#</b> &nbsp; &nbsp; &nbsp; &nbsp; Output the second value on the stack to the port address<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;at the top of the stack.<br/>
<br/>
<b>IN#</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Replace the port address an the top of the stack by the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;16 bit representation of the 8 bit number read from the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;port.<br/>
<br/>
Example:<br/>
<br/>
The following will poll the Kempston Joystick and execute one of 8 words depending<br/>
on the joystick position. &nbsp;Finally, the fire button will be tested. Type:<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
63
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
: JOYSTICK 31 IN# DUP CASE &lt;CR&gt;<br/>
&nbsp;0 OF ." CENTRE " ENDOF &lt;CR&gt;<br/>
&nbsp;1 OF ." RIGHT " FNDOF &lt;CR&gt;<br/>
&nbsp;2 OF ." LEFT " ENDOF &lt;CR&gt;<br/>
&nbsp;4 OF ." DOWN " ENDOF &lt;CR&gt;<br/>
&nbsp;8 OF ." UP " ENDOF &lt;CR&gt;<br/>
&nbsp;9 OF ." UPRIGHT " ENDOF &lt;CR&gt;<br/>
10 OF ." UPLEFT " ENDOF &lt;CR&gt;<br/>
&nbsp;5 OF ." DOWNRIGHT " ENDOF &lt;CR&gt;<br/>
&nbsp;6 OF ." DOWNLEFT " ENDOF &lt;CR&gt;<br/>
ENDCASE &lt;CR&gt;<br/>
15 &gt; IF ." FIRE " ENDIF ; &lt;CR&gt;<br/>
: JTEST BEGIN JOYSTICK CR 1 1 KB UNTIL ;&lt;CR&gt;<br/>
<br/>
To run type:<br/>
<br/>
JTEST &lt;CR&gt;<br/>
<br/>
To halt press CAPS SHIFT<br/>
<br/>
<br/>
<b>KB</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This command is provided for the detection of multiple key<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;presses. &nbsp;All it does, in fact, is test the specified key<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and stack a true flag if the key is pressed and a false flag if<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;it is not. &nbsp;The key to be tested is specified by the top two<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;numbers on the stack. &nbsp;The second value specifies the half ROW<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and the top value the COLUMN. &nbsp;For a full description<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;of the COLUMNS and ROWS of the Spectrum keyboard see page 160<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;of the Spectrum manual. &nbsp;Below is a summary.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; KEYS<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CAPS SHIFT to V<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; A to G<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Q to T<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1 to 5<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 to 6<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P to 7<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ENTER to H<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SPACE to B<br/>
<br/>
<br/>
Columns are organised from 1 to 5 and counted from the outside in. &nbsp;This is the<br/>
order above.<br/>
<br/>
<br/>
<b>BLEEP</b> &nbsp; &nbsp; &nbsp; &nbsp;This operates in the same way as the Spectrum's BEEP<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;command with the second number on the stack providing<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;duration and top number pitch.<br/>
Example:<br/>
<br/>
100 200 BLEEP<br/>
<br/>
<br/>
<b>ATTON</b> &nbsp; &nbsp; &nbsp; &nbsp;After the execution of ATTON, group 1 GETs and PUTs will GET<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and PUT attribute data at the same time as they GET and PUT<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pixel data. &nbsp;The GW and PW commands, however, are unaffected<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;by ATTON or ATTOFF and always use separate commands to<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;move pixel data. &nbsp;After the execution of a GW or PW command<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the attribute switch is always set to 'OFF'.<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 64
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>ATTOFF</b> &nbsp; &nbsp; &nbsp; After the execution of ATOFF, group GETs and PUTs will move<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pixel data only.<br/>
<br/>
<br/>
<b>CALL</b> &nbsp; &nbsp; &nbsp; &nbsp; Control jumps to a machine code subroutine whose address<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;is held at the top of the stack.<br/>
<br/>
Example:<br/>
<br/>
HEX D000 CALL<br/>
<br/>
would execute a machine code subroutine at location D000 HEX. Don't type this<br/>
unless you have a machine code routine at HEX D000!<br/>
<br/>
<br/>
<b>ZAP</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Once program development is completed and you have compiled<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;your final program into the dictionary, typing ZAP will<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;produce a run-time version. &nbsp;The length of the final<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;version is displayed to the screen and a copy can be saved<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;by typing:<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SAVE "filename" CODE 24832, LENGTH<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the length being the length displayed. &nbsp;Typing:<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PRINT USR 24832<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; will execute the last word defined before the ZAP command.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This is the only form in which White Lightning programs<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; can be commercially sold.<br/>
<br/>
<br/>
<b>ZAPINT</b> &nbsp; &nbsp; &nbsp; &nbsp;As above except that programs which utilise the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Foreground/Background facility must be produced using the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ZAPINT command as opposed to the ZAP command. &nbsp;The only<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; real difference is that the first five screens also need<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to be saved and that the top 16 bytes of RAM will be<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; used by the final program.<br/>
<br/>
<br/>
<b>PRT-ON</b> &nbsp; &nbsp; &nbsp; &nbsp;All subsequent screen output is to ZX-Printer only.<br/>
<br/>
<br/>
<b>PRT-OFF</b> &nbsp; &nbsp; &nbsp; All subsequent output is to screen only.<br/>
<br/>
Example:<br/>
<br/>
PRT-ON VLIST PRT-OFF<br/>
<br/>
will list the current FORTH dictionary to the ZX-Printer.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
65
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>FORTH/BASIC WORDS</b><br/>
<br/>
For those users who have mastered and grown used to the Spectrum's own graphics<br/>
commands, a set of 18 Forth implementations of Spectrum words is provided.<br/>
Parameters are placed on the stack in the same order as they occur in their BASIC<br/>
implementations. &nbsp;If an error occurs during the execution of a BASIC word, Forth<br/>
should be re-entered via a WARM start, i.e. PRINT USR 24836. &nbsp;For a full<br/>
description of the action of each of these words refer to your Spectrum manual.<br/>
<br/>
<br/>
PARAMETERS &nbsp; &nbsp; &nbsp;WORD &nbsp; &nbsp; &nbsp;ACTION<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>COPY</b> &nbsp; &nbsp; &nbsp;The screen in 'dumped' to the ZX-Printer.<br/>
<br/>
ROW, COL &nbsp; &nbsp; &nbsp; &nbsp;<b>AT</b> &nbsp; &nbsp; &nbsp; &nbsp;The print position is moved the specified<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Column and Row.<br/>
<br/>
COLOUR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>BORDER</b> &nbsp; &nbsp;The border colour is set to one of the 8<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Spectrum colours.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>CLS</b> &nbsp; &nbsp; &nbsp; The screen is cleared of pixel data and the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attributes set to the current INK, PAPER,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BRIGHT and FLASH values.<br/>
<br/>
X,Y,ANGLE &nbsp; &nbsp; &nbsp; <b>DRAW-ARC</b> &nbsp;See Spectrum manual page 122.<br/>
<br/>
X,Y,RADIUS &nbsp; &nbsp; &nbsp;<b>CIRCLE</b> &nbsp; &nbsp;See Spectrum manual page 123.<br/>
<br/>
X,Y &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>DRAW</b> &nbsp; &nbsp; &nbsp;See Spectrum manual page 121.<br/>
<br/>
X,Y &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>PLOT</b> &nbsp; &nbsp; &nbsp;See Spectrum manual page 121.<br/>
<br/>
ROW, COL &nbsp; &nbsp; &nbsp; &nbsp;<b>SCREEN$</b> &nbsp; The character at the screen position defined<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; by the two values at the top of the stack is<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tested to see if it is one of the Spectrum's<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pre-defined characters. &nbsp;The ASCII value<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is left on the stack.<br/>
<br/>
ROW, COL &nbsp; &nbsp; &nbsp; &nbsp;<b>ATTR</b> &nbsp; &nbsp; &nbsp;The code for the attribute at the screen<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; position defined by the top two values on the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack is left on the stack.<br/>
<br/>
X,Y &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>POINT</b> &nbsp; &nbsp; The pixel at the (x,y) co-ord defined by the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; top two values on the stack is tested and<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a true or false flag stacked depending on<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; whether the pixel is set or not.<br/>
<br/>
COL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>TAB</b> &nbsp; &nbsp; &nbsp; Set the horizontal print position to the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value at the top of the stack.<br/>
<br/>
COLOUR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>INK</b> &nbsp; &nbsp; &nbsp; Set the INK colour to the value at the top<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of the stack.<br/>
<br/>
COLOUR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>PAPER</b> &nbsp; &nbsp; Set the PAPER colour to the value at the top<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of the stack.<br/>
<br/>
FLAG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>OVER.</b> &nbsp; &nbsp; Note the full stop at the end of OVER.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; This sets the printing mode according to<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the value of FLAG which is zero or one.<br/>
<br/>
FLAG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>INVERSE</b> &nbsp; As for OVER.<br/>
<br/>
FLAG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>BRIGHT</b> &nbsp; &nbsp;As for OVER.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 66
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>FOREGROUND BACKGROUND</b><br/>
<br/>
<br/>
Mastering machine code does give most programmers access to the speed of<br/>
commercial games, but often the smoothness and continuity are lacking. &nbsp;One of the<br/>
greatest difficulties facing any games designer is timing. &nbsp;The basic problem is<br/>
that some parts of the program need to execute at regular intervals, and trying to<br/>
achieve this can involve a lot of calculation and wasted processor time. &nbsp;The<br/>
solution to this is to use interrupts to execute particular sections of code.<br/>
White Lightning does this for you, using the words INT-ON and INT-OFF.<br/>
<br/>
The Spectrum interrupt occurs 50 times a second, so background words can be<br/>
executed at this frequency, or by counting interrupts, at lower frequencies.<br/>
<br/>
If you list any of the screens 1 to 5, you will see that they are apparently<br/>
filled with garbage. &nbsp;This is because the area in memory occupied by these screens<br/>
contains the machine code that enables the background facility. &nbsp;If you are not<br/>
intending to use this facility, then you can clear screens 1 to 5 and use them<br/>
normally for source code. &nbsp;If you do this, however, don't forget that you won't be<br/>
able to use any of the graphics words in background mode, or the system will crash<br/>
in no uncertain manner!<br/>
<br/>
When an interrupt occurs, the foreground program stops exactly where it is, saves<br/>
off its parameters and then executes the background word. &nbsp;The background word<br/>
will then execute fully before continuing execution of the foreground program,<br/>
from the exact point at which it was halted. &nbsp;Three important points should be<br/>
borne in mind. &nbsp;Firstly, if the execution time of the background word exceeds a<br/>
fiftieth of a second, it is not possible to execute it more than twenty five times<br/>
a second, if it exceeds a twenty-fifth of a second, it can only be executed at<br/>
half that frequency, and so on. &nbsp;There is, however, no limit to the length of the<br/>
background execution time itself. &nbsp;Secondly, as the execution time approaches a<br/>
fiftieth of a second, or some multiple of a fiftieth of a second, then less and<br/>
less processor time will be available for the foreground program and sometimes it<br/>
is necessary to extend the length of the background program to make the foreground<br/>
program run more quickly, by reducing the frequency of the background program.<br/>
Experimentation will familiarise the user with the techniques required for the<br/>
best effects. &nbsp;More foreground time can also be taken by disabling and then re-<br/>
enabling the interrupt using DI and EI respectively. &nbsp;This brings us to the third,<br/>
and most important point. &nbsp;Remember that when an interrupt occurs, the foreground<br/>
program will stop whatever it is doing, execute the background program and then<br/>
continue with the foreground execution. &nbsp;Suppose the background program is a<br/>
sideways scroll of a user defined screen window and the foreground program PUTs a<br/>
character into the window. &nbsp;A problem arises if an interrupt occurs halfway<br/>
through the PUT, because the top half of the character will be scrolled before the<br/>
second half of the character is PUT to the screen. &nbsp;To circumvent this problem,<br/>
where an operation is carried out on the same screen or sprite data by both the<br/>
foreground and background programs, the background program should be temporarily<br/>
disabled using DI, the foreground word executed, and then the background program<br/>
re-enabled using EI ready for the next interrupt to occur. &nbsp;The safest way to<br/>
proceed until you have really mastered the language, is to avoid the situation<br/>
altogether and make sure the foreground and background programs don't operate on<br/>
the same sprite or screen area.<br/>
<br/>
To set the background program running, simply type an apostrophe (shifted 7), a<br/>
space, the word to be executed, a space and then INT-ON. &nbsp;Don't forget that if the<br/>
background word does not set its own parameters, then these will need to be set<br/>
before execution and if these are the IDEAL variables, then the alternate set will<br/>
be used.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
67
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
For example, suppose you wanted to scroll a window, four characters square, in the<br/>
middle of the screen and invert it after each sideways scroll. &nbsp;First we need to<br/>
define a word to do the scrolling and the inverting. &nbsp;For some reason, most test<br/>
programs are called FRED and there is no reason for breaking with convention. &nbsp;To<br/>
define the word type:<br/>
<br/>
: FRED WRR1V INVV ; &lt;CR&gt;<br/>
<br/>
To set up the parameters type:<br/>
<br/>
4 HGT' ! 4 LEN' ! 14 COL' ! 9 ROW' ! &lt;CR&gt;<br/>
<br/>
To make sure there is some data in the window, type:<br/>
<br/>
VLIST &lt;CR&gt;<br/>
<br/>
You are now ready to execute the background program by typing:<br/>
<br/>
' FRED INT-ON &lt;CR&gt;<br/>
<br/>
To halt this program type:<br/>
<br/>
INT-OFF &lt;CR&gt;<br/>
<br/>
This program is running a bit too fast to see, so let's write another program<br/>
which slows this down to every fifth interrupt, i.e. ten times a second. &nbsp;We will<br/>
need to define a variable and a new word. &nbsp;To set up the variable type:<br/>
<br/>
0 VARIABLE ICNT &lt;CR&gt;<br/>
<br/>
This sets up a variable called ICNT and assigns to it the value 0. &nbsp;We'll call<br/>
this new background word FREDA. &nbsp;Type:<br/>
<br/>
: FREDA ICNT @ 1+ 5 &gt; IF FRED 0 ICNT ! ELSE 1 ICNT + ! ENDIF ; &lt;CR&gt;<br/>
<br/>
Now type:<br/>
<br/>
' FREDA INT-ON &lt;CR&gt;<br/>
<br/>
All "FREDA" does, is to increment ICNT and compare it with 5 and if it is greater<br/>
than 5 then "FREDA" is executed and ICNT set back to zero.<br/>
<br/>
It would be useful to be able to control the speed that "FREDA" ran at, so, let's<br/>
modify "FREDA" to do this. &nbsp;First, type INT-OFF FORGET FREDA &lt;CR&gt; to get rid of<br/>
the old definition and then set up a new variable and construct a slightly<br/>
different program. &nbsp;A variable which sets the limit on the number of interrupts<br/>
needs to be set up, so type: 4 VARIABLE LCNT &lt;CR&gt;. &nbsp;The new definition is set up<br/>
by typing:<br/>
<br/>
: FREDA ICNT @ 1+ LCNT @ &gt; IF FRED 0 ICNT ! ELSE 1 ICNT +! FNDIF ; &lt;CR&gt;<br/>
<br/>
To execute the new word type:<br/>
<br/>
0 ICNT ! ' FREDA INT-ON &lt;CR&gt;<br/>
<br/>
This program increments ICNT, compares it with LCNT and executes when ICNT is<br/>
equal to LCNT. &nbsp;Increasing LCNT then, will slow the background execution and<br/>
decrementing LCNT will speed it up. &nbsp;If LCNT is put equal to 1, execution will<br/>
occur every cycle.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 68
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
To speed up "FREDA" type: 0 ICNT ! 2 LCNT ! &lt;CR&gt; and to slow "FREDA" type 10 LCNT<br/>
! &lt;CR&gt; and so on. &nbsp;Type: INT-OFF &lt;CR&gt; to halt FREDA. &nbsp;Now type: FORGET FREDA &lt;CR&gt;<br/>
<br/>
<br/>
<b>Frequency and Phase</b><br/>
<br/>
One of the problems with executing a word on each interrupt, &nbsp;is that the dot<br/>
scanning the screen may overtake the screen operation in the same position on each<br/>
execution. &nbsp;This can produce some strange effects, and often, sections of the<br/>
screen window will appear to be "sliced". &nbsp;It is more usual to execute on selected<br/>
interrupts. &nbsp;We can do this very simply using modular arithmetic.<br/>
<br/>
Suppose we have four different words that we wish to execute with four different<br/>
frequencies. &nbsp;Suppose they are as follows.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INVV &nbsp; every 50 cycles<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MIRV &nbsp; every 20 cycles<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WRR1V &nbsp;every &nbsp;4 cycles<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WCRV &nbsp; every &nbsp;5 cycles<br/>
<br/>
We now define a variable to count interrupts and four constants to store the<br/>
frequencies.<br/>
<br/>
0 VARIABLE ICNT 50 CONSTANT F1 20 CONSTANT F2 4 CONSTANT F3 5 CONSTANT F4 &lt;CR&gt;<br/>
: MAO MOD ABS 0= ; &lt;CR&gt;<br/>
: IRUN ICNT @ DUP DUP DUP &lt;CR&gt;<br/>
F1 MAO IF INVV ENDIF &lt;CR&gt;<br/>
F2 MAO IF MIRV ENDIF &lt;CR&gt;<br/>
F3 MAO IF WRR1V ENDIF &lt;CR&gt;<br/>
F4 MAO IF WCRV ENDIF &lt;CR&gt;<br/>
1 ICNT @ +! ; &lt;CR&gt;<br/>
<br/>
All we need to do now is set up the parameters by typing:<br/>
<br/>
10 COL' ! 10 ROW' ! 6 HGT' ! 8 LEN' ! 2 NPX' ! &lt;CR&gt;<br/>
<br/>
then put some data on to the screen and execute:<br/>
<br/>
VLIST 0 0 AT ' IRUN INT-ON &lt;CR&gt;<br/>
<br/>
To terminate, type INT-OFF &lt;CR&gt;<br/>
<br/>
If we had made the F1 to F4 variables, we could have controlled the background<br/>
program from the foreground by resetting them.<br/>
<br/>
Sometimes, controlling the frequencies of events is not sufficient and phase<br/>
information needs to be introduced. &nbsp;In the previous example, values of 0, 100,<br/>
200, 300 and so on cause all four events. &nbsp;Supposing we wanted to maintain these<br/>
frequencies, but change the order in which the words execute - we need to<br/>
introduce the concept of phase.<br/>
<br/>
In this example we need four more constants, so type:<br/>
<br/>
FORGET IRUN &lt;CR&gt;<br/>
<br/>
31 CONSTANT PH1 5 CONSTANT PH2 0 CONSTANT PH3 3 CONSTANT PH4 &lt;CR&gt;<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
69
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
Now type:<br/>
<br/>
: IRUN ICNT @ DUP DUP DUP &lt;CR&gt;<br/>
F1 MOD ABS PH1 = IF INVV ENDIF &lt;CR&gt;<br/>
F2 MOD ABS PH2 = IF MIRV ENDIF &lt;CR&gt;<br/>
F3 MOD ABS PH3 = IF WRR1V ENDIF &lt;CR&gt;<br/>
F4 MOD ABS PH4 = IF WCRV ENDIF &lt;CR&gt;<br/>
1 ICNT +! ; &lt;CR&gt;<br/>
<br/>
This can be executed using VLIST ' IRUN INT-ON &lt;CR&gt;<br/>
Halted using: INT-OFF &lt;CR&gt;<br/>
and cleared using: FORGET IRUN &lt;CR&gt;<br/>
<br/>
<br/>
<b>Forth/BASIC Words</b><br/>
<br/>
Sinclair's graphics and sound commands have been replicated as Forth words for<br/>
continuity - they also execute slightly more rapidly than their BASIC<br/>
counterparts. &nbsp;For a full list, see the section on Forth/BASIC WORDS.<br/>
<br/>
They all execute code in Sinclair's own ROM which, unlike Forth and IDEAL, is not<br/>
re-entrant. &nbsp;This means that these words cannot be executed in foreground and<br/>
background simultaneously. &nbsp;The FORTH words ." , . and U. should also not be<br/>
executed simultaneously with themselves or any of the BASIC words. &nbsp;None of the<br/>
Forth/BASIC words, ." , . or U. should be executed in background while Forth is in<br/>
command mode.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 70
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>LOGICAL OPERATIONS</b><br/>
<br/>
There are three types of logical operation included in the IDEAL sub-language;<br/>
these are OR, XOR and AND. &nbsp;To get the best out of this package it is important to<br/>
make full use of these commands.<br/>
<br/>
If a GET or PUT postfixed with "BLS" or "BLM" is executed, &nbsp;then data is block<br/>
moved from the source which may be part of the screen, a sprite, or a sprite<br/>
window, in such a way that whatever was previously held at the destination which<br/>
may also be part of the screen, a sprite, or a sprite window, is obliterated and<br/>
replaced by whatever was at the source. &nbsp;This may not always be the desired effect<br/>
and quite often the user will want to merge characters or remove parts of the<br/>
characters and so on.<br/>
<br/>
If two sprites are "OR"ed together, the resulting sprite will have pixels set<br/>
where pixels were set in either or both of the sprites being "OR"ed.<br/>
<br/>
If two sprites are "AND"ed together, the resulting sprite will have pixels set<br/>
where pixels were set in both of the sprites being "AND"ed.<br/>
<br/>
If two sprites are "XOR"ed together, the resulting sprite will have pixels set<br/>
where pixels were set in either but reset where pixels were set or reset in both.<br/>
<br/>
These results are summarised as follows and should make things a little clearer:<br/>
<br/>
<br/>
<b>SOURCE</b> &nbsp; &nbsp; &nbsp; &nbsp; <b>DESTINATION</b> &nbsp; &nbsp; &nbsp; &nbsp; <b>OPERATION</b> &nbsp; &nbsp; &nbsp; &nbsp;<b>RESULT</b><br/>
<br/>
&nbsp; on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;on<br/>
&nbsp; on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;on<br/>
&nbsp; off &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;on<br/>
&nbsp; off &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;off &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;off<br/>
<br/>
&nbsp; on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;on<br/>
&nbsp; on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;off<br/>
&nbsp; off &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;off<br/>
&nbsp; off &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;off &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;off<br/>
<br/>
&nbsp; on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XOR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off<br/>
&nbsp; on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;XOR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; on<br/>
&nbsp; off &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;on &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XOR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; on<br/>
&nbsp; off &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;off &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;XOR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off<br/>
<br/>
<br/>
We can now use the sample sprites to illustrate the effects of these operations.<br/>
First FORGET any previously defined words and type: DECIMAL &lt;CR&gt; to ensure that<br/>
you are in decimal mode. Now type:<br/>
<br/>
7 INK 0 PAPER CLS ." LOGICAL OR " CR ." LOGICAL OR " &lt;CR&gt;<br/>
<br/>
This will clear the screen and put some data in the top left hand corner.<br/>
<br/>
Now type:<br/>
<br/>
3 SPN ! 0 COL ! 0 ROW 1 ATTOFF PUTORS &lt;CR&gt;<br/>
<br/>
You will see that the data has been merged together, both the dragster and the<br/>
letters remain.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
71
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
Now type:<br/>
<br/>
CLS ." LOGICAL AND " CR ." LOGICAL AND " PUTNDS &lt;CR&gt;<br/>
<br/>
This time, the only data remaining is at those points where the data coincided.<br/>
Logical "AND"s are normally used to mark off sections of the screen or sprites.<br/>
They are also used extensively for collision detection. &nbsp;If a window of the screen<br/>
is "AND"ed into a sprite, and then a SCANM performed, it is possible to determine<br/>
whether a collision would occur if the sprite were PUT; before actually PUTting<br/>
the sprite.<br/>
<br/>
We now come to the logical XOR. &nbsp;This is probably the most useful operation of the<br/>
lot. "XOR"s have the peculiar property of restoring the destination data to its<br/>
former state if the operation is performed twice. &nbsp;This is how Sinclair's own<br/>
"OVER" operation works. &nbsp;To see this happen type:<br/>
<br/>
CLS ." XOR " CR ." XOR " PUTXRS &lt;CR&gt;<br/>
<br/>
To restore the text type:<br/>
<br/>
PUTXRS &lt;CR&gt;<br/>
<br/>
We can even use this property to swap two sprites without using a third. &nbsp;This<br/>
example will swap the data but not the attributes. &nbsp;We will "PUT" two sprites at<br/>
each stage so you can see what is happening. &nbsp;Type:<br/>
<br/>
CLS ATTON 0 SCOL ! 0 SROW ! 1 SP1 ! 2 SP2 ! 23 COL ! 6 0 AT &lt;CR&gt;<br/>
<br/>
Now type:<br/>
<br/>
1 SPN ! PUTBLS 2 SPN ! 27 COL ! PUTBLS &lt;CR&gt;<br/>
<br/>
These are the two sprites before the operations begin.<br/>
<br/>
Now type:<br/>
<br/>
GWXRM 2 ROW ! 23 COL ! 1 SPN ! PUTBLS 27 COL ! 2 SPN ! PUTBLS &lt;CR&gt;<br/>
<br/>
sprite 1 has now been "XOR"ed into sprite 2. &nbsp;Now type:<br/>
<br/>
PWXRM 4 ROW ! 23 COL ! 1 SPN ! PUTBLS 27 COL 1 2 SPN ! PUTBLS &lt;CR&gt;<br/>
<br/>
sprite 2 is now in sprite 1. &nbsp;Finally, type:<br/>
<br/>
GWXRM 6 ROW ! 23 COL ! 1 SPN ! PUTBLS 27 COL ! 2 SPN ! PUTBLS &lt;CR&gt;<br/>
<br/>
The operation is now complete.<br/>
<br/>
If we wanted to add a new word to the language which swaps two equally sized<br/>
sprites whose numbers were in SP1 and SP2, we would now do so.<br/>
<br/>
: SWOP 0 SCOL ! 0 SROW 1 GWXRM PWXRM GWXRM ; &lt;CR&gt;<br/>
<br/>
In fact we could also use:<br/>
<br/>
: SWOP 0 SCOL ! 0 SROW ! PWXRM GXXRM PWXRM ; &lt;CR&gt;<br/>
<br/>
for exactly the same effect. &nbsp;You will get MSG # 4 if you type the second word<br/>
before typing FORGOT SWOP &lt;CR&gt;<br/>
<br/>
Ironically, even though we can swap pixel data, there is no simple method for<br/>
swapping attribute data unless a third sprite is involved.<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 72
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>COLLISION DETECTION AND SPRITE RECOGNITION</b><br/>
<br/>
Two words are provided for collision detection, these are SCANV and SCANM.<br/>
<br/>
SCANV is used to scan a particular character position on the screen. &nbsp;If any data<br/>
is present in the specified square (co-ords are held in COL and ROW), then a true<br/>
flag is placed on the stack and if the square is empty (contains no pixel data), a<br/>
false flag is placed on the stack. Type:<br/>
<br/>
CLS VLIST 0 VARIABLE CNT &lt;CR&gt;<br/>
<br/>
This will put some data on the screen and initiate the variable CNT. &nbsp;Now type:<br/>
<br/>
: GO 0 CNT ! 24 0 DO I ROW ! 32 0 &lt;CR&gt;<br/>
DO I COL ! SCANV IF 1 CNT +! &lt;CR&gt;<br/>
ENDIF LOOP LOOP CNT ? ; &lt;CR&gt;<br/>
<br/>
This defines a word which simply counts the number of characters on the screen.<br/>
Type:<br/>
<br/>
GO &lt;CR&gt;<br/>
<br/>
This should print a number somewhere around 250.<br/>
<br/>
Often it is insufficient to determine whether a particular character square<br/>
contains data or not, and for this reason the slower, but more powerful command<br/>
SCANM, has been included. This will scan the sprite whose number is held in SPN<br/>
and put a true flag on the stack if the sprite contains pixel data, or a false<br/>
flag if it does not. &nbsp;SCANM is normally used to perform one of three functions:<br/>
<br/>
1. &nbsp;To see if data will collide.<br/>
<br/>
2. &nbsp;To detect an exact pattern.<br/>
<br/>
3. &nbsp;To detect the presence of a pattern.<br/>
<br/>
Collision detection is most commonly used to detect a collision between a sprite<br/>
moving across the screen and any data which lies in its path. &nbsp;Often the sprite<br/>
can pass through an occupied character position without a collision occurring, so<br/>
the SCANM command is insufficient. &nbsp;The procedure is basically to load a dummy<br/>
sprite with the section of screen into which the sprite is about to be put, "AND"<br/>
it with the sprite about to be PUT and then use SCANM. &nbsp;If a true flag is on the<br/>
stack the dummy sprite contains data and therefore a collision has occurred. &nbsp;This<br/>
is all very well, but a problem occurs if the new sprite position overlaps the old<br/>
sprite position, because this means that the old sprite has to be removed from the<br/>
screen before beginning the above detection procedure and subsequently PUTting the<br/>
new sprite. &nbsp;This delay causes flicker. &nbsp;The easiest solution is to work with<br/>
"XOR"s so that the window can be GOT, "XOR"ed with the old sprite in memory to<br/>
remove the old sprite data, and then to do the detection followed finally by the<br/>
blotting and then immediate PUTting.<br/>
<br/>
Once an impending collision is detected it is frequently useful to determine what<br/>
the sprite has collided with. &nbsp;To begin with, let's assume that the screen window<br/>
we're examining contains one of a known set of objects and that no other data is<br/>
present in the window. &nbsp;The method is to load the dummy sprite with the object to<br/>
be tested and then compare it against the set of sprites with which a match is<br/>
being sought. &nbsp;To compare the dummy sprite with a known sprite, all you need to do<br/>
is XOR the sprite being tested into the dummy and do a SCANM. &nbsp;If the result is<br/>
zero, an exact match was found, if not, do a second XOR into the dummy to restore<br/>
it and test the next candidate.<br/>
<br/>
<br/>
<br/>
<br/>
73
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
Finally, consider the case where the object being tested contains extraneous data<br/>
in addition to one of the possible sprites. &nbsp;This time, the dummy &nbsp;sprite is<br/>
loaded with the contents of the screen window, but the candidates are first<br/>
"AND"ed into the dummy to remove extraneous data before the XOR and SCANM.<br/>
Finally the dummy needs to be reloaded from the screen before the next test. &nbsp;This<br/>
latter test is limited by the fact that its conclusion is only that the screen<br/>
contained all the parts of the sprite with which a comparison was made. In the<br/>
extreme case of the screen window containing all pixels set, then an agreement<br/>
would be found with all the sprites tested.<br/>
<br/>
<br/>
<b>SCROLLING LANDSCAPES</b><br/>
<br/>
Scrolling landscapes are an integral part of so many video games that it is worth<br/>
a brief description of how they can best be produced using White Lightning.<br/>
<br/>
The first and most obvious point is never to scroll more than you have to. &nbsp;If,<br/>
for instance, you are moving a mountain range where the variation takes place over<br/>
the top three characters, then only the top three characters need to be stored and<br/>
moved.<br/>
<br/>
The simplest and most effective method of producing smooth scrolls is to sacrifice<br/>
a column of the screen for transactions with the sprite being scrolled. &nbsp;Suppose<br/>
we are scrolling a sprite of 4 or 5 screens width which uses rows 8 to 10 (3<br/>
rows). &nbsp;Suppose we require pixel scrolling and there is no horizontal variation in<br/>
attributes. &nbsp;It doesn't really matter which column we sacrifice, far right (column<br/>
31) or far left (column 0), but let's, for this example, use column 0. &nbsp;All that<br/>
we need to do is set up a window 1 character wide and 3 characters high on the far<br/>
left of the landscape to have the same INK and PAPER colours. &nbsp;This means that<br/>
pixel data cannot be seen in this region. &nbsp;Use the SETAV command to do this. &nbsp;To<br/>
begin with, 31 columns of the sprite are PUT to the active part of the screen<br/>
using the PWBLS command. &nbsp;If scrolling is to the left, then the dummy column<br/>
should be loaded with the next column to the right of the sprite now 'on screen'.<br/>
If scrolling is to the right then the column to the left of the sprite window<br/>
should be inserted. &nbsp;The full 32 column screen window is now wrapped in the<br/>
appropriate direction until a total of + or - 8 pixels has been accrued. &nbsp;The<br/>
dummy column is then loaded from the appropriate sprite column and so on. &nbsp;The<br/>
method can be simply adapted to make the landscape wrap and is usually implemented<br/>
under interrupt.<br/>
<br/>
<b>PROGRAMMABLE SPRITES</b><br/>
<br/>
One of the most common applications of the background mode is the setting of<br/>
sprites into automatic motion. &nbsp;Perhaps the chief advantage that a language has<br/>
over a games designer, is that the sprites thus created can have as much<br/>
'intelligence' as the programmer requires. &nbsp;A sprite can bounce off the edge of<br/>
the screen and/or other sprites until a particular event, and then totally change<br/>
its behaviour - possibly to follow a previously stored track.<br/>
<br/>
We have included a very simple listing which sets a sprite in motion, that just<br/>
bounces off the edges of the screen, to give you some idea of what is involved.<br/>
This sample program assumes you have the demonstration sprites in memory.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 74
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
SCR # 6<br/>
&nbsp; 0<br/>
&nbsp; 1<br/>
&nbsp; 2<br/>
&nbsp; 3 0 VARIABLE DELAY : WAIT DELAY @ 0 DO NOOP LOOP ;<br/>
&nbsp; 4 : BASE 0 COL ! 18 ROW ! 32 LEN ! 6 HGT ! 0 PAPER 0 INK<br/>
&nbsp; 5 SETAV 7 INK ;<br/>
&nbsp; 6 : GO16 6 PAPER 0 INK 0 BORDER CLS 7 0 AT<br/>
&nbsp; 7 10 0 DO ." WHITE LIGHTNING " LOOP 0 0 AT BASE ; --&gt;<br/>
<br/>
SCR # 7<br/>
&nbsp; 0 8 VARIABLE PX 8 VARIABLE PY 1 VARIABLE DX 1 VARIABLE DY<br/>
&nbsp; 1 0 VARIABLE SP 0 VARIABLE CL 0 VARIABLE RW : PCAL PX @ ABS<br/>
&nbsp; 2 2 /MOD CL ! PY @ ABS 2 /MOD RW ! DUP + + 251 + SP ! ;<br/>
&nbsp; 3 : MOVE PX @ 56 &gt; IF DX @ MINUS DX ! ENDIF PX @ 0 &gt; IF NOOP<br/>
&nbsp; 4 ELSE DX @ MINUS DX ! ENDIF<br/>
&nbsp; 5 PY @ 28 &gt; IF DY @ MINUS DY ! FNDIF PY @ 0 &gt; IF NOOP ELSE DY @<br/>
&nbsp; 6 MINUS DY ! ENDIF DY @ PY @ + PY ! DX @ PX @ + PX ! ;<br/>
&nbsp; 7 : LO RW @ ROW ! CL @ COL 1 SP @ SPN ! ; --&gt;<br/>
<br/>
SCR # 8<br/>
&nbsp; 0 : SOT PCAL LD EXX LD EXX PUTXRS ;<br/>
&nbsp; 1 : GO PCAL MOVE PUTXRS LD PUTXRS ;<br/>
&nbsp; 2 0 VARIABLE ICNT 2 VARIABLE LCNT<br/>
&nbsp; 3 : IRUN 1 ICNT +! ICNT @ DUP 2000 = IF -2 DX ! ENDIF DUP 4002 =<br/>
&nbsp; 4 IF 2 DY ! ENDIF DUP 6000 = IF 3 DY ! ENDIF DUP 8000 = IF 1 DY<br/>
&nbsp; 5 ! 1 DX ! ENDIF 9000 = IF INT-OFF ENDIF ;<br/>
&nbsp; 6 : TRY SOT ' GO INT-ON 9000 0 DO IRUN LOOP &nbsp;INT-OFF ;<br/>
&nbsp; 7 : SCN16 GO16 9999 DELAY ! WAIT 1 DX ! 1 DY ! 8 PX ! 8 PY ! --&gt;<br/>
<br/>
SCR # 9<br/>
&nbsp; 0 0 ICNT ! TRY WAIT 0 PAPER 7 INK CLS ;<br/>
&nbsp; 1<br/>
&nbsp; 2<br/>
&nbsp; 3<br/>
&nbsp; 4<br/>
&nbsp; 5<br/>
&nbsp; 6<br/>
&nbsp; 7<br/>
<br/>
To compile this type:<br/>
<br/>
6 LOAD &lt;CR&gt;<br/>
<br/>
and to execute type:<br/>
<br/>
SCN16 &lt;CR&gt;<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
75
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>THE BASIC INTERFACE</b><br/>
<br/>
The BASIC interface was provided to increase the flexibility of the language and<br/>
allow the newcomer to Forth, a gradual transition. &nbsp;Some applications are actually<br/>
more suited to BASIC but for games writing in general, Forth is much more<br/>
appropriate and we hope that this facility will not discourage people from<br/>
experimenting with Forth.<br/>
<br/>
There are four words to master at the Forth end and 3 USR calls to master at the<br/>
BASIC end. &nbsp;Do not use CLEAR or NEW whilst in BASIC.<br/>
<br/>
<br/>
<b>The Command Level</b><br/>
<br/>
When White Lightning is first entered from a COLD start, BASIC is located beneath<br/>
Forth and there is approximately 1k of program space if microdrives are not in<br/>
use. &nbsp;This is ample space if BASIC is only to be used at command level, to LOAD<br/>
and SAVE for instance, but if programs are to be written you will need to execute<br/>
the RESERVE command. &nbsp;For the time being, however, let's just consider operation<br/>
at the command level. &nbsp;To enter BASIC from Forth type:<br/>
<br/>
PROG &lt;CR&gt;<br/>
<br/>
To re-enter Forth from BASIC just use:<br/>
<br/>
PRINT USR 24836 &lt;CR&gt;<br/>
<br/>
This is the normal WARM start entry. &nbsp;Note that PRINT USR must be used and not<br/>
RANDOMIZE USR, or an OUT OF SCREEN error may occur.<br/>
<br/>
<br/>
<b>BASIC AS A SUBROUTINE</b><br/>
<br/>
At the next level, lines of BASIC can be executed as if they were subroutines and<br/>
then return made to your Forth program. &nbsp;The word at the Forth end is GOTO. &nbsp;To<br/>
return to Forth and continue execution use PRINT USR 30006.<br/>
<br/>
To begin with, space needs to be made in the dictionary for the basic program.<br/>
The word used to do this is RESERVE. &nbsp;What RESERVE actually does, is to make space<br/>
in the dictionary and reset BASIC's system variables to point to this new area.<br/>
This does mean, however, that if a second reserve is done, without FORGETting the<br/>
old space, then the old space is lost and can never be re-accessed. &nbsp;Do not<br/>
execute a Forth COLD start while BASIC is reserved or a RAMTOP error may occur if<br/>
insufficient memory is reserved. &nbsp;Always execute PROG as the next command after<br/>
RESERVE.<br/>
<br/>
As an example, try the following:<br/>
<br/>
DECIMAL 2000 RESERVE PROG &lt;CR&gt;<br/>
<br/>
This will set up the BASIC space and then enter it at command mode. &nbsp;The following<br/>
lines of BASIC can now be entered:<br/>
<br/>
1000 PRINT "LINE 1000 OF BASIC" : PRINT USR 30006<br/>
2000 PRINT "LINE 2000 OF BASIC"<br/>
2010 FOR I = 1 TO 8 : PRINT I : NEXT I<br/>
2020 PRINT USR 30006<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 76
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
After entering these lines type:<br/>
<br/>
PRINT USR 24836<br/>
<br/>
to re-enter Forth at command level.<br/>
<br/>
Let's now define a word which executes some Forth, some BASIC, some more Forth,<br/>
some more BASIC, and finally some more Forth. &nbsp;To begin executing BASIC at a<br/>
particular line, all that we need to do is put the line number on the stack and<br/>
then execute GOTO. Try the following:<br/>
<br/>
: FBDEM ." IN FORTH " CR 1000 GOTO ." BACK IN FORTH " &lt;CR&gt;<br/>
CR 2000 GOTO ." FORTH AGAIN " ; &lt;CR&gt;<br/>
<br/>
Now type FBDEM &lt;CR&gt;<br/>
<br/>
A more useful application would be to define words to handle cassette loading and<br/>
saving. &nbsp;BASIC source is saved and loaded in the normal way from the reserved<br/>
BASIC area.<br/>
<br/>
<br/>
<b>Forth As A Subroutine</b><br/>
<br/>
If you're an "out and out BASIC person" you're probably more likely to want to<br/>
execute Forth as a subroutine. &nbsp;To return to BASIC from Forth use the word RETUSR.<br/>
To call Forth from BASIC use RANDOMIZE USR 30000. &nbsp;Note that on this occasion it<br/>
is a RANDOMIZE USR and not a PRINT USR. &nbsp;Using the previously reserved space we<br/>
can try another example. &nbsp;First type:<br/>
<br/>
PROG &lt;CR&gt;<br/>
<br/>
to enter BASIC, then add the following lines:<br/>
<br/>
3000 PRINT " CALLING FORTH " : RANDOMIZE USR 30000<br/>
3010 PRINT " BACK IN BASIC " : PRINT USR 30006<br/>
<br/>
Now type PRINT USR 24836 to re-enter Forth.<br/>
<br/>
Now type:<br/>
<br/>
: BFDEM ." GOTO BASIC " CR 30000 GOTO ." FORTH CALLED " &lt;CR&gt;<br/>
RETUSR ." ENDING IN FORTH " CR ; &lt;CR&gt;<br/>
<br/>
Now type<br/>
<br/>
BFDEM &lt;CR&gt;<br/>
<br/>
to see the result.<br/>
<br/>
Now type<br/>
<br/>
FORGET FBDEM &lt;CR&gt;<br/>
<br/>
<br/>
<b>Passing Parameters</b><br/>
<br/>
Forth variables can easily be PEEK'ed and POKE'd from BASIC and used not only to<br/>
pass data, but also to control the execution of Forth. &nbsp;As an example, suppose we<br/>
wished to select one of 4 Forth words at any one time with a call from BASIC. &nbsp;Let<br/>
the Forth words simply be ." WORD1 ", ." WORD2 ", ." WORD3 ", ." WORD4 ". First<br/>
we'll need a variable to pass the parameter, so type:<br/>
<br/>
<br/>
<br/>
77
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
0 VARIABLE CONTROL CONTROL U. &lt;CR&gt;<br/>
<br/>
This will set up a variable called CONTROL, set it to zero and then print the<br/>
address of the least significant byte which we'll use to pass the information.<br/>
For the sake of this example suppose the address was 50000. &nbsp;We'll now use the<br/>
CASE construct to select the word to execute. &nbsp;Use the following definitions:<br/>
<br/>
: SELECT CASE 1 OF ." WORD1 " ENDOF 2 OF ." WORD2 " &lt;CR&gt;<br/>
ENDOF 3 OF ." WORD3 " ENDOF 4 OF ." WORD4 " ENDOF &lt;CR&gt;<br/>
ENDCASE CR ; &lt;CR&gt;<br/>
<br/>
If the value in CONTROL is 1 to 4, the appropriate word will be executed.<br/>
<br/>
: RUN 4000 GOTO BEGIN CONTROL @ &lt;CR&gt;<br/>
DUP SELECT DUP IF RETUSR ENDIF 0= UNTIL ; &lt;CR&gt;<br/>
<br/>
The BASIC program is initially entered at 4000 and could take the following form:<br/>
<br/>
4000 REM REPLACE ADDRESS 5000 WITH THE ADDRESS OF CONTROL<br/>
4010 PRINT " EXECUTE WORD1 " : GOSUB 5000<br/>
4020 PRINT " EXECUTE WORD2 " : GOSUB 5010<br/>
4030 PRINT " EXECUTE WORD3 " : GOSUB 5020<br/>
4040 PRINT " EXECUTE WORD4 " : GOSUB 5030<br/>
4050 PRINT " FINISH " : POKE 50000,0 : PRINT USR 30006<br/>
5000 POKE 5000,1 : RANDOMISE USR 30000 : RETURN<br/>
5010 POKE 5000,2 : RANDOMISE USR 30000 : RETURN<br/>
5020 POKE 5000,3 : RANDOMISE USR 30000 : RETURN<br/>
5030 POKE 5000,4 : RANDOMISE USR 30000 : RETURN<br/>
<br/>
Note that when final return is made to Forth a PRINT USR 30006 is used. &nbsp;If a<br/>
RANDOMISE USR 30006 CALL is made to Forth a RETUSR must be executed or the BASIC<br/>
stack will be left corrupted. &nbsp;To reset the stack if it has been corrupted, use<br/>
PROG to enter BASIC and then re-enter Forth with the WARM start, PRINT USR 24836.<br/>
<br/>
This concludes the section on the BASIC Interface.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 78
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>PROGRAM DEVELOPMENT</b><br/>
<br/>
At any one time, there are up to five areas of development: &nbsp;Forth source code,<br/>
BASIC source code, sprites, the Forth language itself, and finally the compiled<br/>
and completed program.<br/>
<br/>
<br/>
<b>Forth Source</b><br/>
<br/>
As previously discussed under the section on editing, Forth source is divided into<br/>
screens, each of 512 bytes in length. &nbsp; Each screen can be individually loaded,<br/>
saved and compiled in any order required. &nbsp;Screens can even be saved and then<br/>
loaded back into different screens. &nbsp;The real advantage of this comes when you're<br/>
writing really large programs. &nbsp;As sprite space becomes large, it will work down<br/>
over the higher screens and this can be clearly seen when an attempt is made to<br/>
List them. Don't CLEAR these screens or the sprite data will be lost!<br/>
<br/>
If really large programs are required and sprites have over-run the top screens,<br/>
then programs can be compiled a few screens at a time, loading each time into the<br/>
available screens, compiling and then loading the next section. &nbsp;Of course, you<br/>
don't need to load the sprites until compilation is complete, but it's useful to<br/>
have the facility just in case.<br/>
<br/>
To save Forth source you'll need to consult Table 1, the table of Screen<br/>
Addresses. &nbsp;If, for instance, you wanted to save screens 6 to 11, then the start<br/>
address would be 52224 decimal and the length, just 6 times 512. &nbsp;Type 6 512 * .<br/>
&lt;CR&gt; to find this figure, which is 3072. &nbsp;To save the source, type PROG to enter<br/>
BASIC and then type:<br/>
<br/>
SAVE "filename" CODE 52224,3072<br/>
<br/>
To re-enter White Lightning, type PRINT USR 24836 to do a WARM start.<br/>
<br/>
To Load the source, either type Y in response to the LOAD SOURCE Y/N prompt at the<br/>
beginning of the session, or exit to BASIC using PROG, then type:<br/>
<br/>
LOAD "filename" CODE &nbsp; &nbsp; where filename is optional.<br/>
<br/>
If you want to load the code into a different screen area from that in which it<br/>
was Saved, type:<br/>
<br/>
LOAD "filename" CODE start, length<br/>
<br/>
where start is the address of the screen to be loaded, and length is the number of<br/>
screens to be loaded multiplied by 512. &nbsp;Again, White Lightning should be<br/>
re-entered with a PRINT USR 24836. &nbsp;Do not use RANDOMISE USR 24836 or an OUT OF<br/>
SCREEN error may occur.<br/>
<br/>
<br/>
<b>BASIC Source</b><br/>
<br/>
Before BASIC source can be used in White Lightning programs, the user must execute<br/>
a RESERVE to make space for the BASIC program. &nbsp;To reserve, for example, 1K, type:<br/>
DECIMAL 1024 RESERVE. &nbsp;This will allocate 1024 bytes for BASIC source code within<br/>
the dictionary. &nbsp;If at some later stage you execute a second RESERVE the previous<br/>
1024 bytes are not reclaimed, so if you find you have not allocated enough space,<br/>
Save the BASIC source, FORGET all previous definitions, execute a COLD START, and<br/>
start the compilation from scratch. You can now do a second RESERVE.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
79
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
To save BASIC source, type PROG &lt;CR&gt; to enter BASIC if you're not already there,<br/>
then just type SAVE "filename" as normal and re-enter White Lightning with PRINT<br/>
USR 24836. &nbsp;Likewise, source can be reloaded by entering BASIC with a PROG, using<br/>
LOAD "filename" and then re-entering Forth with a PRINT USR 24836.<br/>
<br/>
<br/>
<b>Sprites</b><br/>
<br/>
Sprites can be saved from White Lightning and then re-Loaded into White Lightning,<br/>
but sprites saved by White Lightning, cannot be loaded into the sprite development<br/>
software which requires the additional array information preceding sprites &nbsp;which<br/>
is not SAVEd by White Lightning. &nbsp;Sprite development should always be done using<br/>
the development software, but if you do wish to save the sprites for later merging<br/>
then do the following:<br/>
<br/>
1. &nbsp;Find the start of sprites by typing SPST @ U.<br/>
<br/>
2. &nbsp;Find the length to save by typing SPND @ SPST @ - 1+ U.<br/>
<br/>
3. &nbsp;Note the start and length, then return to BASIC using PROG.<br/>
<br/>
4. &nbsp;Save using SAVE "filename" CODE start, length.<br/>
<br/>
5. &nbsp;Re-enter White Lightning using PRINT USR 24836.<br/>
<br/>
<br/>
<b>Merging Sprites</b><br/>
<br/>
Two blocks of sprites can be merged together in the main program using the<br/>
following procedure:<br/>
<br/>
1. &nbsp;Make a note of the SPST and SPND values of the second block to be<br/>
&nbsp; &nbsp; merged. These are displayed by the sprite development software.<br/>
<br/>
2. &nbsp;Load the main White Lightning package and then load the first block<br/>
&nbsp; &nbsp; of sprites in response to the "LOAD SPRITES Y/N" prompt.<br/>
<br/>
3. &nbsp;Load source as required and once in the main program relocate<br/>
&nbsp; &nbsp; the first block of sprites downwards by the size of the second<br/>
&nbsp; &nbsp; block. &nbsp;Suppose the decimal values for SPST and SPND of the second<br/>
&nbsp; &nbsp; block were 60000 and 65280 respectively, then type:<br/>
<br/>
&nbsp; &nbsp; DECIMAL 60000 65280 - SPST @ + U. &lt;CR&gt;<br/>
<br/>
&nbsp; &nbsp; (The DECIMAL is not required if you are already in DECIMAL mode).<br/>
&nbsp; &nbsp; This will calculate the new start after relocation. &nbsp;It is well worth<br/>
&nbsp; &nbsp; checking that this will not run over your source code, so here is a<br/>
&nbsp; &nbsp; quick calculation that will tell you if you have enough space.<br/>
&nbsp; &nbsp; You need to know the highest screen number that you intend to use, for<br/>
&nbsp; &nbsp; example screen 18. &nbsp;Type:<br/>
<br/>
&nbsp; &nbsp; 18 512 * 49664 + U. &lt;CR&gt;<br/>
<br/>
&nbsp; &nbsp; This will print the first free byte after screen 18. &nbsp;So long as<br/>
&nbsp; &nbsp; this result is lower than the new sprite start after relocation you<br/>
&nbsp; &nbsp; can proceed. &nbsp;Again, using the previous example where the block to be<br/>
&nbsp; &nbsp; merged has SPST and SPND of 60000 and 65280 respectively, the line<br/>
&nbsp; &nbsp; to type is:<br/>
<br/>
&nbsp; &nbsp; DECIMAL 60000 65280 - MLEN ! RELOCATE &lt;CR&gt;<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 80
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
&nbsp; &nbsp; The relocate command uses the value held in MLEN as the relocation<br/>
&nbsp; &nbsp; length, a negative value, as above, relocates downward and a positive<br/>
&nbsp; &nbsp; value upward.<br/>
<br/>
4. &nbsp;Before loading the second block of sprites, the values of the new<br/>
&nbsp; &nbsp; SPST and SPND should be calculated and noted. &nbsp;Type:<br/>
<br/>
&nbsp; &nbsp; SPST @ U. SPND @ 65280 60000 - + DUP SPND ! U. &lt;CR&gt;<br/>
<br/>
&nbsp; &nbsp; Take a note of these two values. &nbsp;If the previous steps have been<br/>
&nbsp; &nbsp; carried out correctly the second number (the new SPND) should be the<br/>
&nbsp; &nbsp; same value as the old SPND before relocation.<br/>
<br/>
5. &nbsp;Type: PROG &lt;CR&gt; to exit back to BASIC then type LOAD "" CODE. &nbsp;The<br/>
&nbsp; &nbsp; array of pointers will be ignored but the sprites will be loaded.<br/>
&nbsp; &nbsp; This assumes that this second block of sprites was also saved using<br/>
&nbsp; &nbsp; the sprite development software.<br/>
<br/>
6. &nbsp;Type PRINT USR 24836 to re-enter Forth and your sprites should be<br/>
&nbsp; &nbsp; merged. &nbsp;Note that if a sprite number used in the second block has<br/>
&nbsp; &nbsp; also been used in the first block, that only the first occurrence<br/>
&nbsp; &nbsp; will be found. &nbsp;If the first occurrence is destroyed using WIPE or<br/>
&nbsp; &nbsp; DSPRITE, then the second occurrence will be found.<br/>
<br/>
<br/>
<b>Extending the Forth Itself</b><br/>
<br/>
One of the beauties of the Forth language is that it is extendable, so if you've<br/>
added a few of your own commands which you would like to become a permanent<br/>
feature of your customised version, you will need to make a copy. &nbsp;For this<br/>
reason, no attempt has been made to protect the software; but we do appeal to<br/>
users not to take advantage of this facility to pirate the program. &nbsp;Piracy pushes<br/>
up the price of software to genuine users, so if you've bought a genuine copy, do<br/>
yourself a favour and keep the price of your future software affordable. &nbsp;Copying<br/>
the manual, however, will result in immediate court action and a reward will be<br/>
paid to anyone offering information leading to the successful prosecution of<br/>
offenders.<br/>
<br/>
To save the Forth use the following procedure:<br/>
<br/>
1. &nbsp;Type: WARM-&gt;COLD &lt;CR&gt; to embed the commands.<br/>
<br/>
2. &nbsp;Type: HERE 24832 - 1+ U. &lt;CR&gt; to print the length to be Saved.<br/>
<br/>
3. &nbsp;Type: PROG &lt;CR&gt; to enter BASIC.<br/>
<br/>
4. &nbsp;Save using SAVE "FORTH" CODE 24832, length.<br/>
<br/>
5. &nbsp;Re-enter using PRINT USR 24836.<br/>
<br/>
To use the amended version, LOAD White Lightning as normal, exit using PROG, LOAD<br/>
the new Forth over the old Forth and execute a Cold start using 24832.<br/>
<br/>
Oasis make no undertakings to support customised versions, and make no guarantee<br/>
as to the success of the operation.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
81
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>Compiled and Completed Programs</b><br/>
<br/>
Once the program is fully debugged and running, a final run-time version can be<br/>
produced. &nbsp;This is the only form in which programs generated from White Lightning<br/>
can be marketed.<br/>
<br/>
If the program makes use of the foreground/background facility, ZAPINT should be<br/>
typed, if not, then ZAP should be typed. &nbsp;The length of the compiled program is<br/>
then displayed until a key is pressed and control returned to BASIC to make a<br/>
copy.<br/>
<br/>
The final program should be saved using:<br/>
<br/>
SAVE "filename" CODE 24832, length<br/>
<br/>
and executed using PRINT USR 24832. &nbsp;Do not use RANDOMISE USR 24832.<br/>
<br/>
Remember that a lot of run-time software is saved with your final code, so even if<br/>
your program is only two lines long, the resulting program will be pretty large.<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>TABLE 1</b><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>Table of Screen Numbers and Addresses</b><br/>
<br/>
<br/>
Screen &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Start<br/>
Number &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Address<br/>
<br/>
&nbsp; &nbsp;1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 49664 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Each screen used for editing<br/>
&nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 50176 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;into consists of<br/>
&nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 50688 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;8 lines x 64 characters<br/>
&nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 51200 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 512 bytes.<br/>
&nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 51712<br/>
&nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 52224<br/>
&nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 52736 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Therefore, if you have only<br/>
&nbsp; &nbsp;8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 53248 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;edited into screens 6-9,<br/>
&nbsp; &nbsp;9 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 53760 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;then there is no need to save<br/>
&nbsp; 10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 54272 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ALL of the screens 1-22<br/>
&nbsp; 11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 54784 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;since you only need save<br/>
&nbsp; 12 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 55296 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;from 52224 to 54271 (end of<br/>
&nbsp; 13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 55808 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;screen 9), i.e. 2k bytes.<br/>
&nbsp; 14 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 56320<br/>
&nbsp; 15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 56832<br/>
&nbsp; 16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 57344<br/>
&nbsp; 17 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 57856<br/>
&nbsp; 18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 58368<br/>
&nbsp; 19 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 58880<br/>
&nbsp; 20 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 59392<br/>
&nbsp; 21 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 59904<br/>
&nbsp; 22 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 60416<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 82
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>FUNCTION KEY SUMMARY</b><br/>
<br/>
<b>KEY</b><br/>
<br/>
<b>A</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the ATIRIBUTE switch.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Press 1 to set switch ON.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Press 0 to set switch OFF.<br/>
<br/>
<b>B</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the BRIGHT variable.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Press 1 to set BRIGHT to ON.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Press 0 to set BRIGHT to OFF.<br/>
<br/>
<b>C</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the PAPER variable.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Press any key between 0 and 7 to activate the colour indicated<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;above the key.<br/>
<br/>
<b>D</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates DIRECT DATA INPUT<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Accepts 8 bytes of data, one byte at a time, followed by ENTER, via<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the keyboard, to the position on the sprite Screen indicated by<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the cursors. &nbsp;Inputted data must be in the range 0 to 255 Decimal<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or, H00 to HFF HEX (the character H must precede Hex entry).<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NOTE: &nbsp;If Attribute switch = 1, then the four current attributes will<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;be used at the same position as well.<br/>
<br/>
<b>E</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the SCREEN FUNCTIONS.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;You will be given three options: press 1, 2 or 3.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 INVERT<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Option 1, INVERT, sets all 0 bits to 1 and all 1 bits to 0,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;in a window whose length is held in the "Sprite length"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;variable and whose height is held in the "Sprite height"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;variable. &nbsp;The inversion will take place from the positioning<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;of the sprite screen cursors, i.e. at the intersection of an<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;imaginary line drawn from each cursor.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 MIRROR<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Option 2 MIRROR, 'Flips' a window whose height is held in the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"Sprite height" variable and whose length is held in the "Sprite<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;length" variable. &nbsp;The Mirroring will take place about the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;vertical centre of the screen window.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 MIRROR ATTRIBUTES<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Option 3 MIRROR ATTRIBUTES, 'Flips' the attributes in a window<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;whose height is held in the "Sprite height" variable and whose<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;length is held in the "Sprite length" variable. &nbsp;The Mirroring of<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Attributes will take place about the vertical centre of the screen<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;window<br/>
<br/>
<b>F</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates FLASH WINDOW.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Flashes the current screen window whose height is held in the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SPRITE HEIGHT variable and whose length is held in the SPRITE LENGTH<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;variable. &nbsp;The Flash will take place at the position of the sprite<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;screen cursors.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Flash is used to check the position of the sprite screen cursors,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;to check that the height and length parameters are as required or<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;to check that the window is correctly positioned.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
83
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>G</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates GET SPRITE function.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Gets a sprite of the dimensions held in the "Sprite height" and<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"Sprite length" variables, using the number held in the "Sprite<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Number" variable and at the window indicated by the sprite screen<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cursor - and stores it in memory.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NOTE: &nbsp;If the Attribute switch = 1, the sprite and attributes<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;are stored; if the Attribute switch = 0, then any Attributes will<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;be ignored. When a sprite is first defined with Attribute<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;switch = 0 the attribute data will probably be garbage.<br/>
<br/>
<b>H</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the SPRITE HEIGHT Variable.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Permits the input of the height of a sprite window from 1-15.<br/>
<br/>
<b>I</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the ATTRIBUTE DUMP function.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Places the four Attributes set in the four Attribute Variables,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;to the sprite screen, at the position indicated by the sprite<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;screen cursors - with a resolution of one character.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NOTE: &nbsp;This function is independent of the Attribute Switch, e.g.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;to place Attributes at position x=4, y=4: &nbsp;position sprite screen<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cursors at x=4 and y=4, then set the four attributes as required<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(you can then set the Attribute switch to 0 (OFF) if you like)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and press I.<br/>
<br/>
<b>J</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the move CHR$ SQR TO SPRITE SCREEN function.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Dumps the bit pattern set in the CHR$ SQR to a character square<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;in the sprite screen, indicated by the sprite screen cursors.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NOTE: &nbsp;If the Attribute Switch = 0, no Attributes will move with<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the pattern. &nbsp;If the Attribute switch = 1, then the Attributes<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;held in the Attribute Variables will move with the pattern.<br/>
<br/>
<b>K</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the MOVE SPRITE SCREEN CHARACTER TO CHR$ SQR<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;function.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Picks up the Character Square indicated by the Sprite Screen<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Cursors, into the CHR$ SQR.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NOTE: &nbsp;ATTR = 0 ignores Character Attributes. &nbsp;ATTR = 1 takes the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Attributes of the character and loads them into the Attribute<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Variables.<br/>
<br/>
<b>L</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the SPRITE LENGTH variable.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Permits the input of the length of a Sprite Window from 1-15.<br/>
<br/>
<b>M</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the Sprite Functions.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;You will be given three options which act in the same way as the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'SCREEN FUNCTIONS E', except that these functions operate on<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the sprite in memory only and have no effect directly on the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;screen.<br/>
<br/>
<b>N</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the No, negative response to (Y/N) questions.<br/>
<br/>
<b>O</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the Sprite Logic functions.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;You will be given three options. &nbsp;Each option GETS an area of the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sprite screen, the dimensions of which are specified as those of<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the defined sprite, having a top left-hand corner at the sprite screen<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cursor positions and logically GETs the data into the defined sprite -<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;whose number is in the Sprite Number Variable.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 84
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NOTE: &nbsp;ATTR = 0 leaves the attributes of the sprite as they are.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ATTR = 1 takes the attributes from the screen and places them<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;into the sprite.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 GETORS, ORs the screen data with the pre-defined sprite, and<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;leaves the result in the sprite (screen display unaffected).<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 GETXRS, XORs the screen data with the data of a pre-defined<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sprite, and leaves the result in the sprite, (screen<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;display unaffected).<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 GETNDS, ANDs the screen data with the data of a pre-defined<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sprite, and leaves the result in the sprite (screen display<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;unaffected).<br/>
<br/>
<br/>
<b>P</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the PUT functions.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;You will be given four options. &nbsp;Each option PUTS a sprite<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;whose number is specified in the variable "Sprite Number" onto<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the sprite screen, having a top left-hand corner at the sprite<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;screen cursor positions.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NOTE: &nbsp;ATTR = 0 leaves the Screen Attributes unaffected.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ATTR = 1 PUTs sprite Attributes to the sprite Screen.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 PUTBLS is a straightforward PUT, placing data directly to<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the sprite screen, destroying anything that is on that part of<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the screen (Sprite unaffected).<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 PUTORS, ORs the sprite data with the data on the sprite screen,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;leaving the result on the screen (Sprite unaffected).<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 PUTXRS, XORs the sprite data with the data on the sprite screen,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;leaving the result on the screen (Sprite unaffected).<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 PUTNDS, ANDs the sprite data with the data on the sprite screen,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;leaving the result on the screen (Sprite unaffected).<br/>
<br/>
<b>Q</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the CLEAR CHR$ SQR function. &nbsp;Sets all CHR$ SQR bits<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;to zero.<br/>
<br/>
<b>&lt;=</b> &nbsp; &nbsp; &nbsp; Activates the CLEAR SPRITE SCREEN function. &nbsp;Clears the sprite<br/>
<b>(SYMBOL</b> &nbsp; screen of all data and attributes.<br/>
<b>SHIFT Q)</b><br/>
<br/>
<br/>
<b>R</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the ROTATE SPRITE function.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rotates a sprite, in memory, by 90 degrees, leaving the original<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sprite unaffected. &nbsp;The new Rotated sprite must be given a new<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sprite number, as asked for. &nbsp;Attributes are automatically<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Rotated with the pixel data.<br/>
<br/>
<b>S</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the SPRITE NUMBER variable.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Permits the defining of sprites and asks for a sprite number in<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the range 1 to 255<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NOTE: &nbsp;If a sprite to be defined is given an existing sprite<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;number, a warning is displayed, advising you of this fact. &nbsp;The<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;existing sprite, or the new sprite, are in no way corrupted.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
85
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>T</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the TEST SPRITE function.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Performs a test on the sprite whose number is held in the "Sprite<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Number" variable, and does the following:<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1. &nbsp;Places the sprite height into the "Sprite height" variable.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2. &nbsp;Places the sprite length into the "Sprite length" variable.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3. &nbsp;Places the address in memory of where the sprite data starts,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;into the "Sprite" variable.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4. &nbsp;Places the address of the start of sprite space into the variable<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"SPST"<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5. &nbsp;Places the address of the end of sprite space into the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;variable "SPND".<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6. &nbsp;Calculates the remaining memory available for sprite<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;storage and places it into the "Memory Left" variable.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NOTE: &nbsp;The screen display of these variables will be updated<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if necessary.<br/>
<br/>
<b>U</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the PICK UP ATTRIBUTES function.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Picks up the attributes of the character from the sprite screen,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;indicated by the position of the sprite screen cursors and<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Loads them into the four Attribute variables.<br/>
<br/>
<b>V</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the FLASH variable. This is one of the four attributes.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Press 1 to put switch ON.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Press 0 to put switch OFF.<br/>
<br/>
<b>W</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the WIPE SPRITE function.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Wipes the sprite indicated by the "Sprite number" variable<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;totally from memory. &nbsp;All other sprites stored in memory below<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;that sprite are moved up to fill the space previously<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;occupied by the Wiped sprite.<br/>
<br/>
<b>X</b> &nbsp; &nbsp; &nbsp; &nbsp;Activate the INK variable which is one of the four attributes.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Press any key between 0 and 7 to set the colour indicated<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;above the key.<br/>
<br/>
<b>Y</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the YES, positive response to (Y/N) questions.<br/>
<br/>
<b>Z</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the pre-defined ARCADE CHARACTER function.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Place a pre-defined Arcade Character to the sprite screen.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;The top left hand corner of the character is indicated by<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;the sprite screen cursors. &nbsp;Input a number between 1 and 167<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;followed by ENTER.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NOTE: &nbsp;Each character, with its number, can be seen on the Demo B<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tape. &nbsp;A list is given at the back of this section.<br/>
<br/>
<b>NOT</b> &nbsp; &nbsp; &nbsp;Activates the SAVE SPRITES TO TAPE facility.<br/>
<b>(SYMBOL</b> &nbsp; Place a suitable cassette in your cassette recorder and<br/>
<b>SHIFT S)</b> &nbsp;position as desired. &nbsp;Press NOT, enter your filename (1 to 8<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;characters). &nbsp;The program will save three groups of data;<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;an array and two sections of code.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;After SAVEing, you will be asked to rewind the tape and VERIFY -<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;be sure to only press PLAY on your cassette recorder.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;If the programs VERIFY, the Sprite Development Program will<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return to command level with the Text Line cleared.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NOTE: &nbsp;If the program breaks because of failure to VERIFY,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;type GOTO 3 and execute a WARM START; your data will not be lost.<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 86
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>-</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the LOAD SPRITES FROM TAPE facility.<br/>
<b>(SYMBOL</b> &nbsp;Place tape in your cassette recorder. &nbsp;Press SYMBOL SHIFT J<br/>
<b>SHIFT J)</b> and press PLAY on the cassette recorder. &nbsp;Three groups of data<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;will load. &nbsp;When loaded, the Text Line will clear and the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;program will resume.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NOTE: &nbsp;Any sprites in memory will be destroyed when this command<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;is executed.<br/>
<br/>
<b>5</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the MOVE CHR$ SQR CURSOR 1 place to the left - non-<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;destructive.<br/>
<br/>
<b>6</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the MOVE CHR$ SQR CURSOR 1 place down - non-destructive.<br/>
<br/>
<b>7</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the MOVE CHR$ SQR CURSOR 1 place up - non-destructive.<br/>
<br/>
<b>8</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the MOVE CHR$ SQR CURSOR 1 place to the right -<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;non-destructive.<br/>
<br/>
<b>9</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the SET CHR$ at current position.<br/>
<br/>
<b>0</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the CLEAR CHR$ SQR at current position.<br/>
<br/>
<b>%</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the MOVE SPRITE SCREEN CURSOR 1 place to the left.<br/>
<b>(SYMBOL</b><br/>
<b>SHIFT 5)</b><br/>
<br/>
<br/>
<b>&</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the MOVE SPRITE SCREEN CURSOR 1 place down.<br/>
<b>(SYMBOL</b><br/>
<b>SHIFT 6)</b><br/>
<br/>
<br/>
<b>'</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the &nbsp;MOVE SPRITE SCREEN CURSOR 1 place up.<br/>
<b>(SYMBOL</b><br/>
<b>SHIFT 7)</b><br/>
<br/>
<br/>
<b>(</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the MOVE SPRITE SCREEN CURSOR 1 place to the right.<br/>
<b>(SYMBOL</b><br/>
<b>SHIFT 8)</b><br/>
<br/>
<br/>
<b>&lt;</b> &nbsp; &nbsp; &nbsp; &nbsp;Activates the RELOCATE SPRITES function.<br/>
<b>(SYMBOL</b> &nbsp;Allows the user to move the sprite data about in memory,<br/>
<b>SHIFT R)</b> &nbsp; &nbsp;between the top of the Sprite Generator Program and address<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;65520.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;e.g. &nbsp;a positive number i.e. 50, moves the data 50 bytes up<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;in memory. &nbsp;A negative number i.e. -50, moves the data 50<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bytes down in memory.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CAUTION - use this function with care.<br/>
<br/>
<b>BREAK</b> &nbsp; &nbsp;Activates the PLACE SPRITE INTO SPRITE WINDOW function.<br/>
and &nbsp; &nbsp; &nbsp;This allows you to place a sprite of smaller dimensions into<br/>
<b>SPACE</b> &nbsp; &nbsp;a sprite of greater dimensions, at a position of ROW,<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;COL in the greater sprite in memory - the smaller sprite is<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;left unaltered.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
87
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NOTE: &nbsp;ATTR = 0, Attributes of smaller sprite ignored.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ATTR = 1, Attributes of smaller sprite taken and placed with<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sprite.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Three options given:<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 GETBLS<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;GETs the smaller sprite directly into the window of the larger<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sprite.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 GETORS<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;GETs the smaller sprite and ORs it into the window of the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;larger sprite.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 GETXRS<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;GETs the smaller sprite and XORs it into the window of the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;larger sprite.<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 GETNDS<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;GETs the smaller sprite and ANDs it into the window of the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;larger sprite.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 88
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>THE WHITE LIGHTNING ARCADE</b><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>GRAPHICS LIBRARY</b><br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp;<b>ARCADE CHAR-</b><br/>
&nbsp; &nbsp; &nbsp;<b>ACTER NUMBER</b><br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1- &nbsp;8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Asteroids Space Ships<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;9- 11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Asteroids<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 12 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Asteroids Flying Saucer<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 13- 20 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Pac-Men<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 21- 22 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Pac-Men Ghosts<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 23- 25 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Fruit<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 26- 33 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Pac-Men Maze Parts<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 34- 44 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Assault Course type games<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 45- 54 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Defender type games<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 55- 62 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Defender type landscapes<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 63- 67 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Space Invaders<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 68- 70 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Space Invaders Bases<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 71- 74 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Space Invaders Guns etc.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 75- 84 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;City Bomber type games<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 85- 88 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Lunar Lander type games<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 89- 98 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Frogger type games<br/>
&nbsp; &nbsp; &nbsp; &nbsp; 99-107 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Centipede type games<br/>
&nbsp; &nbsp; &nbsp; &nbsp;108-117 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;War type games<br/>
&nbsp; &nbsp; &nbsp; &nbsp;118-130 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Donkey Kong type games<br/>
&nbsp; &nbsp; &nbsp; &nbsp;131-136 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Space War type games<br/>
&nbsp; &nbsp; &nbsp; &nbsp;137-141 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Explosions<br/>
&nbsp; &nbsp; &nbsp; &nbsp;142-148 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Bug-Eyed Monsters<br/>
&nbsp; &nbsp; &nbsp; &nbsp;149-152 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Robots<br/>
&nbsp; &nbsp; &nbsp; &nbsp;153-158 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Adventure type games Treasure<br/>
&nbsp; &nbsp; &nbsp; &nbsp;159-167 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Zaps<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>WHITE LIGHTNING DEMONSTRATION</b><br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>SPRITE LIBRARY</b><br/>
<br/>
<br/>
<b>SPRITE</b> &nbsp; &nbsp; &nbsp; &nbsp;<b>DESCRIPTION</b> &nbsp; &nbsp; &nbsp; <b>INK</b> &nbsp; <b>PAPER</b> &nbsp; <b>LENGTH</b> &nbsp;<b>HEIGHT</b><br/>
<b>NUMBER</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>COL</b> &nbsp; &nbsp;<b>COL</b><br/>
<br/>
&nbsp; 1 &nbsp; &nbsp; VINTAGE CAR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; 2<br/>
&nbsp; 2 &nbsp; &nbsp; VAN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; 2<br/>
&nbsp; 3 &nbsp; &nbsp; DRAGSTER &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; 2<br/>
&nbsp; 4 &nbsp; &nbsp; DUCK &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; 3<br/>
&nbsp; 5 &nbsp; &nbsp; DANCER &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; 4<br/>
&nbsp; 6 &nbsp; &nbsp; ROCKET &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; 2<br/>
&nbsp; 7 &nbsp; &nbsp; SPIDER #1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; 5<br/>
&nbsp; 8 &nbsp; &nbsp; SPIDER #2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; 5<br/>
&nbsp; 9 &nbsp; &nbsp; TOP OF TRAIN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 11 &nbsp; &nbsp; &nbsp; 2<br/>
&nbsp;10 &nbsp; &nbsp; RAILWAY TRACK &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;8 &nbsp; &nbsp; &nbsp; 1<br/>
&nbsp;11 &nbsp; &nbsp; SMALL WALL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1,5 &nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; 1<br/>
&nbsp;12 &nbsp; &nbsp; OASIS LOGO &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5,7 &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; 12 &nbsp; &nbsp; &nbsp; 4<br/>
&nbsp;13 &nbsp; &nbsp; T.V. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 15 &nbsp; &nbsp; &nbsp;12<br/>
&nbsp;14 &nbsp; &nbsp; TOP OF RAILWAY COACH &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 10 &nbsp; &nbsp; &nbsp; 2<br/>
&nbsp;15 &nbsp; &nbsp; SPACE SHIP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; 5 &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; 2<br/>
&nbsp;16 &nbsp; &nbsp; SHADOW OF SPACE SHIP &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; 7 &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; 1<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
89
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
&nbsp;17 &nbsp; &nbsp; LARGE WALL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2,7 &nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; &nbsp;8 &nbsp; &nbsp; &nbsp; 2<br/>
&nbsp;18 &nbsp; &nbsp; TRAIN WHEELS #1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4,7 &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; 11 &nbsp; &nbsp; &nbsp; 1<br/>
&nbsp;19 &nbsp; &nbsp; TRAIN WHEELS #2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4,7 &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; 11 &nbsp; &nbsp; &nbsp; 1<br/>
&nbsp;20 &nbsp; &nbsp; TRAIN WHEELS #3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4,7 &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; 11 &nbsp; &nbsp; &nbsp; 1<br/>
&nbsp;21 &nbsp; &nbsp; TRAIN WHEELS #4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4,7 &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; 11 &nbsp; &nbsp; &nbsp; 1<br/>
&nbsp;22 &nbsp; &nbsp; RAILWAY COACH #1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 10 &nbsp; &nbsp; &nbsp; 1<br/>
&nbsp;23 &nbsp; &nbsp; RAILWAY COACH #2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 10 &nbsp; &nbsp; &nbsp; 1<br/>
&nbsp;24 &nbsp; &nbsp; INVADER 0 DEGREES &nbsp; &nbsp; &nbsp; &nbsp; 6 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; 2<br/>
&nbsp;25 &nbsp; &nbsp; INVADER 90 DEGREES &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; 2<br/>
&nbsp;26 &nbsp; &nbsp; INVADER 180 DEGREES &nbsp; &nbsp; &nbsp; 6 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; 2<br/>
&nbsp;27 &nbsp; &nbsp; INVADER 270 DEGREES &nbsp; &nbsp; &nbsp; 6 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; 2<br/>
&nbsp;28 &nbsp; &nbsp; FACE WITH HAT #1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; 3<br/>
&nbsp;29 &nbsp; &nbsp; FACE WITH HAT #2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; 3<br/>
&nbsp;30 &nbsp; &nbsp; 'WHITE' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5,7 &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; &nbsp; 2<br/>
&nbsp;31 &nbsp; &nbsp; 'LIGHTNING' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5,7 &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; 10 &nbsp; &nbsp; &nbsp; 2<br/>
&nbsp;32 &nbsp; &nbsp; LIGHTNING BOLT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 13 &nbsp; &nbsp; &nbsp; 4<br/>
&nbsp;33 &nbsp; &nbsp; CRAB &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4,7 &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; 3<br/>
&nbsp;34 &nbsp; &nbsp; LUNAR LANDER &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; &nbsp; 4<br/>
&nbsp;35 &nbsp; &nbsp; RADAR #1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; 1<br/>
&nbsp;36 &nbsp; &nbsp; RADAR #2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; 1<br/>
&nbsp;37 &nbsp; &nbsp; RADAR #3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; 1<br/>
&nbsp;38 &nbsp; &nbsp; RADAR #4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; 1<br/>
&nbsp;39 &nbsp; &nbsp; RADAR #5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; 1<br/>
&nbsp;40 &nbsp; &nbsp; RADAR #6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; 1<br/>
&nbsp;41 &nbsp; &nbsp; RADAR #7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; 1<br/>
&nbsp;42 &nbsp; &nbsp; RADAR #8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; 1<br/>
&nbsp;43 &nbsp; &nbsp; EXPLOSION &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 7 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp; &nbsp; &nbsp; 2<br/>
&nbsp;44 &nbsp; &nbsp; LUNAR SURFACE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; 15 &nbsp; &nbsp; &nbsp; 1<br/>
&nbsp;45 &nbsp; &nbsp; ROTATING BALL #1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; 4<br/>
&nbsp;46 &nbsp; &nbsp; ROTATING BALL #2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; 4<br/>
&nbsp;47 &nbsp; &nbsp; ROTATING BALL #3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; 4<br/>
&nbsp;48 &nbsp; &nbsp; ROTATING BALL #4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; &nbsp; 4<br/>
&nbsp;49 &nbsp; &nbsp; CLOCKWORK TOYS #1 &nbsp; &nbsp; &nbsp; &nbsp; 4 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp;12<br/>
&nbsp;50 &nbsp; &nbsp; CLOCKWORK TOYS #2 &nbsp; &nbsp; &nbsp; &nbsp; 4 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp;12<br/>
&nbsp;59 &nbsp; &nbsp; 'TRY THIS' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;8 &nbsp; &nbsp; &nbsp; 1<br/>
&nbsp;60 &nbsp; &nbsp; 'WITHOUT' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;8 &nbsp; &nbsp; &nbsp; 1<br/>
&nbsp;61 &nbsp; &nbsp; 'FROM' &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; 0 &nbsp; &nbsp; &nbsp; &nbsp;5 &nbsp; &nbsp; &nbsp; 1<br/>
251 &nbsp; &nbsp; BOUNCING BALL #1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; 6 &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; 3<br/>
252 &nbsp; &nbsp; BOUNCING BALL #2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; 6 &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; 3<br/>
253 &nbsp; &nbsp; BOUNCING BALL #3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; 6 &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; 3<br/>
254 &nbsp; &nbsp; BOUNCING BALL #4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; 6 &nbsp; &nbsp; &nbsp; &nbsp;3 &nbsp; &nbsp; &nbsp; 3<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 90
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>Fig-FORTH GLOSSARY</b><br/>
<br/>
<br/>
This glossary contains all of the word definitions in Release 1 of fig-FORTH. &nbsp;The<br/>
definitions are presented in the order of their ASCII sort and are reproduced<br/>
courtesy of the FORTH INTEREST GROUP, P.O. BOX 1105, SAN CARLOS, CA 94070.<br/>
<br/>
The first line of each entry shows a symbolic description of each action of the<br/>
procedure on the parameter stack. &nbsp;The symbols indicate the order in which input<br/>
parameters have been placed on the stack. &nbsp;Three dashes "---" indicate the<br/>
execution point; any parameters left on the stack are listed. In this notation,<br/>
the top of the stack is to the right.<br/>
<br/>
The symbols include:<br/>
<br/>
addr &nbsp; &nbsp;memory address<br/>
b &nbsp; &nbsp; &nbsp; 8 bit byte (i.e. hi 8 bits zero)<br/>
c &nbsp; &nbsp; &nbsp; 7 bit ASCII character (hi 9 bits zero)<br/>
d &nbsp; &nbsp; &nbsp; 32 bit signed double integer, most significant portion with sign<br/>
&nbsp; &nbsp; &nbsp; &nbsp; on top of stack.<br/>
f &nbsp; &nbsp; &nbsp; boolean flag. &nbsp;0 = false, non-zero = true.<br/>
ff &nbsp; &nbsp; &nbsp;boolean false flag = 0<br/>
n &nbsp; &nbsp; &nbsp; 16 bit signed integer number<br/>
u &nbsp; &nbsp; &nbsp; 16 bit unsigned integer<br/>
tf &nbsp; &nbsp; &nbsp;boolean true flag = non-zero<br/>
<br/>
The capital letters on the right show definition characteristics:<br/>
<br/>
C &nbsp; &nbsp; &nbsp; May only be used within a colon definition. &nbsp;A digit indicates<br/>
&nbsp; &nbsp; &nbsp; &nbsp; number of memory addresses used, if other than one.<br/>
E &nbsp; &nbsp; &nbsp; Intended for execution only.<br/>
L0 &nbsp; &nbsp; &nbsp;Level zero definition of FORTH-78<br/>
L1 &nbsp; &nbsp; &nbsp;Level 1 definition of FORTH-78<br/>
P &nbsp; &nbsp; &nbsp; Has precedence bit set. &nbsp;Will execute even when compiling.<br/>
U &nbsp; &nbsp; &nbsp; A user variable.<br/>
<br/>
Unless otherwise noted, all references to numbers are for 16 bit signed integers.<br/>
The high byte of a number is on top of the stack, with the sign on the leftmost<br/>
bit. &nbsp;For 32 bit signed double numbers, the most significant bit (with the sign)<br/>
is on top.<br/>
<br/>
All arithmetic is implicitly 16 bit signed integer math, with error and underflow<br/>
indication specified.<br/>
<br/>
NOTE: &nbsp; All references to disc in this documentation can be read as references to<br/>
the disc simulation area in memory from C200H to F000H, which are treated as a<br/>
very limited disk capacity by White Lightning, and do not in any way change the<br/>
operation or description of any of the FORTH words defined in this documentation.<br/>
DO NOT use DR0, DR1 or GO.<br/>
<br/>
<br/>
<b>!</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n addr --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
Store 16 bits of n at address. &nbsp;Pronounced "store".<br/>
<br/>
<br/>
<b>!CSP</b><br/>
<br/>
Save the stack position in CSP. &nbsp;Used as part of the compiler security.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
91
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>#</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d1 --- d2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
Generate from a double number d1, the next ASCII character which is placed in an<br/>
output string. &nbsp;Result d2 is the quotient after division by BASE, and is<br/>
maintained for further processing. &nbsp;Used between &lt;# and #&gt;. &nbsp;See #S.<br/>
<br/>
<br/>
<b>#&gt;</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d --- addr count &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
Terminates numeric output conversion by dropping d, leaving the text address and<br/>
character count suitable for TYPE.<br/>
<br/>
<br/>
<b>#BUF</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --- n<br/>
<br/>
A constant returning the number of disc buffers allocated.<br/>
<br/>
<br/>
<b>#S</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;d1 --- d2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
Generates ascii text in the text output buffer, by the use of #, until a zero<br/>
double number results. &nbsp;Used between &lt;# and #&gt;.<br/>
<br/>
<br/>
<b>'</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P,L0<br/>
<br/>
Used in the form: &nbsp;' nnnn<br/>
<br/>
Leaves the parameter field address of dictionary word nnnn. &nbsp;As a compiler<br/>
directive, executes in colon definition to compile the address as a literal. &nbsp;If<br/>
the word is not found after a search of CONTEXT and CURRENT, an appropriate error<br/>
message is given. &nbsp;Pronounced "tick".<br/>
<br/>
<br/>
<b>(</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P,L0<br/>
<br/>
Used in the form: ( cccc)<br/>
<br/>
Ignore a comment that will be delimited by a right parenthesis on the same line.<br/>
May occur during execution or in a colon-definition. &nbsp;A blank after the leading<br/>
parenthesis is required.<br/>
<br/>
<br/>
<b>(.")</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;C+<br/>
<br/>
The run-time procedure, compiled by ." which transmits the following in-line text<br/>
to the selected output device. &nbsp;See ."<br/>
<br/>
<br/>
<b>(;CODE)</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;C<br/>
<br/>
The run-time procedure, compiled by ;CODE, that re-writes the code field of the<br/>
most recently defined word to point to the following machine code sequence. &nbsp;See<br/>
;CODE.<br/>
<br/>
<br/>
<b>(+LOOP)</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;C2<br/>
<br/>
The run-time procedure compiled by +LOOP, which increments the loop index by n and<br/>
tests for loop completion. &nbsp;See +LOOP.<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 92
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>(ABORT)</b><br/>
<br/>
Executes after an error when WARNING is -1. &nbsp;This word normally executes ABORT,<br/>
but may be altered (with care) to a user's alternative procedure. &nbsp;See WARNING.<br/>
<br/>
<br/>
<b>(DO)</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C<br/>
<br/>
The run-time procedure compiled by DO which moves the loop control parameters to<br/>
the return stack. &nbsp;See DO.<br/>
<br/>
<br/>
<b>(FIND)</b> &nbsp; &nbsp; addr1 addr2 --- pfa b tf (ok)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;addr1 addr2 --- ff &nbsp; &nbsp; &nbsp;(bad)<br/>
<br/>
Searches the dictionary starting at the name field address addr2, matching to the<br/>
text at addr1. &nbsp;Returns parameter field address, length byte of name field and<br/>
boolean true for a good match. &nbsp;If no match is found, only a boolean false is<br/>
left.<br/>
<br/>
<br/>
<b>(LINE)</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n1 n2 --- addr count<br/>
<br/>
Convert the line number n1 and the screen n2 to the disc buffer address containing<br/>
the data. &nbsp;A count of 64 indicates the full line text length.<br/>
<br/>
<br/>
<b>(LOOP)</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;C2<br/>
<br/>
The run-time procedure compiled by LOOP which increments the loop index and tests<br/>
for loop completion. &nbsp;See LOOP.<br/>
<br/>
<br/>
<b>(NUMBER)</b> &nbsp; &nbsp; &nbsp;d1 addr1 --- d2 addr2<br/>
<br/>
Convert the ASCII text beginning at addr1 + 1 with regard to BASE. &nbsp;The new value<br/>
is accumulated into double number d1, being left as d2. &nbsp;Addr2 is the address of<br/>
the first unconvertible digit. &nbsp;Used by NUMBER.<br/>
<br/>
<br/>
<b>*</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n1 n2 --- prod &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
Leave the signed product of two signed numbers.<br/>
<br/>
<br/>
<b>*/</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n1 n2 n3 --- n4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
Leave the ratio n4 = n1*n2/n3 where all are signed numbers. &nbsp;Retention of an<br/>
intermediate 31 bit product permits greater accuracy than would be available with<br/>
the sequence n1 n2 * n3 /.<br/>
<br/>
<br/>
<b>*/MOD</b> &nbsp; &nbsp; &nbsp; &nbsp; n1 n2 n3 --- n4 n5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Leave the quotient n5 and remainder n4 of the operation n1*n2/n3. &nbsp;A 31 bit<br/>
intermediate product is used as for */.<br/>
<br/>
<br/>
<b>+</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n1 n2 --- sum &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Leave the sum of n1+n2.<br/>
<br/>
<br/>
<br/>
93
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>+!</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n addr --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Add n to the value at the address. &nbsp;Pronounced "plus-store".<br/>
<br/>
<br/>
<b>+-</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n1 n2 --- n3<br/>
<br/>
Apply the sign of n2 to n1, which is left as n3.<br/>
<br/>
<br/>
<b>+BUF</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add1 --- addr2 f<br/>
<br/>
Advance the disc buffer address addr1 to the address of the next buffer addr2.<br/>
Boolean f is false when addr2 is the buffer presently pointed to by variable<br/>
PREV.<br/>
<br/>
<br/>
<b>+LOOP</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n1 --- (run)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;addr n2 --- (compile) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P,C2,L0<br/>
<br/>
Used in a colon-definition in the form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DO &nbsp;... &nbsp;n1 &nbsp;+LOOP<br/>
At run-time, +LOOP selectively controls branching back to the corresponding DO<br/>
based on n1, the loop index and the loop limit. &nbsp;The signed increment n1 is added<br/>
to the index and the total compared to the limit. &nbsp;The branch back to DO occurs<br/>
until the new index is equal to or greater than the limit (n1&gt;0), or until the new<br/>
index is equal to or less than the limit (n1&lt;0). &nbsp;Upon exiting the loop, the<br/>
parameters are discarded and the execution continues ahead.<br/>
<br/>
At compile time, +LOOP compiles the run-time word (+LOOP) and the branch offset<br/>
computed from HERE to the address left on the stack by DO. &nbsp;n2 is used for compile<br/>
time error checking.<br/>
<br/>
<br/>
<b>+ORIGIN</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n --- addr<br/>
<br/>
Leave the memory address relative by n to the origin parameter area. &nbsp;n is the<br/>
minimum address unit, either byte or word. &nbsp;This definition is used to access or<br/>
modify the boot-up parameters at the origin area.<br/>
<br/>
<br/>
<b>,</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n --- , &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Store n into the next available dictionary memory cell, advancing the dictionary<br/>
pointer. &nbsp;(comma)<br/>
<br/>
<br/>
<b>-</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n1 n2 --- diff &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
Leave the difference of n1-n2.<br/>
<br/>
<br/>
<b>--&gt;</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P,L0<br/>
<br/>
Continue interpretation with the next screen. &nbsp;(Pronounced next-screen).<br/>
<br/>
<br/>
<b>-DUP</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n1 --- n1 &nbsp; &nbsp; (if zero)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n1 --- n1 n1 &nbsp;(non-zero) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Reproduce n1 only if it is non-zero. &nbsp;This is usually used to copy a value just<br/>
before IF, to eliminate the need for an ELSE part to drop it.<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 94
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>-FIND</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- pfa b tf &nbsp;(found)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- ff &nbsp; &nbsp; &nbsp; &nbsp;(not found)<br/>
<br/>
Accepts the next text word (delimited by blanks) in the input stream to HERE, then<br/>
searches the CONTEXT and then CURRENT vocabularies for a matching entry. &nbsp;If<br/>
found, the dictionary entry's parameter field address, its length byte, and a<br/>
boolean true is left. &nbsp;Otherwise, only a boolean false is left.<br/>
<br/>
<br/>
<b>-TRAILING</b> &nbsp; &nbsp; &nbsp;addr n1 --- addr n2<br/>
<br/>
Adjusts the character count n1 of a text string beginning address to suppress the<br/>
output of trailing blanks. &nbsp;i.e. the characters at addr+n1 to addr+n2 are blanks.<br/>
<br/>
<br/>
<b>.</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Print a number from a signed l6 bit two's complement value, converted according to<br/>
the numeric BASE. &nbsp;A trailing blanks follows. &nbsp;Pronounced "dot".<br/>
<br/>
<br/>
<b>."</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P,L0<br/>
<br/>
Used in the form: &nbsp;." cccc "<br/>
<br/>
Compiles an in-line string cccc (delimited by the trailing "), with an execution<br/>
procedure to transmit the text to the selected output device. &nbsp;If executed outside<br/>
a definition, ." will immediately print the text until the final ". &nbsp;See (.").<br/>
<br/>
<br/>
<b>.LINE</b> &nbsp; &nbsp; &nbsp; &nbsp; line scr ---<br/>
<br/>
Print on the terminal device, a line of text by its line and screen number.<br/>
Trailing blanks are suppressed.<br/>
<br/>
<br/>
<b>.R</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n1 n2 ---<br/>
<br/>
Print the number n1 right aligned in a field whose width is n2. &nbsp;No following<br/>
blanks printed.<br/>
<br/>
<br/>
<b>/</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n1 n2 --- quot &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
Leave the signed quotient of n1/n2.<br/>
<br/>
<br/>
<b>/MOD</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n1 n2 --- rem quot &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
Leave the remainder and signed quotient of n1/n2. &nbsp;The remainder has the sign of<br/>
the dividend.<br/>
<br/>
<br/>
<b>0 1 2 3</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- n<br/>
<br/>
These small numbers are used so often, that it is attractive to define them by<br/>
name in the dictionary as constants.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
95
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>0&lt;</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n --- f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Leave a true flag if the number is less than zero (negative), otherwise leave a<br/>
false flag.<br/>
<br/>
<br/>
<b>0=</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n --- f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Leave a true flag is the number is equal to zero, otherwise leave a false flag.<br/>
<br/>
<br/>
<b>0BRANCH</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;f --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;C2<br/>
<br/>
The run-time procedure to conditionally branch. &nbsp;If f is false (zero), the<br/>
following in-line parameter is added to the interpretive pointer to branch ahead<br/>
or back. &nbsp;Compiled by IF, UNTIL, and WHILE.<br/>
<br/>
<br/>
<b>1+</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n1 --- n2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L1<br/>
<br/>
Increment n1 by l.<br/>
<br/>
<br/>
<b>2+</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n1 --- n2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L1<br/>
<br/>
Leave n1 incremented by 2.<br/>
<br/>
<br/>
<b>2!</b> &nbsp; &nbsp; nlow nhigh addr ---<br/>
<br/>
32 bit store, nhigh is stored at addr; nlow is stored at addr+2.<br/>
<br/>
<br/>
<b>2@</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;addr --- nlow nhigh<br/>
<br/>
32 bit fetch, nhigh is fetched from addr; nlow is fetched from addr-2.<br/>
<br/>
<br/>
<b>2DUP</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n2 n1 --- n2 n1 n2 n1<br/>
<br/>
Duplicates the top two values on the stack. &nbsp;Equivalent to OVER OVER.<br/>
<br/>
<br/>
<b>:</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P,E,L0<br/>
<br/>
Used in the form called a colon-definition:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;: cccc &nbsp;... &nbsp;;<br/>
Creates a dictionary entry defining cccc as equivalent to the following sequence<br/>
of Forth word definitions '...' until the next ';' or ';CODE'. &nbsp;The compiling<br/>
process is done by the text interpreter as long as STATE is non-zero. &nbsp;Other<br/>
details are that the CONTEXT vocabulary is set to the CURRENT vocabulary and that<br/>
words with the precedence bit set (P) are executed rather than being compiled.<br/>
<br/>
<br/>
<b>;</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P,C,L0<br/>
<br/>
Terminate a colon-definition and stop further compilation. &nbsp;Compiles the run-time<br/>
;S.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 96
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>;CODE</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P,C,L0<br/>
<br/>
Used in the form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;: cccc &nbsp;.... &nbsp;;CODE<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;assembly mnemonics<br/>
Stop compilation and terminate a new defining word cccc by compiling (;CODE). &nbsp;Set<br/>
the CONTEXT vocabulary to ASSEMBLER, assembling to machine code the following<br/>
mnemonics. &nbsp;This facility is included for those users who may wish to write a Z80<br/>
Assembler in FORTH.<br/>
<br/>
When cccc later executes in the form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cccc &nbsp; nnnn<br/>
the word nnnn will be created with its execution procedure given by the machine<br/>
code following cccc. &nbsp;That is, when nnnn is executed, it does so by jumping to the<br/>
code after nnnn. &nbsp;An existing defining word must exist in cccc prior to ;CODE.<br/>
<br/>
<br/>
<b>;S</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P,L0<br/>
<br/>
Stop interpretation of a screen. &nbsp;;S is also the run-time word compiled at the end<br/>
of a colon-definition, which returns execution to the calling procedure.<br/>
<br/>
<br/>
<b>&lt;</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n1 n2 --- f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Leave a true flag if n1 is less than n2; otherwise leave a false flag.<br/>
<br/>
<br/>
<b>&lt;#</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Setup for pictured numeric output formatting using the words:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;# &nbsp;# &nbsp;#S &nbsp;SIGN &nbsp;#&gt;<br/>
The conversion is done on a double number producing text at PAD.<br/>
<br/>
<br/>
<b>&lt;BUILDS</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C,L0<br/>
<br/>
Used within a colon-definition:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;: &nbsp;cccc &nbsp;&lt;BUILDS &nbsp;...<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DOES&gt; &nbsp; &nbsp;... &nbsp;;<br/>
Each time cccc is executed, &lt;BUILDS defines a new word with a high-level execution<br/>
procedure. &nbsp;Executing cccc in the form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cccc &nbsp;nnnn<br/>
uses &lt;BUILDS to create a dictionary entry for nnnn with a call to the DOES&gt; part<br/>
for nnnn. &nbsp;When nnnn is later executed, it has the address of its parameter area<br/>
on the stack and executes the words after DOES&gt; in cccc. &nbsp;&lt;BUILDS and DOES&gt; allow<br/>
run-time procedures to written in high-level, rather than in assembler code (as<br/>
required by ;CODE).<br/>
<br/>
<br/>
<b>=</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n1 n2 --- f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Leave a true flag if n1=n2 otherwise leave a false flag.<br/>
<br/>
<br/>
<b>&gt;</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n1 n2 --- f &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Leave a true flag if n1 is greater than n2 otherwise a false flag.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
97
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>&gt;R</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;C,L0<br/>
<br/>
Remove a number from the computation stack and place as the most accessible on the<br/>
return stack. &nbsp;Use should be balanced with R&gt; in the same definition.<br/>
<br/>
<br/>
<b>?</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Print the value contained at the address in free format according to the current<br/>
base.<br/>
<br/>
<br/>
<b>?COMP</b><br/>
<br/>
Issue error message if not compiling.<br/>
<br/>
<br/>
<b>?CSP</b><br/>
<br/>
Issue error message if stack position differs from value saved in CSP.<br/>
<br/>
<br/>
<b>ERROR</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;f n ---<br/>
<br/>
Issue an error message number n, if the boolean flag is true.<br/>
<br/>
<br/>
<b>?EXEC</b><br/>
<br/>
Issue an error message if not executing.<br/>
<br/>
<br/>
<b>?LOADING</b><br/>
<br/>
Issue an error message if not loading<br/>
<br/>
<br/>
<b>?PAIRS</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n1 n2 ---<br/>
<br/>
Issue an error message if n1 does not equal n2. &nbsp;The message indicates that<br/>
compiled conditionals do not match.<br/>
<br/>
<br/>
<b>?STACK</b><br/>
<br/>
Issue an error message is the stack is out of bounds.<br/>
<br/>
<br/>
<b>?TERMINAL</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- f<br/>
<br/>
Perform a test of the terminal keyboard for actuation of the break key. &nbsp;A true<br/>
flag indicates actuation.<br/>
<br/>
<br/>
<b>@</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr --- n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Leave the 16 bit contents of address.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 98
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>ABORT</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
Clear the stacks and enter the execution state. &nbsp;Return control to the operator's<br/>
terminal, printing a message appropriate to the installation.<br/>
<br/>
<br/>
<b>ABS</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n --- u &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Leave the absolute value of n as u.<br/>
<br/>
<br/>
<b>AGAIN</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr n --- (compiling) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P,C2,L0<br/>
<br/>
Used in a colon-definition in the form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BEGIN &nbsp;... &nbsp;AGAIN<br/>
At run-time, AGAIN forces execution to return to corresponding BEGIN. &nbsp;There is no<br/>
effect on the stack. &nbsp;Execution cannot leave this loop (unless R&gt; is executed one<br/>
level below).<br/>
<br/>
At compile time, AGAIN compiles BRANCH with an offset from HERE to addr. &nbsp;n is<br/>
used for compile-time error checking.<br/>
<br/>
<br/>
<b>ALLOT</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Add the signed number to the dictionary pointer DP. &nbsp;May be used to reserve<br/>
dictionary space or re-origin memory. &nbsp;n is with regard to computer address type<br/>
(byte or word).<br/>
<br/>
<br/>
<b>AND</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n1 n2 --- n2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
Leave the bitwise logical "AND" of n1 and n2 as n3.<br/>
<br/>
<br/>
<b>B/BUF</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- n<br/>
<br/>
This constant leaves the number of bytes per disc buffer, the byte count read from<br/>
disc by BLOCK.<br/>
<br/>
<br/>
<b>B/SCR</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- n<br/>
<br/>
This component leaves the number of blocks per editing screen. &nbsp;By convention, an<br/>
editing screen is 512 bytes, organised as 8 lines of 64 characters each.<br/>
<br/>
<br/>
<b>BACK</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;addr ---<br/>
<br/>
Calculate the backward branch offset from HERE to addr and compile into the next<br/>
available dictionary memory address.<br/>
<br/>
<br/>
<b>BASE</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --- addr<br/>
<br/>
A user variable containing the current number base used for input and output<br/>
conversion.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
99
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>BEGIN</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- addr n (compilation) &nbsp; &nbsp; &nbsp; &nbsp; P,L0<br/>
<br/>
Occurs in a colon-definition in form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BEGIN &nbsp;... &nbsp;UNTIL<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BEGIN &nbsp;... &nbsp;AGAIN<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BEGIN &nbsp;... &nbsp;WHILE &nbsp;... &nbsp;REPEAT<br/>
At run-time, BEGIN marks the start of a sequence that may be repetitively<br/>
executed. &nbsp;It serves as a return point from the corresponding UNTIL, AGAIN or<br/>
REPEAT. &nbsp;When executing UNTIL, a return to BEGIN will occur if the top of the<br/>
stack is false; for AGAIN and REPEAT, a return to BEGIN always occurs.<br/>
<br/>
At compile time BEGIN leaves its return address and n for compiler error checking.<br/>
<br/>
<br/>
<b>BL</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --- c<br/>
<br/>
A constant that leaves the ASCII value for blank.<br/>
<br/>
<br/>
<b>BLANKS</b> &nbsp; &nbsp; &nbsp;addr count ---<br/>
<br/>
Fill in an area of memory beginning at addr with blanks.<br/>
<br/>
<br/>
<b>BLK</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
A user variable containing the block number being interpreted. &nbsp;If zero, input is<br/>
being taken from the terminal input buffer.<br/>
<br/>
<br/>
<b>BLOCK</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n --- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
Leave the memory address of the block buffer containing block n. &nbsp;If the block is<br/>
not already in memory, it is transferred from disc to whichever buffer was least<br/>
recently written. &nbsp;If the block occupying that buffer has been marked as updated,<br/>
it is re-written to disc before block n is read into the buffer. See also BUFFER,<br/>
R/W UPDATE FLUSH.<br/>
<br/>
<br/>
<b>BRANCH</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C2,L0<br/>
<br/>
The run-time procedure to unconditionally branch. &nbsp;An in-line offset is added to<br/>
the interpretive pointer IP to branch ahead or back. &nbsp;BRANCH is compiled by ELSE,<br/>
AGAIN, REPEAT.<br/>
<br/>
<br/>
<b>BUFFER</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n --- addr<br/>
<br/>
Obtain the next memory buffer, assigning it to block n. &nbsp;If the contents of the<br/>
buffer are marked up as updated, it is written to the disc. &nbsp;The block is not read<br/>
from the disc. &nbsp;The address left is the first cell within the buffer for data<br/>
storage.<br/>
<br/>
<br/>
<b>C!</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;b addr ---<br/>
<br/>
Store 8 bits at address.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;100
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>C,</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b ---<br/>
<br/>
Store 8 bits of b into the next available dictionary byte, advancing the<br/>
dictionary pointer.<br/>
<br/>
<br/>
<b>C@</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;addr --- b<br/>
<br/>
Leave the 8 bit contents of memory address.<br/>
<br/>
<br/>
<b>CASE</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --- n (compiling)<br/>
<br/>
Occurs in a colon definition in the form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CASE<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n OP ..... ENDOF<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .....<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ENDCASE<br/>
At run-time, CASE marks the start of a sequence of OF ... ENDOF statements.<br/>
<br/>
At compile time CASE leaves n for compiler error checking.<br/>
<br/>
<br/>
<b>CFA</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pfa --- cfa<br/>
<br/>
Convert the parameter field address of a definition to its code field address.<br/>
<br/>
<br/>
<b>CMOVE</b> &nbsp; &nbsp;from to count ---<br/>
<br/>
Move the specified quantity of bytes beginning at address 'from' to address 'to'.<br/>
The contents of address 'from' are moved first proceeding toward high memory.<br/>
<br/>
<br/>
<b>COLD</b><br/>
<br/>
The cold start procedure to adjust the dictionary pointer to the minimum standard<br/>
and restart via ABORT. &nbsp;May be called from the terminal to remove application<br/>
programs and restart.<br/>
<br/>
<br/>
<b>COMPILE</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C2<br/>
<br/>
When the word containing COMPILE executes, the execution address of the word<br/>
following COMPILE is copied (compiled) into the dictionary. &nbsp;This allows specific<br/>
compilation situations to be handled in addition to simply compiling an execution<br/>
address (which the interpreter already does).<br/>
<br/>
<br/>
<b>CONSTANT</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
A defining word used in the form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n &nbsp;CONSTANT &nbsp;cccc<br/>
to create word cccc, with its parameter field containing n. &nbsp;When cccc is later<br/>
executed, it will push the value of n to the stack.<br/>
<br/>
<br/>
<b>CONTEXT</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; U,L0<br/>
<br/>
A user variable containing a pointer to the vocabulary within which dictionary<br/>
searches will first begin.<br/>
<br/>
<br/>
<br/>
101
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>COUNT</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;addr1 --- addr2 n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Leave the byte address addr2 and byte count n of a message text beginning at<br/>
address addr1. &nbsp;It is presumed that the first byte at addr1 contains the text byte<br/>
count and that the actual text starts with the second byte. &nbsp;Typically, COUNT is<br/>
followed by TYPE.<br/>
<br/>
<br/>
<b>CR</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Transmit a carriage return and line feed to the selected output device.<br/>
<br/>
<br/>
<b>CREATE</b><br/>
<br/>
A defining word used in the form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CREATE cccc<br/>
by such words as CODE and CONSTANT to create a dictionary header for a Forth<br/>
definition. &nbsp;The code field contains the address of the word's parameter field. &nbsp;A<br/>
new word is created in the CURRENT vocabulary.<br/>
<br/>
<br/>
<b>CSP</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;U<br/>
<br/>
A user variable temporarily storing the stack pointer position, for compilation<br/>
error checking.<br/>
<br/>
<br/>
<b>D+</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d1 d2 --- dsum<br/>
<br/>
Leave the double number sum of two double numbers.<br/>
<br/>
<br/>
<b>D+-</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d1 n --- d2<br/>
<br/>
Apply the sign of n to the double number d1, leaving it as d2.<br/>
<br/>
<br/>
<b>D.</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L1<br/>
<br/>
Print a signed double number from a 32 bit two's complement value. &nbsp;The high-order<br/>
l6 bits are most accessible on the stack. &nbsp;Conversion is performed according to<br/>
the current base. &nbsp;A blank follows. &nbsp;Pronounced D-dot.<br/>
<br/>
<br/>
<b>D.R</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;d n --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Print a signed double number d right aligned in a field n characters wide.<br/>
<br/>
<br/>
<b>DABS</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d --- ud<br/>
<br/>
Leave the absolute value of a double number.<br/>
<br/>
<br/>
<b>DECIMAL</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
Set the numeric conversion BASE for decimal input-output.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;102
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>DEFINITIONS</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L1<br/>
<br/>
Used in the form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cccc DEFINITIONS<br/>
Set the CURRENT vocabulary to the CONTEXT vocabulary. &nbsp;In the example, executing<br/>
vocabulary name cccc made it in the CONTEXT vocabulary, and executing DEFINITIONS<br/>
made both specify vocabulary cccc.<br/>
<br/>
<br/>
<b>DIGIT</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c n1 --- n2 tf &nbsp;(ok)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c n1 --- ff &nbsp; &nbsp; (bad)<br/>
<br/>
Converts the ASCII characters c (using base n1) to its binary equivalent n2,<br/>
accompanied by a true flag. &nbsp;If the conversion is invalid, leaves only a false<br/>
flag.<br/>
<br/>
<br/>
<b>DLITERAL</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d --- d &nbsp;(executing)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;d --- &nbsp; &nbsp;(compiling) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P<br/>
<br/>
If compiling, compile a stack double number into a literal. &nbsp;Later execution of<br/>
the definition containing the literal will push it to the stack. &nbsp;If executing,<br/>
the number will remain on the stack.<br/>
<br/>
<br/>
<b>DMINUS</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;d1 --- d2<br/>
<br/>
Convert d1 to its double number two's complement.<br/>
<br/>
<br/>
<b>DO</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n1 n2 --- (execute)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr n --- (compile) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P,C2,L0<br/>
<br/>
Occurs in a colon-definition in form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DO &nbsp;... &nbsp;LOOP<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DO &nbsp;... +LOOP<br/>
At run time, DO begins a sequence with repetitive execution controlled by a loop<br/>
limit n1 and an index with initial value n2. &nbsp;DO removes these from the stack.<br/>
Upon reaching LOOP the index is incremented by one. &nbsp;Until the new index equals or<br/>
exceeds the limit, execution loops back to just after DO otherwise the loop<br/>
parameters are discarded and execution continues ahead. &nbsp;Both n1 and n2 are<br/>
determined at run-time and may be the result of other operations. &nbsp;Within a loop,<br/>
'I' will copy the current value of the index to the stack. &nbsp;See I, LOOP, +LOOP,<br/>
LEAVE.<br/>
<br/>
When compiling within the colon definition, DO compiles (DO), leaving the<br/>
following address addr and n for later error checking.<br/>
<br/>
<br/>
<b>DOES&gt;</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
A word which defines the run-time action within a high-level defining word. &nbsp;DOES&gt;<br/>
alters the code field and first parameter of the new word, to execute the sequence<br/>
of compiled word addresses following DOES&gt;. &nbsp;Used in combination with &lt;BUILDS.<br/>
When the word DOES&gt; part executes, it begins with the address of the first<br/>
parameter of the new word on the stack. &nbsp;This allows interpretation using this<br/>
area or its contents. &nbsp;Typical uses include the Forth assembler, multi-dimensional<br/>
arrays and compiler generation.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
103
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>DP</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;U,L<br/>
<br/>
A user variable, the dictionary pointer, which contains the address of the next<br/>
free memory above the dictionary. &nbsp;The value may be read by HERE and altered by<br/>
ALLOT.<br/>
<br/>
<br/>
<b>DPL</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; U,L0<br/>
<br/>
A user variable containing the number of digits to the right of the decimal on<br/>
double integer input. &nbsp;It may also be used to hold output column location of a<br/>
decimal point, in user generated formatting. &nbsp;The default value on single number<br/>
input is -1.<br/>
<br/>
<br/>
<b>DROP</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Drop the number from the stack.<br/>
<br/>
<br/>
<b>DUMP</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;addr --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Print the contents of n memory locations beginning at addr. &nbsp;Both addresses and<br/>
contents are shown in the current numeric base.<br/>
<br/>
<br/>
<b>DUP</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n --- n n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Duplicate the value on the stack.<br/>
<br/>
<br/>
<b>ELSE</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;addr1 n1 --- addr2 n2<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (compiling) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P,C2,L0<br/>
<br/>
Occurs within a colon-definition within the form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IF &nbsp;... &nbsp;ELSE &nbsp;... &nbsp;ENDIF<br/>
At run-time, ELSE executes after the true part following IF. &nbsp;ELSE forces the<br/>
execution to skip over the following false part, and resumes execution after the<br/>
ENDIF. &nbsp;It has no stack effect.<br/>
<br/>
A compile time ELSE emplaces branch reserving a branch offset, leaves the address<br/>
addr2 and n2 for error treating. &nbsp;ELSE also resolves the pending forward branch<br/>
from IF by calculating the offset from addr1 to HERE and storing at addr1.<br/>
<br/>
<br/>
<b>EMIT</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Transmit ASCII character c to the selected output device. &nbsp;OUT is incremented for<br/>
each character output.<br/>
<br/>
<br/>
<b>EMPTY-BUFFERS</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
Mark all block-buffers as empty, not necessarily affecting the contents. &nbsp;Updated<br/>
blocks are not written to the disc. &nbsp;This is also an initialization procedure<br/>
before first use of the disc.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;104
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>ENCLOSE</b> &nbsp; &nbsp; &nbsp; &nbsp;addr1 c --- addr1 n1 n2 n3<br/>
<br/>
The text scanning primitive used by WORD. &nbsp;From the text address addr1 and an<br/>
ASCII delimiting character c, is determined the byte offset to the first<br/>
non-delimiter character n1, the offset to the first delimiter after the text n2,<br/>
and the offset to the first character not included. &nbsp;This procedure will not<br/>
process past an ASCII 'null', treating it as an unconditional delimiter.<br/>
<br/>
<br/>
<b>END</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P,C2,L0<br/>
<br/>
This is an 'alias' or duplicate definition for UNTIL.<br/>
<br/>
<br/>
<b>ENDCASE</b> &nbsp; &nbsp; &nbsp; &nbsp; addr n --- (compile)<br/>
<br/>
Occurs in a colon definition in the form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CASE<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n OF ..... ENDOF<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .....<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ENDCASE<br/>
At run-time ENDCASE marks the conclusion of a CASE statement.<br/>
<br/>
At compile time ENDCASE computes forward branch offsets.<br/>
<br/>
<br/>
<b>ENDIF</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr n --- (compile) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P,C0,L0<br/>
<br/>
At run-time, ENDIF serves only as the destination of a forward branch from IF or<br/>
ELSE. &nbsp;It marks the conclusion of the conditional structure. &nbsp;THEN is another name<br/>
for ENDIF. &nbsp;Both names are supported in Fig-FORTH. &nbsp;See also IF and ELSE.<br/>
<br/>
At compile time, ENDIF computes the forward branch offset from addr to HERE and<br/>
stores it at addr. &nbsp;n is used for error tests.<br/>
<br/>
<br/>
<b>ENDOF</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr n --- (compile)<br/>
<br/>
Used as ENDIF but in CASE statements.<br/>
<br/>
<br/>
<b>ERASE</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr n ---<br/>
<br/>
Clear a region of memory to zero from addr over n addresses.<br/>
<br/>
<br/>
<b>ERROR</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; line --- in blk<br/>
<br/>
Execute error notification and restart of system. &nbsp;WARNING is first examined. &nbsp;If<br/>
1, the text of line n, relative to screen 4 of drive 0 is printed. &nbsp;This line<br/>
number may be positive or negative, and beyond just screen 4. &nbsp;If WARNING=0, n is<br/>
just printed as a message number (non disc installation). &nbsp;If warning is -l, the<br/>
definition ABORT is executed, which executes the system ABORT. &nbsp;The user may<br/>
cautiously modify this by altering (ABORT). &nbsp;Fig-FORTH saves the contents of IN<br/>
and BLK to assist in determining the location of the error. &nbsp;Final action is<br/>
execution of QUIT.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
105
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>EXECUTE</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr ---<br/>
<br/>
Execute the definition whose code field address is on the stack. &nbsp;The code field<br/>
address is also called the compilation address.<br/>
<br/>
<br/>
<b>EXPECT</b> &nbsp; &nbsp; &nbsp;addr count --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Transfer characters from the terminal to address, until a return or the count of<br/>
characters has been received. &nbsp;One or more nulls are added at the end of the<br/>
text.<br/>
<br/>
<br/>
<b>FENCE</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;U<br/>
<br/>
A user variable containing an address below which FORGETting is trapped. &nbsp;To<br/>
forget below this point the user must alter the contents of FENCE.<br/>
<br/>
<br/>
<b>FILL</b> &nbsp; &nbsp; &nbsp; addr quan b ---<br/>
<br/>
Fill memory at the address with the specified quantity of bytes b.<br/>
<br/>
<br/>
<b>FIRST</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- n<br/>
<br/>
A constant that leaves the address of the first (lowest) block buffer.<br/>
<br/>
<br/>
<b>FLD</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;U<br/>
<br/>
A user variable for control of number output field width. &nbsp;Presently unused in<br/>
Fig-FORTH.<br/>
<br/>
<br/>
<b>FORGET</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;E,L0<br/>
<br/>
Deletes definition named cccc from the dictionary with all entries physically<br/>
following it. &nbsp;In Fig-FORTH, an error message will occur if the CURRENT and<br/>
CONTEXT vocabularies are not currently the same.<br/>
<br/>
<br/>
<b>FORTH</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P,L1<br/>
<br/>
The name of the primary vocabulary. &nbsp;Execution makes FORTH the CONTEXT vocabulary.<br/>
Until additional user vocabularies are defined, new user definitions become a part<br/>
of FORTH. &nbsp;FORTH is immediate, so it will execute during the creation of a<br/>
colon-definition, to select this vocabulary at compile time.<br/>
<br/>
<br/>
<b>HERE</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
Leave the address of the next available dictionary location.<br/>
<br/>
<br/>
<b>HEX</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
Set the numeric conversion base to sixteen (hexadecimal).<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;106
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>HLD</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
A user variable that holds the address of the latest character of text during<br/>
numeric output conversion.<br/>
<br/>
<br/>
<b>HOLD</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Used between &lt;# and #&gt; to insert an ASCII character into a pictured numeric output<br/>
string.<br/>
<br/>
e.g. &nbsp;2E HOLD will place a decimal point.<br/>
<br/>
<br/>
<b>I</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;C,L0<br/>
<br/>
Used within a DO-LOOP to copy the loop index to the stack. &nbsp;Other use is<br/>
implementation dependent. &nbsp;See R.<br/>
<br/>
<br/>
<b>ID.</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr ---<br/>
<br/>
Print a definition's name from its name field address.<br/>
<br/>
<br/>
<b>IF</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(run-time)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- addr n &nbsp; (compile) &nbsp; &nbsp; &nbsp; &nbsp;P,C2,L0<br/>
<br/>
Occurs in a colon-definition in the form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IF &nbsp;(tp) &nbsp;... &nbsp;ENDIF<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IF &nbsp;(tp) &nbsp;... &nbsp;ELSE &nbsp;(fp) &nbsp;... &nbsp;ENDIF<br/>
At run-time, IF selects execution based on a boolean flag. &nbsp;If f is a true<br/>
(non-zero), execution continues ahead through the true part. &nbsp;If f is false<br/>
(zero), execution skips till just after ELSE to execute the false part. &nbsp;After<br/>
either part, execution resumes after ENDIF. &nbsp;ELSE and its false part are optional;<br/>
if missing, false execution skips to just after ENDIF.<br/>
<br/>
At compile time, IF compiles 0BRANCH and reserves space for an offset at addr.<br/>
addr and n are used later for resolution of the offset and error testing.<br/>
<br/>
<br/>
<b>IMMEDIATE</b><br/>
<br/>
Mark the most recently made definition so that when encountered at compile time it<br/>
will be executed rather than compiled, i.e. &nbsp;the precedence bit in its header is<br/>
set. &nbsp;This method allows definitions to handle unusual compiling situations,<br/>
rather than build them into the fundamental compiler. &nbsp;The user may force<br/>
compilation of an immediate definition by preceding it with [COMPILE].<br/>
<br/>
<br/>
<b>IN</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
A user variable containing the byte offset within the current input text buffer<br/>
(terminal or disc) from which the next text will be accepted. &nbsp;WORD uses and moves<br/>
the value of IN.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
107
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>INDEX</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;from to ---<br/>
<br/>
Print the first line of each screen over the range from, to. &nbsp;This is used to view<br/>
the comment lines of an area of text on disc screens.<br/>
<br/>
<br/>
<b>INTERPRET</b><br/>
<br/>
The outer text interpreter which sequentially executes or compiles text from the<br/>
input stream (terminal or disc) depending on STATE. &nbsp;If the word name cannot be<br/>
found after a search of CONTEXT and then CURRENT, it is converted to a number<br/>
according to the current base. &nbsp;That also failing, an error message echoing the<br/>
name with a "?" will be given. &nbsp;Text input will be taken according to the<br/>
convention for WORD. &nbsp;If a decimal point is found as part of a number, a double<br/>
number value will be left. &nbsp;The decimal point has no other purpose than to force<br/>
this action. &nbsp;See NUMBER.<br/>
<br/>
<br/>
<b>KEY</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- c &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Leave the ASCII value of the next terminal key struck.<br/>
<br/>
<br/>
<b>LATEST</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --- addr<br/>
<br/>
Leave the name field address of the topmost word in the CURRENT vocabulary.<br/>
<br/>
<br/>
<b>LEAVE</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; C,L0<br/>
<br/>
Force termination of a DO-LOOP at the next opportunity by setting the loop limit<br/>
equal to the current value of the index. &nbsp;The index itself remains unchanged, and<br/>
execution proceeds normally until LOOP or +LOOP is encountered.<br/>
<br/>
<br/>
<b>LFA</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pfa --- lfa<br/>
<br/>
Convert the parameter field address of a dictionary definition to its link field<br/>
address.<br/>
<br/>
<br/>
<b>LIMIT</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- n<br/>
<br/>
A constant leaving the address just above the highest memory available for a disc<br/>
buffer. &nbsp;Usually this is the highest system memory.<br/>
<br/>
<br/>
<b>LINE</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n --- addr<br/>
<br/>
Leave address of line n of current screen. &nbsp;This address will be in the disc<br/>
buffer area<br/>
<br/>
<br/>
<b>LIST</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Display the ASCII text of screen n on the selected output device. &nbsp;SCR contains<br/>
the screen number during and after this process.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;108
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>LIT</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;C,L0<br/>
<br/>
Within a colon-definition, LIT is automatically compiled before each 16 bit<br/>
literal number encountered in input text. &nbsp;Later execution of LIT causes the<br/>
contents of the next dictionary address to be pushed to the stack.<br/>
<br/>
<br/>
<b>LITERAL</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n --- (compiling) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P,C2,L0<br/>
<br/>
If compiling, then compile the stack value n as a 16 bit literal. &nbsp;This definition<br/>
is immediate so that it will execute during a colon definition. &nbsp;The intended use<br/>
is:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : &nbsp;xxx &nbsp; (calculate) LITERAL &nbsp;;<br/>
Compilation is suspended for the compile time calculation of a value. &nbsp;Compilation<br/>
is resumed and LITERAL compiles this value.<br/>
<br/>
<br/>
<b>LOAD</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Begin interpretation of screen n. &nbsp;Loading will terminate at the end of the screen<br/>
or at ;S. &nbsp;See ;S and --&gt;.<br/>
<br/>
<br/>
<b>LOOP</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;addr n --- (compiling) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P,C2,L0<br/>
<br/>
Occurs in a colon-definition in form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DO &nbsp;... &nbsp;LOOP<br/>
At run-time, LOOP selectively controls branching back to the corresponding DO<br/>
based on the loop index and limit. &nbsp;The loop index is incremented by one and<br/>
compared to the limit. &nbsp;The branch back to DO occurs until the index equals or<br/>
exceeds the limit; at that time, the parameters are discarded and execution<br/>
continues ahead.<br/>
<br/>
At compile-time. &nbsp;LOOP compiles (LOOP) and uses addr to calculate an offset to DO.<br/>
n is used for error testing.<br/>
<br/>
<br/>
<b>M*</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n1 n2 --- d<br/>
<br/>
A mixed magnitude math operation which leaves the double number signed product of<br/>
two signed numbers.<br/>
<br/>
<br/>
<b>M/</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;d n1 --- n2 n3<br/>
<br/>
A mixed magnitude math operator which leaves the signed remainder n2 and signed<br/>
quotient n3, from a double number dividend and divisor n1. &nbsp;The &nbsp;remainder takes<br/>
its sign from the dividend.<br/>
<br/>
<br/>
<b>M/MOD</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ud1 u2 --- u3 ud4<br/>
<br/>
An unsigned mixed magnitude math operation which leaves a double quotient ud4 and<br/>
remainder u3, from a double dividend ud1 and single divisor u2.<br/>
<br/>
<br/>
<b>MAX</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n1 n2 --- max &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Leaves the greater of two numbers.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
109
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>MESSAGE</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n ---<br/>
<br/>
Print on the selected output device the text of line n relative to screen 4 of<br/>
drive 0. &nbsp;n may be positive or negative. &nbsp;MESSAGE may be used to print incidental<br/>
text such as report headers. &nbsp;If WARNING is zero, the message will simply be<br/>
printed as a number (disc unavailable).<br/>
<br/>
<br/>
<b>MIN</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n1 n2 --- min &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Leave the smaller of two numbers.<br/>
<br/>
<br/>
<b>MINUS</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n1 --- n2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
Leave the two's complement of a number.<br/>
<br/>
<br/>
<b>MOD</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n1 n2 --- mod &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Leave the remainder of n1/n2, with the same sign as n1.<br/>
<br/>
<br/>
<b>NEXT</b><br/>
<br/>
This is the inner interpreter that uses the interpretive IP to execute compiled<br/>
Forth definitions. &nbsp;It is not directly executed but is the return point for all<br/>
code procedures. &nbsp;It acts by fetching the address pointed by IP, and storing this<br/>
value in register W. &nbsp;It then jumps to the address pointed to by the address<br/>
pointed to by W. &nbsp;W points to the code field of a definition which contains the<br/>
address of the code which executes for that definition. &nbsp;This usage of indirect<br/>
threaded code is a major contributor to the power, portability, and extensibility<br/>
of Forth.<br/>
<br/>
<br/>
<b>NFA</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pfa --- nfa<br/>
<br/>
Convert the parameter field address of a definition to its name field. See PFA.<br/>
<br/>
<br/>
<b>NUMBER</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;addr --- d<br/>
<br/>
Convert a character string left at addr with a preceding count, to a signed<br/>
double number, using the current numeric base. &nbsp;If a decimal point is encountered<br/>
in the text, its position will be given in DPL, but no other effect occurs. &nbsp;If<br/>
numeric conversion is not possible, an error message will be given.<br/>
<br/>
<br/>
<b>OFFSET</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;U<br/>
<br/>
A user variable which may contain a block offset to disc drives. &nbsp;The contents of<br/>
OFFSET is added to the stack number by BLOCK. &nbsp;Messages by MESSAGE are independent<br/>
of OFFSET. &nbsp;See BLOCK, DR0, DR1, MESSAGE.<br/>
<br/>
<br/>
<b>OR</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n1 n2 --- or &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
Leave the bit-wise logical "OR" of two l6 bit values.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;110
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>OUT</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;U<br/>
<br/>
A user variable that contains a value incremented by EMIT. &nbsp;The user may alter and<br/>
examine OUT to control display formatting.<br/>
<br/>
<br/>
<b>OVER</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n1 n2 --- n1 n2 n1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
Copy the second stack value, placing it as the new top.<br/>
<br/>
<br/>
<b>PAD</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
Leave the address of the text output buffer, which is a fixed offset above HERE.<br/>
<br/>
<br/>
<b>PFA</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;nfa --- pfa<br/>
<br/>
Convert the name field address of a compiled definition to its parameter field<br/>
address.<br/>
<br/>
<br/>
<b>POP</b><br/>
<br/>
The code sequence to remove a stack value and return to NEXT. &nbsp;POP is not directly<br/>
executable, but is s Forth re-entry point after machine code.<br/>
<br/>
<br/>
<b>PREV</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --- addr<br/>
<br/>
A variable containing the address of the disc buffer most recently referenced.<br/>
The UPDATE command marks this buffer to be later written to disc.<br/>
<br/>
<br/>
<b>PUSH</b><br/>
<br/>
This code sequence pushes machine registers to the computation stack and returns<br/>
to NEXT. &nbsp;It is not directly executable, but is a Forth re-entry point after<br/>
machine code.<br/>
<br/>
<br/>
<b>PUT</b><br/>
<br/>
This code sequence stores machine register contents over the topmost computation<br/>
value and returns to NEXT. &nbsp;It is not directly executable, but is a Forth re-entry<br/>
point after machine code.<br/>
<br/>
<br/>
<b>QUERY</b><br/>
<br/>
Input 80 characters of text (or until a "return") from the operator's terminal.<br/>
Text is positioned at the address contained in TIB with IN set to zero.<br/>
<br/>
<br/>
<b>QUIT</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L1<br/>
<br/>
Clear the return stack, stop compilation, and return control to the operator's<br/>
terminal. &nbsp;No message is given.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
111
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>R</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- n<br/>
<br/>
Copy the top of the return stack to the computation stack.<br/>
<br/>
<br/>
<b>R#</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;U<br/>
<br/>
A user variable which may contain the location of an editing cursor, or other file<br/>
related function.<br/>
<br/>
<br/>
<b>R/W</b> &nbsp; &nbsp; &nbsp; &nbsp; addr blk f ---<br/>
<br/>
The Fig-FORTH standard read-write linkage. &nbsp;addr specifies the source or<br/>
destination block buffer. &nbsp;blk is the sequential number of the referenced block;<br/>
and f is a flag for f=0 write and f=1 read. &nbsp;R/W determines the location on mass<br/>
storage, performs the read-write and any error checking.<br/>
<br/>
<br/>
<b>R&gt;</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --- n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Remove the top value from the return stack and leave it on the computation stack.<br/>
See &gt;R and R.<br/>
<br/>
<br/>
<b>R0</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;U<br/>
<br/>
A user variable containing the initial location of the return stack. &nbsp;Pronounced<br/>
R-zero. &nbsp;See RP!<br/>
<br/>
<br/>
<b>REPEAT</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;addr n --- (compiling) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P,C2<br/>
<br/>
Used within a colon-definition in the form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BEGIN &nbsp;... &nbsp;WHILE &nbsp;... &nbsp;REPEAT<br/>
At run-time, REPEAT forces an unconditional branch back to just after the<br/>
corresponding BEGIN.<br/>
<br/>
At compile-time, REPEAT compiles BRANCH and the offset from HERE to addr. &nbsp;n is<br/>
used for error testing.<br/>
<br/>
<br/>
<b>ROT</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n1 n2 n3 --- n2 n3 n1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0<br/>
<br/>
Rotate the top three values on the stack, bringing the third to the top.<br/>
<br/>
<br/>
<b>RP@</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr<br/>
<br/>
Leaves the current value in the return stack pointer register.<br/>
<br/>
<br/>
<b>RP!</b><br/>
<br/>
A computer dependent procedure to initialise the return stack pointer from user<br/>
variable R0.<br/>
<br/>
<br/>
<b>S-&gt;D</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n --- d<br/>
<br/>
Sign extend a single number to form a double number.<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;112
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>S0</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;U<br/>
<br/>
A user variable that contains the initial value for the stack pointer. &nbsp;Pronounced<br/>
S-zero. &nbsp;See SP!<br/>
<br/>
<br/>
<b>SCR</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;U<br/>
<br/>
A user variable containing the screen number most recently reference by LIST.<br/>
<br/>
<br/>
<b>SIGN</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n d --- d &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Stores an ASCII "-" &nbsp;sign just before a converted numeric output string in the<br/>
text output buffer when n is negative. &nbsp;n is discarded, but double number d is<br/>
maintained. &nbsp;Must be used between &lt;# and #&gt;.<br/>
<br/>
<br/>
<b>SMUDGE</b><br/>
<br/>
Used during word definition to toggle the "smudge bit" in a definition's name<br/>
field. &nbsp;This prevents an uncompleted definition from being found during dictionary<br/>
searches, until compiling is completed without error.<br/>
<br/>
<br/>
<b>SP!</b><br/>
<br/>
A computer dependent procedure to initialize the stack pointer from S0.<br/>
<br/>
<br/>
<b>SP@</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- addr<br/>
<br/>
A computer dependent procedure to return the address of the stack position to the<br/>
top of the stack, as it was before SP@ was executed. (e.g. 1 2 SP@ @ . . . would<br/>
print 2 2 1).<br/>
<br/>
<br/>
<b>SPACE</b><br/>
<br/>
Transmit an ASCII blank to the output device.<br/>
<br/>
<br/>
<b>SPACES</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Transmit n ASCII blanks to the output device.<br/>
<br/>
<br/>
<b>STATE</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L0,U<br/>
<br/>
A user variable containing the compilation state. &nbsp;A non-zero indicates<br/>
compilation. &nbsp;The value itself may be implementation dependent.<br/>
<br/>
<br/>
<b>SWAP</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n1 n2 --- n2 n1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Exchange the top two values On the stack.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
113
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>TASK</b><br/>
<br/>
A no-operation word which can mark the boundary between applications. &nbsp;By<br/>
forgetting TASK and re-compiling, an application can be discarded in its entirety.<br/>
<br/>
<br/>
<b>TEXT</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c ---<br/>
<br/>
Accept the following test to PAD. &nbsp;c is the text delimiter.<br/>
<br/>
<b>THEN</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P,C0,L0<br/>
<br/>
An alias for ENDIF.<br/>
<br/>
<br/>
<b>TIB</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;U<br/>
<br/>
A user variable containing the address of the terminal input buffer.<br/>
<br/>
<br/>
<b>TOGGLE</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;addr b ---<br/>
<br/>
Complement the contents of addr by the bit pattern b.<br/>
<br/>
<br/>
<b>TRAVERSE</b> &nbsp; &nbsp; &nbsp; addr1 n --- addr2<br/>
<br/>
Move across the name field of a Fig-FORTH variable length name field. &nbsp;addr1 is<br/>
the address of either the length byte or the last letter. &nbsp;If n=-1, the motion is<br/>
toward low memory. &nbsp;The addr2 resulting is the address of the other end of the<br/>
name.<br/>
<br/>
<br/>
<b>TYPE</b> &nbsp; &nbsp; &nbsp; &nbsp;addr count --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Transmit count characters from addr to the selected output device.<br/>
<br/>
<br/>
<b>U&lt;</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u1 u2 --- f<br/>
<br/>
Leave the boolean value of an unsigned less-than comparison. &nbsp;Leaves f=1 for u1 &gt;<br/>
u2; otherwise leaves 0. &nbsp;This function should be used when comparing memory<br/>
addresses.<br/>
<br/>
<br/>
<b>U*</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u1 u2 --- ud<br/>
<br/>
Leave the unsigned double number product of two unsigned numbers.<br/>
<br/>
<br/>
<b>U.</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u ---<br/>
<br/>
Prints an unsigned 16 bit number converted according to BASE. A trailing blank<br/>
follows.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;114
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>U/</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ud u1 --- u2 u3<br/>
<br/>
Leave the unsigned remainder u2 and unsigned quotient u3 from the unsigned double<br/>
dividend ud and unsigned divisor u1.<br/>
<br/>
<br/>
<b>UNTIL</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;f --- (run-time)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr n --- (compile) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P,C2,L0<br/>
<br/>
Occurs within a colon-definition in the form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;BEGIN ... UNTIL<br/>
At run-time, UNTIL controls the conditional branch back to the corresponding<br/>
BEGIN. &nbsp;If f is false, execution returns to just after BEGIN, if true, execution<br/>
continues ahead.<br/>
<br/>
At compile-time, UNTIL compiles (0BRANCH) and an offset from HERE to addr. &nbsp;n is<br/>
used for error tests.<br/>
<br/>
<br/>
<b>UPDATE</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Marks the most recently referenced block (pointed to by PREV) as altered. &nbsp;The<br/>
block will subsequently be transferred to disc should its buffer be required for<br/>
storage of a different block.<br/>
<br/>
<br/>
<b>USE</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- addr<br/>
<br/>
A variable containing the address of the block buffer to use next, as the least<br/>
recently written.<br/>
<br/>
<br/>
<b>USER</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
A defining word used in the form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n USER cccc<br/>
which creates a user variable cccc. &nbsp;The parameter field of cccc contains n as a<br/>
fixed offset relative to the user pointer register UP for this upper variable.<br/>
When cccc is later executed, it places the sum of its offset and the user base<br/>
address on the stack, as the storage address of that particular variable.<br/>
<br/>
<br/>
<b>VARIABLE</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;E,L0<br/>
<br/>
A defining word used in the form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n VARIABLE cccc<br/>
When VARIABLE is executed, it creates the definition cccc with its parameter field<br/>
initialised to n. &nbsp;When cccc is later executed, the address of its parameter field<br/>
(containing n) is left on the stack, so that a fetch or store may access this<br/>
location.<br/>
<br/>
<br/>
<b>VOC-LINK</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;U<br/>
<br/>
A user variable containing the address of a field in the definition of the most<br/>
recently created vocabulary. &nbsp;All vocabulary names are linked by these fields, to<br/>
allow control for FORGETting through multiple vocabularies.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
115
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>VOCABULARY</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; E,L<br/>
<br/>
A defining word used in the form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;VOCABULARY cccc<br/>
to create a vocabulary definition cccc. &nbsp;Subsequent use of cccc will make it the<br/>
CONTEXT vocabulary which is searched first by INTERPRET. &nbsp;The sequence "cccc<br/>
DEFINITIONS" will also make cccc the CURRENT vocabulary, into which, new<br/>
definitions are placed.<br/>
<br/>
In Fig-FORTH, cccc will also be chained so as to include all definitions of the<br/>
vocabulary in which cccc is itself defined. All vocabularies ultimately chain to<br/>
Forth. &nbsp;By convention, vocabulary names are to be declared IMMEDIATE. &nbsp;See<br/>
VOC-LINK.<br/>
<br/>
<br/>
<b>VLIST</b><br/>
<br/>
List the names of the definitions in the context vocabulary. &nbsp;Pressing "Break"<br/>
will terminate the listing.<br/>
<br/>
<br/>
<b>WARNING</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;U<br/>
<br/>
A user variable containing a value controlling messages.<br/>
If = 1 disc is present, and screen 4 of drive 0 is the base location for messages.<br/>
If = 0, no disc is present and messages will be presented by number. &nbsp;If = -1,<br/>
execute (ABORT) &nbsp;for a user specified procedure. &nbsp;See MESSAGE, ERROR, ABORT.<br/>
<br/>
<br/>
<b>WHERE</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n1 n2 ---<br/>
<br/>
If an error occurs during LOAD from disc, ERROR leaves these values on the stack<br/>
to show the user where the error occurred. WHERE uses these to print the screen<br/>
and line number of where this is.<br/>
<br/>
<br/>
<b>WHILE</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;f --- (run-time)<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr1 n1 --- addr1 n1 addr2 n2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P,C2<br/>
<br/>
Occurs in a colon-definition in the form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BEGIN ... WHILE (tp) ... REPEAT<br/>
At run-time, WHILE selects conditional execution based on boolean flag f. &nbsp;If f is<br/>
true (non-zero), WHILE continues execution of the true part through to REPEAT,<br/>
which then branches back to BEGIN. &nbsp;If f is false (zero), execution skips to just<br/>
after REPEAT, exiting the structure.<br/>
<br/>
At compile time, WHILE emplaces (0BRANCH) and leaves addr2 of the reserved offset.<br/>
The stack values will be resolved by REPEAT.<br/>
<br/>
<br/>
<b>WIDTH</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- addr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;U<br/>
<br/>
In Fig-FORTH, a user variable containing the maximum number of letters saved in<br/>
the compilation of a definitions name. &nbsp;It must be 1 through to 31, having a<br/>
default value of 31. &nbsp;The name character count and its natural characters are<br/>
saved, up to the value of WIDTH. &nbsp;The value may be changed at any time within the<br/>
above limits.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;116
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>WORD</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c --- &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L0<br/>
<br/>
Read the next text characters from the input stream being interpreted, until a<br/>
delimiter c is found, storing the packed character string beginning at the<br/>
dictionary buffer HERE. WORD leaves the character count in the first byte, the<br/>
characters, and ends with two or more blanks. &nbsp;Leading occurrences of c are<br/>
ignored. &nbsp;If BLK is zero, text is taken from the terminal input buffer, otherwise<br/>
from the disc block stored in BLK. &nbsp;See BLK, IN.<br/>
<br/>
<br/>
<b>X</b><br/>
<br/>
This is pseudonym for the "null" or dictionary entry for a name of one character<br/>
of ASCII null. &nbsp;It is the execution procedure to terminate interpretation of a<br/>
line of text from the terminal or within a disc buffer, as both buffers always<br/>
have a null at the end.<br/>
<br/>
<br/>
<b>XOR</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;n1 n2 --- xor &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L1<br/>
<br/>
Leave the bit-wise logical Exclusive-OR of two values.<br/>
<br/>
<br/>
<b>[</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P,L1<br/>
<br/>
Used in a colon-definition in the form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : xxx &nbsp; words &nbsp; more &nbsp; ;<br/>
Suspend &nbsp;compilation. &nbsp;The words after [ are executed, not compiled. &nbsp;This allows<br/>
calculation or compilation exceptions before resuming compilation with ]. &nbsp;See<br/>
LITERAL, ].<br/>
<br/>
<br/>
<b>[COMPILE]</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;P,C<br/>
<br/>
Used in a colon-definition in the form:<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : xxx [COMPILE] FORTH &nbsp;;<br/>
[COMPILE] will force the compilation of an immediate definition, that would<br/>
otherwise execute during compilation. The above example will select the FORTH<br/>
vocabulary when xxx executes, rather than at compile time.<br/>
<br/>
<br/>
<b>]</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; L1<br/>
<br/>
Resume compilation, to the completion of a colon-definition. &nbsp;See [.<br/>
<br/>
<br/>
<br/>
<b>ADDITIONAL GLOSSARY</b><br/>
<br/>
<br/>
<b>C/L</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--- n<br/>
<br/>
A constant containing the number of characters per line (64).<br/>
<br/>
<br/>
<b>WARM</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ---<br/>
<br/>
This will perform a warm-start.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
117
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>NOOP</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ---<br/>
<br/>
This will perform a no-operation, i.e. do nothing.<br/>
<br/>
<br/>
<b>WARM-&gt;COLD</b><br/>
<br/>
This allows you to preserve any FORTH word defined to date, so that a COLD start<br/>
will not delete them. &nbsp;When saving your code, save from 24832 to HERE.<br/>
<br/>
e.g. &nbsp;: NEWWORD ." THIS WILL BE PRESERVED BY WARM-&gt;COLD " ;<br/>
<br/>
If we now do a COLD start this will be lost, but if we first key in WARM-&gt;COLD and<br/>
then do a COLD start, it will still be there.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;118
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>IDEAL GLOSSARY</b><br/>
<br/>
<br/>
<b>WORD</b> &nbsp; &nbsp; <b>PARAMETERS</b> &nbsp; &nbsp; &nbsp; &nbsp; <b>ACTION</b><br/>
<br/>
<b>WCRV</b> &nbsp; &nbsp; HGT, LEN, COL, &nbsp; &nbsp; Scroll the window vertically with wrap by<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW, NPX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NPX pixels.<br/>
<br/>
<b>SCRV</b> &nbsp; &nbsp; HGT, LEN, COL, &nbsp; &nbsp; Scroll the window vertically without<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW, NPX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wrap by NPX pixels.<br/>
<br/>
<b>WRR1V</b> &nbsp; &nbsp;HGT, LEN, COL, &nbsp; &nbsp; Scroll the window 1 pixel right with wrap.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW<br/>
<br/>
<b>WRL1V</b> &nbsp; &nbsp;HGT, LEN, COL, &nbsp; &nbsp; Scroll the window 1 pixel left with wrap.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW<br/>
<br/>
<b>WRR4V</b> &nbsp; &nbsp;HGT, LEN, COL, &nbsp; &nbsp; Scroll the window 4 pixels right with wrap.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW<br/>
<br/>
<b>WRL4V</b> &nbsp; &nbsp;HGT, LEN, COL, &nbsp; &nbsp; Scroll the window 4 pixels left with wrap.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW<br/>
<br/>
<b>WRR8V</b> &nbsp; &nbsp;HGT, LEN, COL, &nbsp; &nbsp; Scroll the window 8 pixels right with wrap.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW<br/>
<br/>
<b>WRL8V</b> &nbsp; &nbsp;HGT, LEN, COL, &nbsp; &nbsp; Scroll the window 8 pixels left with wrap.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW<br/>
<br/>
<b>SCR1V</b> &nbsp; &nbsp;HGT, LEN, COL, &nbsp; &nbsp; Scroll the window 1 pixel right without<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;wrap.<br/>
<br/>
<b>SCL1V</b> &nbsp; &nbsp;HGT, LEN, COL, &nbsp; &nbsp; Scroll the window 1 pixel left without<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;wrap.<br/>
<br/>
<b>SCR4V</b> &nbsp; &nbsp;HGT, LEN, COL, &nbsp; &nbsp; Scroll the window 4 pixels right without<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;wrap.<br/>
<br/>
<b>SCL4V</b> &nbsp; &nbsp;HGT, LEN, COL, &nbsp; &nbsp; Scroll the window 4 pixels left without<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;wrap.<br/>
<br/>
<b>SCR8V</b> &nbsp; &nbsp;HGT, LEN, COL, &nbsp; &nbsp; Scroll the window 8 pixels right without<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;wrap.<br/>
<br/>
<b>SCL8V</b> &nbsp; &nbsp;HGT, LEN, COL, &nbsp; &nbsp; Scroll the window 8 pixels left without<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;wrap.<br/>
<br/>
<b>ATTRV</b> &nbsp; &nbsp;HGT, LEN, COL, &nbsp; &nbsp; Scroll the window attributes 1 character<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;right with wrap.<br/>
<br/>
<b>ATTLV</b> &nbsp; &nbsp;HGT, LEN, COL, &nbsp; &nbsp; Scroll the window attributes 1 character<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;left with wrap.<br/>
<br/>
<b>ATTUPV</b> &nbsp; HGT, LEN, COL, &nbsp; &nbsp; Scroll the window attributes 1 character<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;up with wrap.<br/>
<br/>
<b>ATTDNV</b> &nbsp; HGT, LEN, COL, &nbsp; &nbsp; Scroll the window attributes 1 character<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;down with wrap.<br/>
<br/>
<b>WCRM</b> &nbsp; &nbsp; SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Scroll the Sprite vertically with wrap by<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NPX pixels.<br/>
<br/>
<br/>
<br/>
119
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>SCRM</b> &nbsp; &nbsp; SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Scroll the Sprite vertically without wrap<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; by NPX pixels.<br/>
<br/>
<b>WRR1M</b> &nbsp; &nbsp;SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Scroll the Sprite 1 pixel right with wrap.<br/>
<br/>
<b>WRL1M</b> &nbsp; &nbsp;SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Scroll the Sprite 1 pixel left with wrap.<br/>
<br/>
<b>WRR4M</b> &nbsp; &nbsp;SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Scroll the Sprite 4 pixels right with wrap.<br/>
<br/>
<b>WRL4M</b> &nbsp; &nbsp;SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Scroll the Sprite 4 pixels left with wrap.<br/>
<br/>
<b>WRR8M</b> &nbsp; &nbsp;SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Scroll the Sprite 8 pixels right with wrap.<br/>
<br/>
<b>WRL8M</b> &nbsp; &nbsp;SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Scroll the Sprite 8 pixels left with wrap.<br/>
<br/>
<b>SCR1M</b> &nbsp; &nbsp;SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Scroll the Sprite 1 pixel right without wrap.<br/>
<br/>
<b>SCL1M</b> &nbsp; &nbsp;SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Scroll the Sprite 1 pixel left without wrap.<br/>
<br/>
<b>SCR4M</b> &nbsp; &nbsp;SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Scroll the Sprite 4 pixels right without wrap.<br/>
<br/>
<b>SCL4M</b> &nbsp; &nbsp;SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Scroll the Sprite 4 pixels left without wrap.<br/>
<br/>
<b>SCR8M</b> &nbsp; &nbsp;SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Scroll the Sprite 8 pixels right without wrap.<br/>
<br/>
<b>SCL8M</b> &nbsp; &nbsp;SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Scroll the Sprite 8 pixels left without wrap.<br/>
<br/>
<b>ATTRM</b> &nbsp; &nbsp;SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Scroll the Sprite attributes 1 character<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right with wrap.<br/>
<br/>
<b>ATTLM</b> &nbsp; &nbsp;SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Scroll the Sprite attributes 1 character<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left with wrap.<br/>
<br/>
<b>ATTUPM</b> &nbsp; SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Scroll the Sprite attributes 1 character<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; up with wrap.<br/>
<br/>
<b>ATTDNM</b> &nbsp; SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Scroll the Sprite attributes 1 character<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; down with wrap.<br/>
<br/>
<b>GETBLS</b> &nbsp; SPN, COL, ROW &nbsp; &nbsp; &nbsp;Block move screen data from screen to<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sprite.<br/>
<br/>
<b>GETXRS</b> &nbsp; SPN, COL, ROW &nbsp; &nbsp; &nbsp;Logically XOR screen data into Sprite data.<br/>
<br/>
<b>GETORS</b> &nbsp; SPN, COL, ROW &nbsp; &nbsp; &nbsp;Logically OR screen data into Sprite data.<br/>
<br/>
<b>GETNDS</b> &nbsp; SPN, COL, ROW &nbsp; &nbsp; &nbsp;Logically AND screen data into Sprite data.<br/>
<br/>
<b>PUTBLS</b> &nbsp; SPN, COL, ROW &nbsp; &nbsp; &nbsp;Block move Sprite data from Sprite to<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; screen.<br/>
<br/>
<b>PUTXRS</b> &nbsp; SPN, COL, ROW &nbsp; &nbsp; &nbsp;Logically XOR Sprite data into screen data.<br/>
<br/>
<b>PUTORS</b> &nbsp; SPN, COL, ROW &nbsp; &nbsp; &nbsp;Logically OR Sprite data into screen data.<br/>
<br/>
<b>PUTNDS</b> &nbsp; SPN, COL, ROW &nbsp; &nbsp; &nbsp;Logically AND Sprite data into screen data.<br/>
<br/>
<b>GWBLS</b> &nbsp; &nbsp;SPN, COL, ROW, &nbsp; &nbsp; Block move screen data from screen window<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SCOL, SROW, HGT, &nbsp; into Sprite window.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LEN.<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;120
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>GWXRS</b> &nbsp; &nbsp;SPN, COL, ROW, &nbsp; &nbsp; Logically XOR screen data from screen window<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SCOL, SROW, HGT, &nbsp; into Sprite window.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LEN<br/>
<br/>
<b>GWORS</b> &nbsp; &nbsp;SPN, COL, ROW, &nbsp; &nbsp; Logically OR screen data from screen window<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SCOL, SROW, HGT, &nbsp; into Sprite window.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LEN<br/>
<br/>
<b>GWNDS</b> &nbsp; &nbsp;SPN, COL, ROW, &nbsp; &nbsp; Logically AND screen data from screen window<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SCOL, SROW, HGT, &nbsp; into Sprite window.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LEN<br/>
<br/>
<b>GWATTS</b> &nbsp; SPN, COL, ROW, &nbsp; &nbsp; Block move attributes from screen window into<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SCOL, SROW, HGT, &nbsp; Sprite window.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LEN<br/>
<br/>
<b>PWBLS</b> &nbsp; &nbsp;SPN, COL, ROW, &nbsp; &nbsp; Block move Sprite data from Sprite window<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SCOL, SROW, HGT, &nbsp; into screen window.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LEN<br/>
<br/>
<b>PWXRS</b> &nbsp; &nbsp;SPN, COL, ROW, &nbsp; &nbsp; Logically XOR Sprite window data into screen<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SCOL, SROW, HGT, &nbsp; window.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LEN<br/>
<br/>
<b>PWORS</b> &nbsp; &nbsp;SPN, COL, ROW, &nbsp; &nbsp; Logically OR Sprite window data into screen<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SCOL, SROW, HGT, &nbsp; window.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LEN<br/>
<br/>
<b>PWNDS</b> &nbsp; &nbsp;SPN, COL, ROW, &nbsp; &nbsp; Logically AND Sprite window data into screen<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SCOL, SROW, HGT, &nbsp; window.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LEN<br/>
<br/>
<b>PWATTS</b> &nbsp; SPN, COL, ROW, &nbsp; &nbsp; Block move Sprite window attributes into<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SCOL, SROW, HGT, &nbsp; screen window.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LEN<br/>
<br/>
<b>GWBLM</b> &nbsp; &nbsp;SP1, SP2, SCOL, &nbsp; &nbsp;Block move Sprite SP1 into Sprite SP2 at<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SCOL,SROW.<br/>
<br/>
<b>GWXRM</b> &nbsp; &nbsp;SP1, SP2, SCOL, &nbsp; &nbsp;Logically XOR Sprite SP1 into Sprite SP2<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; at SCOL,SROW.<br/>
<br/>
<b>GWORM</b> &nbsp; &nbsp;SP1, SP2, SCOL, &nbsp; &nbsp;Logically OR Sprite SP1 into Sprite SP2 at<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SCOL,SROW.<br/>
<br/>
<b>GWNDM</b> &nbsp; &nbsp;SP1, SP2, SCOL, &nbsp; &nbsp;Logically AND Sprite SP1 into Sprite SP2<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; at SCOL,SROW.<br/>
<br/>
<b>GWATTM</b> &nbsp; SP1, SP2, SCOL, &nbsp; &nbsp;Block move attributes of Sprite SP1 into<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sprite SP2 at SCOL,SROW.<br/>
<br/>
<b>PWBLM</b> &nbsp; &nbsp;SP1, SP2, SCOL, &nbsp; &nbsp;Block move window at SCOL,SROW of Sprite<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SP2 into Sprite SP1.<br/>
<br/>
<b>PWXRM</b> &nbsp; &nbsp;SP1, SP2, SCOL, &nbsp; &nbsp;Logically XOR window at SCOL,SROW of Sprite<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SP2 into Sprite SP1.<br/>
<br/>
<b>PWORM</b> &nbsp; &nbsp;SP1, SP2, SCOL, &nbsp; &nbsp;Logically OR window at SCOL,SROW of Sprite<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SP2 into Sprite SP1.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
121
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>PWNDM</b> &nbsp; &nbsp;SP1, SP2, SCOL, &nbsp; &nbsp;Logically AND window at SCOL,SROW of Sprite<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SP2 into Sprite SP1.<br/>
<br/>
<b>PWATTM</b> &nbsp; SP1, SP2, SCOL, &nbsp; &nbsp;Block move attributes of window at<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SCOL,SROW of Sprite SP2 into Sprite SP1.<br/>
<br/>
<b>COPYM</b> &nbsp; &nbsp;SP1, SP2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; As GWBLM but SCOL,SROW assumed zero.<br/>
<br/>
<b>COPXRM</b> &nbsp; SP1, SP2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; As GWXRM but SCOL,SROW assumed zero.<br/>
<br/>
<b>COPORM</b> &nbsp; SP1, SP2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; As GWORM but SCOL,SROW assumed zero.<br/>
<br/>
<b>COPNDM</b> &nbsp; SP1, SP2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; As GWNDM but SCOL,SROW assumed zero.<br/>
<br/>
<b>COPATTM</b> &nbsp;SP1, SP2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; As GWATTM but SCOL,SROW assumed zero.<br/>
<br/>
<b>INVV</b> &nbsp; &nbsp; HGT, LEN, COL, &nbsp; &nbsp; Invert screen window.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW<br/>
<br/>
<b>MIRV</b> &nbsp; &nbsp; HGT, LEN, COL, &nbsp; &nbsp; Mirror screen window about its centre.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW<br/>
<br/>
<b>MARV</b> &nbsp; &nbsp; HGT, LEN, COL, &nbsp; &nbsp; Mirror screen window attributes about<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;centre.<br/>
<br/>
<b>INVM</b> &nbsp; &nbsp; SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Invert Sprite data.<br/>
<br/>
<b>MIRM</b> &nbsp; &nbsp; SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Mirror Sprite about its centre.<br/>
<br/>
<b>MARM</b> &nbsp; &nbsp; SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Mirror Sprite attributes about centre.<br/>
<br/>
<b>SPINM</b> &nbsp; &nbsp;SP1, SP2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Rotate Sprite SP2 90 degrees clockwise<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; into Sprite SP1.<br/>
<br/>
<b>DSPM</b> &nbsp; &nbsp; SP1, SP2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Enlarge Sprite SP2 into Sprite SP1.<br/>
<br/>
<b>HALT</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Suspend CPU operation until next interrupt.<br/>
<br/>
<b>EI</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Enable interrupt.<br/>
<br/>
<b>DI</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Disable interrupt.<br/>
<br/>
<b>EXX</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Exchange Ideal variables with the alternate<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Ideal variables.<br/>
<br/>
<b>INT-ON</b> &nbsp; FORTH WORD &nbsp; &nbsp; &nbsp; &nbsp; Execute specified Forth Word under interrupt.<br/>
<br/>
<b>INT-OFF</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Terminate execution of interrupt driven<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; word.<br/>
<br/>
<b>PROG</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Enter BASIC.<br/>
<br/>
<b>RESERVE</b> &nbsp;N1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reserve N1 bytes in the dictionary for<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BASIC source.<br/>
<br/>
<b>GOTO</b> &nbsp; &nbsp; N1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Begin execution of BASIC at line N1.<br/>
<br/>
<b>RETUSR</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Return to BASIC from RANDOMIZE USR 30000<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;122
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>DSPRITE</b> &nbsp;SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Delete Sprite and recover bytes from below.<br/>
<br/>
<b>ISPRITE</b> &nbsp;SPN, HGT, LEN &nbsp; &nbsp; &nbsp;Create Sprite and move current Sprites<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; down to accommodate.<br/>
<br/>
<b>WIPE</b> &nbsp; &nbsp; SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Delete Sprite and recover bytes from above.<br/>
<br/>
<b>SPRITE</b> &nbsp; SPN, HGT, LEN &nbsp; &nbsp; &nbsp;Create Sprite at free space after last<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sprite.<br/>
<br/>
<b>RELOCATE</b> MLEN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relocate Sprite space by signed 16 bit<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; length MLEN.<br/>
<br/>
<b>COLD#</b> &nbsp; &nbsp;SPST, SLEN &nbsp; &nbsp; &nbsp; &nbsp; Reset Sprite space to begin at SPST with<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SLEN bytes cleared to zeros.<br/>
<br/>
<b>SETAV</b> &nbsp; &nbsp;HGT, LEN, COL, &nbsp; &nbsp; Fill the screen window with the current<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;attributes.<br/>
<br/>
<b>SETAM</b> &nbsp; &nbsp;SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Fill the Sprite with the current attributes.<br/>
<br/>
<b>CLSV</b> &nbsp; &nbsp; HGT, LEN, COL, &nbsp; &nbsp; Clear the screen window and fill with the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;current attributes.<br/>
<br/>
<b>CLSM</b> &nbsp; &nbsp; SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Clear the Sprite.<br/>
<br/>
<b>ADJV</b> &nbsp; &nbsp; HGT, LEN, COL, &nbsp; &nbsp; Adjust the screen window to lie on the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;screen.<br/>
<br/>
<b>ADJM</b> &nbsp; &nbsp; SPN, COL, ROW &nbsp; &nbsp; &nbsp;Adjust COL, ROW, HGT, LEN, SCOL, SROW such<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; that GETS and PUTS lie on the screen.<br/>
<br/>
<b>RND</b> &nbsp; &nbsp; &nbsp;N1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Leave a random number between 0 and N1 on<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the stack.<br/>
<br/>
<b>OUT#</b> &nbsp; &nbsp; N1, N2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Output LSB of N1 to 16 bit port address N2.<br/>
<br/>
<b>IN#</b> &nbsp; &nbsp; &nbsp;N1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Leave on the stack, byte from 16 bit port<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; address N1.<br/>
<br/>
<b>ZAPINT</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Create run time program with interrupt<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; facility.<br/>
<br/>
<b>ZAP</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Create run time program without interrupt<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; facility.<br/>
<br/>
<b>CALL</b> &nbsp; &nbsp; N1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Execute machine code subroutine at address<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N1.<br/>
<br/>
<b>KB</b> &nbsp; &nbsp; &nbsp; N1, N2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Test for key press at row N1, col N2 and<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack true or false flag.<br/>
<br/>
<b>SCANV</b> &nbsp; &nbsp;COL, ROW &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The character position is scanned for screen<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data and a true or false flag stacked.<br/>
<br/>
<b>SCANM</b> &nbsp; &nbsp;SPN &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;The Sprite is scanned for data and a true<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or false flag stacked.<br/>
<br/>
<b>BLEEP</b> &nbsp; &nbsp;N1, N2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sinclair BEEP. &nbsp;N1 is duration, N2 is pitch.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
123
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>ATTON</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Enable attribute switch.<br/>
<br/>
<b>ATTOFF</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Disable attribute switch.<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>FORTH/BASIC GLOSSARY</b><br/>
<br/>
<br/>
<b>WORD</b> &nbsp; &nbsp; <b>PARAMETERS</b> &nbsp; &nbsp; &nbsp; &nbsp; <b>ACTION</b><br/>
<br/>
<b>COPY</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Copy screen to ZX-Printer.<br/>
<br/>
<b>AT</b> &nbsp; &nbsp; &nbsp; N1, N2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Move print position to N1,N2.<br/>
<br/>
<b>BORDER</b> &nbsp; N1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set border colour to N1.<br/>
<br/>
<b>CLS</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Clear whole screen, home cursor and fill<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; with current attributes.<br/>
<br/>
<b>DRAW-ARC</b> N1, N2, N3 &nbsp; &nbsp; &nbsp; &nbsp; &#177;X,&#177;Y,ANGLE. &nbsp;As Sinclair's own.<br/>
<br/>
<b>CIRCLE</b> &nbsp; N1, N2, N3 &nbsp; &nbsp; &nbsp; &nbsp; X,Y,RADIUS. &nbsp;As Sinclair's own.<br/>
<br/>
<b>DRAW</b> &nbsp; &nbsp; N1, N2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#177;X,&#177;Y. &nbsp;As Sinclair's own.<br/>
<br/>
<b>PLOT</b> &nbsp; &nbsp; N1, N2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X,Y. &nbsp;As Sinclair's own.<br/>
<br/>
<b>SCREEN$</b> &nbsp;N1, N2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Leave on the stack the ASCII code of the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; character at ROW N1, COL N2.<br/>
<br/>
<b>ATTR</b> &nbsp; &nbsp; N1, N2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Leave on the stack the attribute code of<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the character at ROW N1, COL N2.<br/>
<br/>
<b>POINT</b> &nbsp; &nbsp;N1, N2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Test pixel at N1,N2 and leave a true or<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; false flag on the stack.<br/>
<br/>
<b>TAB</b> &nbsp; &nbsp; &nbsp;N1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set print position to COL N1.<br/>
<br/>
<b>OVER</b> &nbsp; &nbsp; N1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Zero or one, as Sinclair's own.<br/>
<br/>
<b>INVERSE</b> &nbsp;N1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Zero or one, as Sinclair's own.<br/>
<br/>
<b>BRIGHT</b> &nbsp; N1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Zero or one, as Sinclair's own.<br/>
<br/>
<b>FLASH</b> &nbsp; &nbsp;N1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Zero or one, as Sinclair's own.<br/>
<br/>
<b>PAPER</b> &nbsp; &nbsp;N1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set paper colour, as Sinclair's own.<br/>
<br/>
<b>INK</b> &nbsp; &nbsp; &nbsp;N1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Set ink colour, as Sinclair's own.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;124
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<b>USR CALLS</b><br/>
<br/>
<br/>
<b>PRINT USR 24832</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Enter Forth from BASIC via a COLD START.<br/>
<br/>
<b>PRINT USR 24836</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Enter Forth from BASIC via a WARM START.<br/>
<br/>
<b>PRINT USR 30006</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Re-enter Forth from BASIC and continue<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; execution of the next Forth word.<br/>
<br/>
<b>RANDOMIZE USR 30000</b> &nbsp; &nbsp; &nbsp; &nbsp; Call Forth and continue execution<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; up to the first occurrence of the Forth<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; word RETUSR.<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>EXTENDED SPECTRA FORTH GLOSSARY</b><br/>
<br/>
<br/>
<b>WORD</b> &nbsp; &nbsp; <b>PARAMETERS</b> &nbsp; &nbsp; &nbsp; &nbsp; <b>ACTION</b><br/>
<br/>
<br/>
<b>PRT-ON</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Send all subsequent output to the printer.<br/>
<br/>
<b>PRT-OFF</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Send all subsequent output to the screen.<br/>
<br/>
<b>EDIT</b> &nbsp; &nbsp; N1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Edit line number N1 from the current screen.<br/>
<br/>
<b>WARM-&gt;COLD</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Create extended Forth.<br/>
<br/>
<b>J</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Copy second loop index to the top of the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack.<br/>
<br/>
<b>K</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Copy third loop index to the top of the<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack.<br/>
<br/>
<b>DUMP</b> &nbsp; &nbsp; N1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Memory dump from address N1.<br/>
<br/>
<b>WARM</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Perform a warm start.<br/>
<br/>
<b>EMITC</b> &nbsp; &nbsp;N1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; As EMIT but control characters are also<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; supported.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
125
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>THE DEMONSTRATION PROGRAM - A BRIEF DESCRIPTION</b><br/>
<br/>
<br/>
<b>THE WHITE LIGHTNING SCREEN</b><br/>
<br/>
The green text at the top of the screen, sprites 59 and 60, is scrolled right in<br/>
background.<br/>
<br/>
The lightning bolt, sprite 32, is put to the screen using PUTBLS. &nbsp;It is then<br/>
mirrored and then mirrored again using MIRV. It is removed from the screen using<br/>
PUTXRS.<br/>
<br/>
Two windows are defined over the 'WHITE LIGHTNING', sprites 30 and 31. &nbsp;The left<br/>
window is scrolled left and the right window scrolled right using SCL8V and SCR8V<br/>
respectively.<br/>
<br/>
<br/>
<b>THE TRAIN</b><br/>
<br/>
The steam engine is comprised of sprites 9, with sprites 18, 19, 20, and 21 for<br/>
the wheels in their four positions. &nbsp;The coaches are comprised of sprites 14 with<br/>
sprites 23 and 24 for the wheels.<br/>
<br/>
The track, sprite 10, is scrolled left using WRL1V. &nbsp;By means of an increasing and<br/>
decreasing delay loop, acceleration and deceleration effects are achieved.<br/>
<br/>
<br/>
<b>THE SPIDERS</b><br/>
<br/>
Five spiders, sprite 7, are placed on the screen. &nbsp;From the left, spider 1 is<br/>
scrolled down by 1 pixel, spider 3 is scrolled up 8 pixels and spider 5 is<br/>
scrolled up 4 pixels all - in background.<br/>
<br/>
Spiders 2 and 4 are animated up and down using sprites 7 and 8.<br/>
<br/>
<br/>
<b>THE SIDEWAYS SCROLLING CIRCLE OF INVADERS</b><br/>
<br/>
Twelve Invaders, sprite 24, are placed in a circle on the screen, using either<br/>
WRR1M, WRR4M or WRR8M they are scrolled in memory and then placed on the screen<br/>
using PUTBLS.<br/>
<br/>
The Invader in the centre of the screen is scrolled left by 1 pixel in<br/>
background.<br/>
<br/>
<br/>
<b>THE ARRAY OF CLOCKWORK TOYS</b><br/>
<br/>
The green clockwork toys are animated using sprites 49 and 50. &nbsp;Each sprite in the<br/>
array is individually placed on the screen using PUTBLS. &nbsp;The movement is<br/>
controlled by simple 'DO LOOPS'.<br/>
<br/>
<br/>
<b>THE VERTICAL ATTRIBUTE SCROLL</b><br/>
<br/>
Using ATTUPV and decreasing and increasing delay loops the attributes placed on<br/>
the screen are scrolled up, whilst a random border colour change is executed.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;126
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>THE THREE VEHICLE SCROLLING DEMO</b><br/>
<br/>
This demonstrates the 3 precisions of scrolls available - 1, 4 and 8 pixels.<br/>
<br/>
Sprite 1, the vintage car, demonstrates the fine 1 pixel scroll using SCL1V.<br/>
<br/>
Sprite 2, the van, demonstrates the faster 4 pixel scroll using SCL4V.<br/>
<br/>
Sprite 3, the dragster, demonstrates, the very fast 8 pixel, or 1 character<br/>
scroll, using SCL8V.<br/>
<br/>
<br/>
<b>THE TELEVISION</b><br/>
<br/>
The television, sprite 13, is placed on the screen, a window is defined inside the<br/>
screen.<br/>
<br/>
Sprite 5, the dancer is used to demonstrate the 1 pixel scroll with wrap, WRR1V.<br/>
<br/>
Sprite 4, the duck, is used to demonstrate the 4 pixel scroll with wrap, WRR4V.<br/>
<br/>
Sprite 6, the rocket, is used to demonstrate the 8 pixel scroll with wrap, WRR8V.<br/>
<br/>
<br/>
<b>THE THREE SPACESHIPS</b><br/>
<br/>
In this demonstration the 3 spaceships, sprite 15, are placed on the screen along<br/>
with their shadows, sprite 16.<br/>
<br/>
They are scrolled to the right by 1 pixel, with alternate 1 pixel up and down<br/>
scrolls, to give a sense of motion.<br/>
<br/>
The attributes of the foreground, sprite 17, and the background, sprite 11, are<br/>
scrolled to the left. &nbsp;The background being scrolled at one character per<br/>
execution with the foreground being scrolled two characters per execution to give<br/>
a sense of perspective.<br/>
<br/>
<br/>
<b>THE BOUNCING MAN WITH HAT</b><br/>
<br/>
The bouncing man is animated using sprites 28 and 29. &nbsp;The sprites are placed on<br/>
the screen using PUTXRS, and removed again using PUTXRS, such that the character<br/>
appears to move behind the 'WHITE LIGHTNING' text without destroying it.<br/>
<br/>
Simple DO LOOPS control his path.<br/>
<br/>
Disabling interrupts, using DI, during the animation appeared to reduce the slight<br/>
flicker of the character, the interrupts where enabled again using EI.<br/>
<br/>
<br/>
<b>THE CIRCLE OF ROTATING INVADERS</b><br/>
<br/>
From the original invader, sprite 24, sprites 25, 26 and 27 were created using the<br/>
'ROTATE' facility of the sprite development package.<br/>
<br/>
This demo shows how the centre invader, scrolling left by 1 pixel in background,<br/>
moves at a constant smooth rate, independent from that of the increasing and then<br/>
decreasing rate of the rotating invaders in the outer circle.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
127
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>THE PLAGUE OF CRABS</b><br/>
<br/>
The crabs, sprite 33, are placed on the screen using PUTBLS.<br/>
<br/>
The ROW and COL variables for the PUTBLS are loaded up each time by a random number<br/>
produced by using the Forth word RND.<br/>
<br/>
<br/>
<b>THE BOUNCING BALL</b><br/>
<br/>
This is a sprite or to be more precise, 4 sprites, moving in background. &nbsp;The ball<br/>
is defined in four orientations to give half character resolution. &nbsp;The movement<br/>
is obtained by doing a PUTXRS, calculating the next co-ordinates, blotting out the<br/>
old sprite with a second PUTXRS and then repeating the cycle. The listing for this<br/>
screen is given in section 3 under the heading - Programmable Sprites.<br/>
<br/>
<br/>
<b>THE LUNAR SPACE SHIP</b><br/>
<br/>
The radar dish on top of the space ship, sprite 34, is animated by sequentially<br/>
placing sprites 35 to 42, giving the effect of constant rotation.<br/>
<br/>
Just before the spaceship takes off, an explosion, sprite 43, is XORed over the<br/>
spaceship using PUTXRS. &nbsp;It is removed again by a second PUTXRS.<br/>
<br/>
The spaceship is then scrolled up in a vertical window by 1 pixel. &nbsp;The Lunar<br/>
surface, sprite 44, is also scrolled by 1 pixel, to the right using WRR1V.<br/>
<br/>
<br/>
<b>THE ROTATING BALLS</b><br/>
<br/>
Four sprites were used to give the impression of rotation, these being sprites 45,<br/>
46, 47, and 48.<br/>
<br/>
Once the sprites were created, animation was a simple process of sequentially<br/>
placing the sprites to the screen with an increasing and decreasing time delay<br/>
between each PUTBLS.<br/>
<br/>
<br/>
<b>THE CREDITS</b><br/>
<br/>
To achieve the text scrolling up from the bottom of the screen, the bottom line<br/>
was set with 0 INK and 0 PAPER colours, while the rest of the screen had 7 INK and<br/>
0 PAPER colours.<br/>
<br/>
Each line of text was printed into that line and then the whole screen scrolled up<br/>
8 * 1 pixel, such that the text data scrolls into the screen that has 7 INK<br/>
attributes and thus appears to smoothly scroll onto the screen.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;128
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>SOME SIMPLE PROGRAMMING EXAMPLES</b><br/>
<br/>
<b>Example 1</b><br/>
<br/>
To scroll a window at row 8, column 9, 5 characters high by 10 characters long, 1<br/>
pixel to the left with wrap - type:<br/>
<br/>
: DEM1 5 HGT ! 10 LEN ! 8 ROW ! 9 COL ! WRL1V ; &lt;CR&gt;<br/>
<br/>
To put some data on the screen: VLIST &lt;CR&gt;<br/>
<br/>
To scroll the window 100 times type:<br/>
<br/>
: DEM2 100 0 DO DEM1 LOOP ; &lt;CR&gt;<br/>
DEM2 &lt;CR&gt;<br/>
<br/>
To execute DEM1 in background type: ' DEM1 INT-ON &lt;CR&gt;<br/>
<br/>
To halt the background execution of DEM1 type: INT-OFF &lt;CR&gt;<br/>
<br/>
<br/>
<b>Example 2</b><br/>
<br/>
To scroll a window at column 12, row 3, 10 characters high and 5 characters wide,<br/>
downward by 3 pixels with wrap - type:<br/>
<br/>
: DEM3 10 HGT ! 5 LEN ! -3 NPX ! 2 ROW ! 12 COL ! WCRV ; &lt;CR&gt;<br/>
<br/>
to define the word, then: DEM3 &lt;CR&gt; to execute it.<br/>
<br/>
To run DEM3 in background type:<br/>
<br/>
' DEM3 INT-ON &lt;CR&gt;<br/>
<br/>
To halt the background execution type: INT-OFF &lt;CR&gt;<br/>
<br/>
<br/>
<b>Example 3</b><br/>
<br/>
To invert a window at column 10, row 5, 4 characters high and 4 characters wide -<br/>
type:<br/>
<br/>
: DEM4 4 HGT ! 4 LEN ! 5 ROW ! 10 COL ! INVV ; &lt;CR&gt;<br/>
<br/>
and then DEM4 &lt;CR&gt; to execute.<br/>
<br/>
<br/>
<b>Example 4</b><br/>
<br/>
It is not always necessary to use colon definitions to achieve a particular<br/>
result. &nbsp;To PUT sprite 34 (If you've got the Demo sprites loaded or have already<br/>
defined your own sprite 34) at row 5, column 6, and replace any data currently at<br/>
that position - type:<br/>
<br/>
34 SPN ! 5 ROW ! 6 COL ! PUTBLS &lt;CR&gt;<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
129
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>Example 5</b><br/>
<br/>
Often it is useful to define a word which carries out an operation that is used<br/>
frequently and which saves typing - for instance:<br/>
<br/>
: DEM5 COL ! ROW ! SPN ! PUTBLS ;<br/>
<br/>
If we wanted to carry out the simple PUT command in example 4 all we'd need to<br/>
type would be:<br/>
<br/>
34 5 6 DEM5<br/>
<br/>
<br/>
<b>Example 6</b><br/>
<br/>
To scroll sprite 29 in memory by 1 pixel to the right with wrap and PUT it on the<br/>
screen at row 10, column 11 - use:<br/>
<br/>
: DEM6 29 SPN ! 10 ROW ! 11 COL ! WRR1M PUTBLS ;<br/>
<br/>
To run DEM6 in background use: ' DEM6 INT-ON<br/>
<br/>
<br/>
<b>Example 7</b><br/>
<br/>
To fill a screen window, at column 17, row 5, 5 characters long and 10 characters<br/>
high, with the attributes - 6 INK, 2 PAPER and 1 FLASH - use the following:<br/>
<br/>
: DEM7 1 FLASH 6 INK 2 PAPER 10 HGT ! 5 LEN ! 13 ROW ! 17 COL ! SETAV 0 FLASH 7<br/>
INK 1 PAPER ;<br/>
<br/>
<br/>
<b>Example 8</b><br/>
<br/>
To change the green face of sprite 28 into a red one use:<br/>
<br/>
: DEM8 28 SPN ! 2 INK ! 1 BRIGHT 0 PAPER SETAM PUTBLS ;<br/>
<br/>
<br/>
<b>Example 9</b><br/>
<br/>
To pick a random number between 0 and 100 use:<br/>
<br/>
: DEM9 100 RND . ;<br/>
<br/>
<br/>
<b>Example 10</b><br/>
<br/>
To pick a random INK colour and change sprite 34's INK colour to this colour, and<br/>
then put it at column 10, row 10, use:<br/>
<br/>
: DEM10 7 RND INK 34 SPN ! SETAM 10 ROW ! 10 COL ! PUTBLS ;<br/>
<br/>
To run DEM10 in background use: ' DEM10 INT-ON and to halt DEM10 use INT-OFF.<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;130
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<b>Example 11</b><br/>
<br/>
To place sprite 24 into the screen of sprite 13 use:<br/>
<br/>
: DEM11 24 SP1 ! 13 SP2 ! 7 SCOL ! 6 SROW ! GWBLM 10 ROW ! 10 COL ! ATTON PUTBLS<br/>
;<br/>
<br/>
<br/>
<b>Example 12</b><br/>
<br/>
To XOR sprite 43, the explosion, with sprite 27, the 270 degree rotated Invader,<br/>
in memory, use:<br/>
<br/>
: DEM12 43 SP1 ! 27 SP2 ! COPXRM 10 ROW ! 10 COL ! 27 SPN ! ATTON PUTBLS ;<br/>
<br/>
<br/>
<b>Example 13</b><br/>
<br/>
To invert sprite 7, the spider, in memory use:<br/>
<br/>
: DEM13 7 SPN ! INVM 10 ROW ! 10 COL ! PUTBLS ;<br/>
<br/>
<br/>
<b>Example 14</b><br/>
<br/>
To enlarge sprite 24 into sprite 45 using the DSPM command use:<br/>
<br/>
: DEM14 45 SP1 ! 24 SP2 ! DSPM 45 SPN ! 10 COL ! 10 ROW ! PUTBLS ;<br/>
<br/>
<br/>
<b>Example 15</b><br/>
<br/>
To search through sprite space, locate any existing sprites, print out the start<br/>
of data, length and height, use:<br/>
<br/>
: DEM15 255 1 DO I SPN ! TEST 1 = IF I. SPACE DPTR @ U. SPACE LEN ? SPACE HGT ?<br/>
SPACE CR THEN LOOP ;<br/>
<br/>
<br/>
<b>Example 16</b><br/>
<br/>
To scroll a landscape sprite numbered 128, 2 characters high and 64 characters<br/>
wide, left by 1 pixel under interrupt, use the following:<br/>
<br/>
SCR # 6<br/>
&nbsp; 0 0 VARIABLE CL 8 VARIABLE PH : OPEN EXX 0 COL ! 12 ROW ! 2 HGT !<br/>
&nbsp; 1 0 SROW ! 0 SCOL ! 128 SPN ! 0 PAPER 6 INK 32 LEN ! CLSV 0 INK<br/>
&nbsp; 2 1 LEN ! CLSV 32 LEN ! PWBLS EXX ;<br/>
&nbsp; 3 : NXB CL @ 1+ DUP 64 = IF DROP 0 ENDIF DUP CL ! 31 + 64 MOD SCOL<br/>
&nbsp; 4 ! 1 LEN ! PWBLS 32 LEN ! ;<br/>
&nbsp; 5 : SL WRL1V PH @ 1- DUP 0= IF NXB DROP 8 ENDIF PH ! ;<br/>
&nbsp; 6 : GO 6 INK 0 PAPER 0 BORDER 1 BRIGHT CLS 14 ROW ! 1 COL !<br/>
&nbsp; 7 6 PAPER 31 LEN ! 4 HGT ! SETAV OPEN 6 INK ' SL INT-ON ;<br/>
<br/>
To speed this up to faster 4 or 8 pixel scrolls change lines 0 and 5 to read:<br/>
<br/>
&nbsp; 0 0 VARIABLE CL 2 VARIABLE PH : OPEN EXX 0 COL ! 12 ROW ! 2 HGT !<br/>
&nbsp; 5 : SL WRL4V PH @ 1- DUP 0= IF NXB DROP 2 ENDIF PH ! ;<br/>
<br/>
&nbsp; 0 0 VARIABLE CL 1 VARIABLE PH : OPEN EXX 0 COL ! 12 ROW ! 2 HGT !<br/>
&nbsp; 5 : SL WRL8V PH @ 1- DUP 0= IF NXB DROP 1 ENDIF PH ! ;<br/>
<br/>
Type: 6 LOAD &lt;CR&gt; to compile and GO &lt;CR&gt; to run.<br/>
<br/>
131
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
<br/>
<b>TRANSCRIBER'S NOTE</b><br/>
<br/>
While OCRing and proofreading the scans of the White Lightning manuals, I have<br/>
tried to preserve, as best as I was able, the original pagination, layout,<br/>
spacing and formatting of the originals - while still incorporating all errata<br/>
noted and published in previous versions, and with a few (small) edits and<br/>
corrections of my own.<br/>
<br/>
This transcription is still a work in progress. If you discover any further<br/>
mistakes, please create a pull request (or otherwise report the errors) against<br/>
the manuals' source repository at:<br/>
<br/>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; https://github.com/richmilne/white-lightning-manuals
<div style="page-break-after:always">-----------------------------------------------------------------------------------</div>
</body>